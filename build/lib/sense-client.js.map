{
  "version": 3,
  "sources": ["../../src/lib/sense-client.ts"],
  "sourcesContent": ["import { EventEmitter } from \"events\";\nimport WebSocket from \"ws\";\nimport axios from \"axios\";\nimport { SenseAuthResponse, SenseDevices } from \"../interfaces\"\nimport { stringify } from \"querystring\";\nimport memoize from \"memoizee\";\nimport { clearInterval } from \"timers\";\n\nconst API_URL = \"https://api.sense.com/apiservice/api/v1/\"\nconst WS_URL = \"wss://clientrt.sense.com/monitors/%id%/realtimefeed?access_token=%token%\"\n\nconst RECONNECT_INTERVAL = 10000; // Initial reconnect interval (10 seconds)\nconst MAX_RECONNECT_INTERVAL = 60000; // Maximum reconnect interval (60 seconds)\nconst PING_INTERVAL = 60000; // Send websocket ping every interval (60 seconds)\n\nconst API_MAX_AGE = 300000 // 5 minutes\nconst API_TIMEOUT = 5000 // 5 seconds\nconst WSS_TIMEOUT = 5000 // 5 seconds\n\nexport type SenseClientOptions = {\n    email: string;\n    password: string;\n}\n\ntype SenseWebSocketMessage = {\n    type: string;\n    payload: any;\n}\n\n/**\n * SenseClient is the main class for interacting with the Sense API.\n */\nexport class SenseClient extends EventEmitter {\n    private readonly _getDevicesMemoized;\n    private readonly httpsClient;\n    private options;\n    private pingTimer?: NodeJS.Timer;\n    private reconnectInterval = RECONNECT_INTERVAL;\n    private reconnectTimer?: NodeJS.Timeout;\n    private webSocket?: WebSocket;\n\n    /**\n     * Creates a new SenseClient instance.\n     */\n    constructor(options: SenseClientOptions) {\n        super();\n        this.options = options;\n        this.httpsClient = axios.create({\n            baseURL: API_URL,\n            timeout: API_TIMEOUT\n        });\n\n        // Memoize the getDevices function to prevent unnecessary requests to the Sense API\n        this._getDevicesMemoized = memoize(this._getDevices, { promise: true, maxAge: API_MAX_AGE });\n    }\n\n    private _account?: SenseAuthResponse;\n\n    /**\n     * The sense account property contains the SenseAuthResponse object returned by the Sense API.\n     */\n    get account(): Readonly<SenseAuthResponse> | undefined {\n        return this._account;\n    }\n\n    private _autoReconnect = true;\n\n    /**\n     * Returns if the autoReconnect function is enabled or disabled.\n     *\n     * @return A boolean value indicating if the autoReconnect function is enabled or disabled\n     */\n    get autoReconnect(): boolean {\n        return this._autoReconnect;\n    }\n\n    /**\n     * Sets the autoReconnect property to true or false.\n     *\n     * @param value: boolean Set the value of autoreconnect to true or false\n     */\n    set autoReconnect(value: boolean) {\n        this._autoReconnect = value;\n    }\n\n    /**\n     * The getDevices function is used to retrieve the devices associated with a monitor.\n     * This function is memoized to prevent unnecessary requests to the Sense API.\n     *\n     * @param monitorId: number Specify the monitor to get data from\n     *\n     * @return A sense device array\n     */\n    public async getDevices(monitorId: number): Promise<SenseDevices | undefined> {\n        return this._getDevicesMemoized(monitorId);\n    }\n\n    /**\n     * The logout function logs the user out of Sense.\n     */\n    public async logout(): Promise<void> {\n        await this.httpsClient.get(\"logout\");\n        this._account = undefined;\n        this.emit(\"logout\");\n    }\n\n    /**\n     * The start function is used to start the websocket connection that provides real-time energy data events.\n     * It will throw an error if you have not authenticated first.\n     */\n    public async start(): Promise<void> {\n        // Schedule a reconnect attempt in case of failure\n        this.scheduleReconnect();\n\n        if (!await this.authenticate()) {\n            return;\n        }\n\n        const id = String(this._account!.monitors[0].id);\n        const token = this._account!.access_token;\n        const wsUrl = WS_URL.replace(\"%id%\", id).replace(\"%token%\", token);\n        const ws = new WebSocket(wsUrl, [], {\n            timeout: WSS_TIMEOUT,\n        });\n        ws.on(\"open\", () => this.onConnected());\n        ws.on(\"message\", (event) => this.onMessage(event));\n        ws.on(\"close\", (code, reason) => this.onDisconnected(reason.toString()));\n        ws.on(\"error\", (error) => this.emit(\"error\", error));\n        ws.on(\"pong\", () => this.emit(\"pong\"));\n        this.webSocket = ws;\n    }\n\n    /**\n     * The stop function closes the websocket connection.\n     */\n    public async stop(): Promise<void> {\n        this.unscheduleReconnect();\n\n        if (this.pingTimer) {\n            clearInterval(this.pingTimer);\n            this.pingTimer = undefined;\n        }\n\n        if (this.webSocket) {\n            this.webSocket.close();\n            this.webSocket = undefined;\n        }\n    }\n\n    /**\n     * The getDevices function is used to retrieve the devices associated with a monitor.\n     *\n     * @param monitorId: number Specify the monitor to get data from\n     *\n     * @return A sense device array\n     */\n    private async _getDevices(monitorId: number): Promise<SenseDevices | undefined> {\n        const response = await this.httpsClient.get<SenseDevices>(\n            `monitors/${monitorId}/devices`).catch((error) => this.httpErrorHandler(error));\n        if (response?.data) {\n            console.log(JSON.stringify(response.data));\n            this.emit(\"devices\", response.data);\n            return response.data;\n        }\n    }\n\n    /**\n     * The authenticate function is used to authenticate the user with the Sense API.\n     * It uses the email and password provided in the options object to make a POST request\n     * to /authenticate endpoint, which returns an access token that will be used for subsequent requests.\n     *\n     * @returns true if the authentication was successful, false otherwise\n     */\n    private async authenticate(): Promise<boolean> {\n        this._account = undefined;\n        const response = await this.httpsClient.post<SenseAuthResponse>(\n            \"authenticate\", stringify({\n                email: this.options.email,\n                password: this.options.password,\n                remember_me: true\n            }), {\n                headers: {\n                    \"Content-Type\": \"application/x-www-form-urlencoded\"\n                }\n            }).catch((error) => this.httpErrorHandler(error));\n        if (response?.data?.authorized) {\n            this.httpsClient.defaults.headers.common[\"Authorization\"] = \"bearer \" + response.data.access_token;\n            this._account = response.data;\n            this.emit(\"authenticated\", response.data);\n            return true;\n        }\n        this._account = undefined;\n        return false;\n    }\n\n    /**\n     * The httpErrorHandler function is a helper function that handles errors from the http request.\n     *\n     * @param error: any Pass in the error object that is returned by axios\n     */\n    private httpErrorHandler(error: Error): void {\n        let errorString: string | undefined = undefined;\n        if (!error) {\n            errorString = \"Unknown Error\";\n        } else if (axios.isAxiosError(error)) {\n            if (error.response) {\n                // The request was made and the server responded with a status code that falls out of the range of 2xx the http status code mentioned above\n                errorString = `HTTP error ${error.response.status} ${error.response.statusText}}`\n            } else if (error.code) {\n                errorString = error.code;\n            } else if (error.request) {\n                // The request was made but no response was received\n                errorString = \"No response received\"\n            }\n        } else {\n            errorString = error.message;\n        }\n\n        if (errorString) {\n            this.emit(\"error\", new Error(errorString));\n        }\n    }\n\n    private onConnected(): void {\n        this.emit(\"connected\");\n\n        // Cancel any pending reconnect attempts\n        this.unscheduleReconnect();\n\n        // Schedule pings to keep the connection alive\n        this.pingTimer = setInterval(() => this.webSocket?.ping(), PING_INTERVAL);\n    }\n\n    /**\n     * The onDisconnected function is called when the client disconnects from the server.\n     * It emits a \"disconnected\" event with a reason string, and if autoReconnect is enabled,\n     * it will schedule a reconnection attempt.\n     *\n     * @param reason: string Pass the reason for disconnection\n     *\n     * @emits disconnected\n     */\n    private async onDisconnected(reason: string): Promise<void> {\n        this.emit(\"disconnected\", reason);\n        if (this.pingTimer) {\n            clearInterval(this.pingTimer);\n            this.pingTimer = undefined;\n        }\n        if (this.autoReconnect) {\n            this.scheduleReconnect();\n        }\n    }\n\n    /**\n     * The onMessage function is called when the WebSocket receives a message.\n     * It parses the JSON data and emits an event based on its type.\n     * If it's an error, it emits an \"error\" event with the payload as its argument.\n     * Otherwise, it emits a type-based event with the payload as its argument.\n     *\n     */\n    private onMessage(data: WebSocket.RawData): void {\n        try {\n            const json: SenseWebSocketMessage = JSON.parse(data.toString());\n            if (json.type == \"error\") {\n                this.emit(\"error\", new Error(\"sense error: \" + json.payload.error_reason));\n            } else {\n                /*\n                 * Message types:\n                 *      \"hello\": Initial message sent by the server\n                 *      \"monitor_info\": Monitor info update\n                 *      \"data_change\": Data change event\n                 *      \"device_states\": Device states\n                 *      \"realtime_update\": Realtime data update\n                 */\n                this.emit(json.type, json.payload);\n            }\n        } catch (error) {\n            this.emit(\"error\", error);\n        }\n    }\n\n    /**\n     * The renewToken function is used to renew the access token for a Sense account.\n     * This function should be called when the access token expires, which happens after 1 hour of inactivity.\n     * The function will automatically update the authorization header with the new access token and emit an event\n     * that can be listened to by other modules.\n     *\n     * @returns true if the token was renewed successfully, false otherwise\n     */\n    private async renewToken(): Promise<boolean> {\n        const response = await this.httpsClient.post<SenseAuthResponse>(\"renew\", stringify({\n            \"user_id\": this._account?.user_id,\n            \"refresh_token\": this._account?.refresh_token\n        }), {\n            headers: {\n                \"Content-Type\": \"application/x-www-form-urlencoded\"\n            }\n        }).catch((error) => this.httpErrorHandler(error));\n        if (response?.data?.authorized) {\n            this.httpsClient.defaults.headers.common[\"Authorization\"] = \"bearer \" + response.data.access_token;\n            this._account = { ...this._account, ...response.data };\n            this.emit(\"token\", response.data);\n            return true;\n        }\n        this._account = undefined;\n        return false;\n    }\n\n    /**\n     * Schedules a reconnect attempt to the panel.\n     * If a reconnect attempt is not already in progress, a reconnect attempt will be scheduled after a delay.\n     * The delay period doubles with each subsequent attempt up to a maximum of 60 seconds.\n     */\n    private scheduleReconnect(): void {\n        // Clear the ping timer if it is set\n        if (this.pingTimer) {\n            clearInterval(this.pingTimer);\n            this.pingTimer = undefined;\n        }\n\n        // Don't schedule reconnect if autoReconnect is disabled\n        if (!this._autoReconnect) return;\n\n        // Don't schedule reconnect if we're already trying to reconnect\n        if (this.reconnectTimer) return;\n\n        // Schedule a reconnect attempt\n        this.reconnectTimer = setTimeout(async () => {\n            // Double the reconnect delay for the next attempt, up to a maximum\n            this.reconnectInterval = Math.min(this.reconnectInterval * 2, MAX_RECONNECT_INTERVAL);\n            this.reconnectTimer = undefined;\n            await this.start();\n        }, this.reconnectInterval);\n    }\n\n    /**\n     * The unscheduleReconnect function clears the reconnectTimer if it is set.\n     * It also sets the reconnectInterval to its default value of RECONNECT_INTERVAL.\n     */\n    private unscheduleReconnect(): void {\n        if (this.reconnectTimer) {\n            clearTimeout(this.reconnectTimer);\n            this.reconnectTimer = undefined;\n            this.reconnectInterval = RECONNECT_INTERVAL;\n        }\n    }\n}\n"],
  "mappings": "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",
  "names": ["axios", "memoize", "WebSocket"]
}
