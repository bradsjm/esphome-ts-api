{
  "version": 3,
  "sources": ["../../src/lib/sense-parser.ts"],
  "sourcesContent": ["import { SenseDevice, SenseUpdate } from \"../interfaces\";\nimport { EventEmitter } from \"events\";\nimport { getIcon } from \"./device-icons\";\n\ntype EventNames = \"gridVoltages\" | \"gridFrequency\" | \"gridWatts\" | \"device\";\n\nexport type SenseParserOptions = {\n    deviceUpdateSeconds: number;\n    generalUpdateSeconds: number;\n    deviceFilter: string[];\n}\n\nconst GENERIC_DEVICES = [ \"unknown\", \"always_on\", \"solar\" ]\n\n/**\n * SenseParser is used to parse real-time messages from Sense.\n * It emits the following events: 'gridVoltages', 'gridFrequency', 'gridWatts' and 'device'.\n */\nexport class SenseParser extends EventEmitter {\n    private readonly lastUpdateTime: Record<EventNames, Record<string, number>>;\n    private readonly options: SenseParserOptions;\n    private previousDeviceList: SenseDevice[] = [];\n\n    /**\n     * Creates a new SenseParser instance.\n     */\n    constructor(options: SenseParserOptions) {\n        super();\n        this.options = options;\n        // Initialize last update times for each type of event\n        this.lastUpdateTime = {\n            gridVoltages: {},\n            gridFrequency: {},\n            gridWatts: {},\n            device: {}\n        };\n    }\n\n    /**\n     * This function checks if a given MAC address is locally administered.\n     *\n     * @param macAddress: string The MAC address to be checked.\n     *\n     * @return A boolean indicating whether the MAC address is locally administered.\n     */\n    private static isLocallyAdministered(macAddress: string | undefined): boolean {\n        return typeof (macAddress) === \"string\" && [ \"2\", \"6\", \"A\", \"E\" ].includes(macAddress[1].toUpperCase());\n    }\n\n    /**\n     * The parse function is used to parse real-time messages from Sense.\n     *\n     * @param {SenseUpdate} update - The SenseUpdate object to parse.\n     */\n    public parse(update: SenseUpdate): void {\n        // Emit grid voltages, frequency, and watts if it has been more than a second\n        if (update.voltage != null) {\n            update.voltage = update.voltage.map((voltage) => Math.round(voltage));\n            this.emitIfDue(\"gridVoltages\", \"grid\", update.voltage, this.options.generalUpdateSeconds);\n        }\n\n        if (update.hz != null) {\n            update.hz = Math.round(update.hz);\n            this.emitIfDue(\"gridFrequency\", \"grid\", update.hz, this.options.generalUpdateSeconds);\n        }\n\n        if (update.channels != null) {\n            update.channels = update.channels.map((watts) => Math.round(watts));\n            this.emitIfDue(\"gridWatts\", \"grid\", update.channels, this.options.generalUpdateSeconds);\n        }\n\n        const filtered = update.devices.filter((device) =>\n            !this.options.deviceFilter.includes(device.name) &&\n            !this.options.deviceFilter.includes(device.id) &&\n            device.tags[\"DeviceListAllowed\"] === \"true\" &&\n            !SenseParser.isLocallyAdministered(String(device.tags[\"DUID\"]))\n        );\n\n        // Detect devices no longer active\n        this.handleMissingDevices(filtered);\n\n        // Parse active devices\n        this.parseActiveDevices(filtered);\n    }\n\n    /**\n     * Emit event if more than specified time has passed since the last update.\n     *\n     * @param {string} eventName - Name of the event to emit.\n     * @param {string} key - Key to check the last update time against.\n     * @param {any} data - Data to be sent with the event.\n     * @param {number} interval - Minimum time in milliseconds that must have elapsed since the last update.\n     */\n    private emitIfDue(eventName: EventNames, key: string, data: any, interval: number): void {\n        const currentTime = Date.now();\n        // If this key has not been used before or enough time has passed\n        if (!this.lastUpdateTime[eventName][key] || currentTime - this.lastUpdateTime[eventName][key] >= (interval * 1000)) {\n            this.emit(eventName, data);\n            this.lastUpdateTime[eventName][key] = interval ? currentTime : 0;\n        }\n    }\n\n    /**\n     * The handleMissingDevices function is used to find devices that are no longer present in the current deviceList list.\n     * It does this by comparing the previousDeviceList with the current deviceList list and emitting a 0 watt event for any\n     * devices that were previously present but are not in the new deviceList list. The function also updates\n     * previousDeviceList to be equal to whatever was passed into it as an argument (the new, updated deviceList list).\n     * This way, when handleMissingDevices is called again on a future iteration of getDataAndPublish(), it will have\n     * access to both lists of devices so that it can compare them.\n     *\n     * @param deviceList: {SenseDevice[]} the array of devices from the sense api\n     */\n    private handleMissingDevices(deviceList: SenseDevice[]): void {\n        // Find devices no longer present to emit a 0 watt event\n        this.previousDeviceList.forEach(lastDevice => {\n            if (!deviceList.some(device => device.id === lastDevice.id)) {\n                this.emitIfDue(\"device\", lastDevice.id, { ...lastDevice, w: 0 }, 0);\n            }\n        });\n\n        // Update the previousDeviceList\n        this.previousDeviceList = deviceList;\n    }\n\n    /**\n     * The parseActiveDevices function takes an array of devices and emits a device event for each one.\n     *\n     * @param devices: {SenseDevice[]} array of devices from the sense api\n     */\n    private parseActiveDevices(devices: SenseDevice[]): void {\n        // Emit device event for each device\n        devices.forEach((device) => {\n            // Round watt value to the nearest integer\n            device.w = Math.round(device.w);\n\n            // Set interval to the deviceUpdateSeconds if the device is not a generic device, otherwise use generalUpdateSeconds\n            const interval = GENERIC_DEVICES.includes(device.id) ? this.options.generalUpdateSeconds : this.options.deviceUpdateSeconds;\n\n            // Convert from icon name to icon SVG\n            device.icon = getIcon(device.icon)\n\n            // Emit device event if it has been more than the configured interval for this device id\n            this.emitIfDue(\"device\", device.id, device, interval);\n        });\n    }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AACA,oBAA6B;AAC7B,0BAAwB;AAUxB,MAAM,kBAAkB,CAAE,WAAW,aAAa,OAAQ;AAMnD,MAAM,oBAAoB,2BAAa;AAAA,EAQ1C,YAAY,SAA6B;AACrC,UAAM;AANV,SAAQ,qBAAoC,CAAC;AAOzC,SAAK,UAAU;AAEf,SAAK,iBAAiB;AAAA,MAClB,cAAc,CAAC;AAAA,MACf,eAAe,CAAC;AAAA,MAChB,WAAW,CAAC;AAAA,MACZ,QAAQ,CAAC;AAAA,IACb;AAAA,EACJ;AAAA,EASA,OAAe,sBAAsB,YAAyC;AAC1E,WAAO,OAAQ,eAAgB,YAAY,CAAE,KAAK,KAAK,KAAK,GAAI,EAAE,SAAS,WAAW,GAAG,YAAY,CAAC;AAAA,EAC1G;AAAA,EAOO,MAAM,QAA2B;AAEpC,QAAI,OAAO,WAAW,MAAM;AACxB,aAAO,UAAU,OAAO,QAAQ,IAAI,CAAC,YAAY,KAAK,MAAM,OAAO,CAAC;AACpE,WAAK,UAAU,gBAAgB,QAAQ,OAAO,SAAS,KAAK,QAAQ,oBAAoB;AAAA,IAC5F;AAEA,QAAI,OAAO,MAAM,MAAM;AACnB,aAAO,KAAK,KAAK,MAAM,OAAO,EAAE;AAChC,WAAK,UAAU,iBAAiB,QAAQ,OAAO,IAAI,KAAK,QAAQ,oBAAoB;AAAA,IACxF;AAEA,QAAI,OAAO,YAAY,MAAM;AACzB,aAAO,WAAW,OAAO,SAAS,IAAI,CAAC,UAAU,KAAK,MAAM,KAAK,CAAC;AAClE,WAAK,UAAU,aAAa,QAAQ,OAAO,UAAU,KAAK,QAAQ,oBAAoB;AAAA,IAC1F;AAEA,UAAM,WAAW,OAAO,QAAQ;AAAA,MAAO,CAAC,WACpC,CAAC,KAAK,QAAQ,aAAa,SAAS,OAAO,IAAI,KAC/C,CAAC,KAAK,QAAQ,aAAa,SAAS,OAAO,EAAE,KAC7C,OAAO,KAAK,yBAAyB,UACrC,CAAC,YAAY,sBAAsB,OAAO,OAAO,KAAK,OAAO,CAAC;AAAA,IAClE;AAGA,SAAK,qBAAqB,QAAQ;AAGlC,SAAK,mBAAmB,QAAQ;AAAA,EACpC;AAAA,EAUQ,UAAU,WAAuB,KAAa,MAAW,UAAwB;AACrF,UAAM,cAAc,KAAK,IAAI;AAE7B,QAAI,CAAC,KAAK,eAAe,WAAW,QAAQ,cAAc,KAAK,eAAe,WAAW,QAAS,WAAW,KAAO;AAChH,WAAK,KAAK,WAAW,IAAI;AACzB,WAAK,eAAe,WAAW,OAAO,WAAW,cAAc;AAAA,IACnE;AAAA,EACJ;AAAA,EAYQ,qBAAqB,YAAiC;AAE1D,SAAK,mBAAmB,QAAQ,gBAAc;AAC1C,UAAI,CAAC,WAAW,KAAK,YAAU,OAAO,OAAO,WAAW,EAAE,GAAG;AACzD,aAAK,UAAU,UAAU,WAAW,IAAI,EAAE,GAAG,YAAY,GAAG,EAAE,GAAG,CAAC;AAAA,MACtE;AAAA,IACJ,CAAC;AAGD,SAAK,qBAAqB;AAAA,EAC9B;AAAA,EAOQ,mBAAmB,SAA8B;AAErD,YAAQ,QAAQ,CAAC,WAAW;AAExB,aAAO,IAAI,KAAK,MAAM,OAAO,CAAC;AAG9B,YAAM,WAAW,gBAAgB,SAAS,OAAO,EAAE,IAAI,KAAK,QAAQ,uBAAuB,KAAK,QAAQ;AAGxG,aAAO,WAAO,6BAAQ,OAAO,IAAI;AAGjC,WAAK,UAAU,UAAU,OAAO,IAAI,QAAQ,QAAQ;AAAA,IACxD,CAAC;AAAA,EACL;AACJ;",
  "names": []
}
