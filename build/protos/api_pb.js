"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SensorStateResponse = exports.ListEntitiesSensorResponse = exports.LightCommandRequest = exports.LightStateResponse = exports.ListEntitiesLightResponse = exports.FanCommandRequest = exports.FanStateResponse = exports.ListEntitiesFanResponse = exports.CoverCommandRequest = exports.CoverStateResponse = exports.ListEntitiesCoverResponse = exports.BinarySensorStateResponse = exports.ListEntitiesBinarySensorResponse = exports.SubscribeStatesRequest = exports.ListEntitiesDoneResponse = exports.ListEntitiesRequest = exports.DeviceInfoResponse = exports.DeviceInfoRequest = exports.PingResponse = exports.PingRequest = exports.DisconnectResponse = exports.DisconnectRequest = exports.ConnectResponse = exports.ConnectRequest = exports.HelloResponse = exports.HelloRequest = exports.AlarmControlPanelStateCommand = exports.AlarmControlPanelState = exports.VoiceAssistantEvent = exports.BluetoothDeviceRequestType = exports.MediaPlayerCommand = exports.MediaPlayerState = exports.LockCommand = exports.LockState = exports.NumberMode = exports.ClimatePreset = exports.ClimateAction = exports.ClimateSwingMode = exports.ClimateFanMode = exports.ClimateMode = exports.ServiceArgType = exports.LogLevel = exports.SensorLastResetType = exports.SensorStateClass = exports.FanDirection = exports.FanSpeed = exports.LegacyCoverCommand = exports.CoverOperation = exports.LegacyCoverState = exports.EntityCategory = void 0;
exports.BluetoothGATTGetServicesRequest = exports.BluetoothDeviceConnectionResponse = exports.BluetoothDeviceRequest = exports.BluetoothLERawAdvertisementsResponse = exports.BluetoothLERawAdvertisement = exports.BluetoothLEAdvertisementResponse = exports.BluetoothServiceData = exports.SubscribeBluetoothLEAdvertisementsRequest = exports.MediaPlayerCommandRequest = exports.MediaPlayerStateResponse = exports.ListEntitiesMediaPlayerResponse = exports.ButtonCommandRequest = exports.ListEntitiesButtonResponse = exports.LockCommandRequest = exports.LockStateResponse = exports.ListEntitiesLockResponse = exports.SirenCommandRequest = exports.SirenStateResponse = exports.ListEntitiesSirenResponse = exports.SelectCommandRequest = exports.SelectStateResponse = exports.ListEntitiesSelectResponse = exports.NumberCommandRequest = exports.NumberStateResponse = exports.ListEntitiesNumberResponse = exports.ClimateCommandRequest = exports.ClimateStateResponse = exports.ListEntitiesClimateResponse = exports.CameraImageRequest = exports.CameraImageResponse = exports.ListEntitiesCameraResponse = exports.ExecuteServiceRequest = exports.ExecuteServiceArgument = exports.ListEntitiesServicesResponse = exports.ListEntitiesServicesArgument = exports.GetTimeResponse = exports.GetTimeRequest = exports.HomeAssistantStateResponse = exports.SubscribeHomeAssistantStateResponse = exports.SubscribeHomeAssistantStatesRequest = exports.HomeassistantServiceResponse = exports.HomeassistantServiceMap = exports.SubscribeHomeassistantServicesRequest = exports.SubscribeLogsResponse = exports.SubscribeLogsRequest = exports.TextSensorStateResponse = exports.ListEntitiesTextSensorResponse = exports.SwitchCommandRequest = exports.SwitchStateResponse = exports.ListEntitiesSwitchResponse = void 0;
exports.APIConnection = exports.AlarmControlPanelCommandRequest = exports.AlarmControlPanelStateResponse = exports.ListEntitiesAlarmControlPanelResponse = exports.VoiceAssistantEventResponse = exports.VoiceAssistantEventData = exports.VoiceAssistantResponse = exports.VoiceAssistantRequest = exports.SubscribeVoiceAssistantRequest = exports.BluetoothDeviceClearCacheResponse = exports.UnsubscribeBluetoothLEAdvertisementsRequest = exports.BluetoothDeviceUnpairingResponse = exports.BluetoothDevicePairingResponse = exports.BluetoothGATTNotifyResponse = exports.BluetoothGATTWriteResponse = exports.BluetoothGATTErrorResponse = exports.BluetoothConnectionsFreeResponse = exports.SubscribeBluetoothConnectionsFreeRequest = exports.BluetoothGATTNotifyDataResponse = exports.BluetoothGATTNotifyRequest = exports.BluetoothGATTWriteDescriptorRequest = exports.BluetoothGATTReadDescriptorRequest = exports.BluetoothGATTWriteRequest = exports.BluetoothGATTReadResponse = exports.BluetoothGATTReadRequest = exports.BluetoothGATTGetServicesDoneResponse = exports.BluetoothGATTGetServicesResponse = exports.BluetoothGATTService = exports.BluetoothGATTCharacteristic = exports.BluetoothGATTDescriptor = void 0;
/* eslint-disable */
// @generated by protobuf-ts 2.9.0 with parameter eslint_disable,add_pb_suffix,output_legacy_commonjs
// @generated from protobuf file "api.proto" (syntax proto3)
// tslint:disable
const api_options_pb_1 = require("./api_options_pb");
const runtime_rpc_1 = require("@protobuf-ts/runtime-rpc");
const runtime_1 = require("@protobuf-ts/runtime");
const runtime_2 = require("@protobuf-ts/runtime");
const runtime_3 = require("@protobuf-ts/runtime");
const runtime_4 = require("@protobuf-ts/runtime");
const runtime_5 = require("@protobuf-ts/runtime");
// ==================== COMMON =====================
/**
 * @generated from protobuf enum EntityCategory
 */
var EntityCategory;
(function (EntityCategory) {
    /**
     * @generated from protobuf enum value: ENTITY_CATEGORY_NONE = 0;
     */
    EntityCategory[EntityCategory["NONE"] = 0] = "NONE";
    /**
     * @generated from protobuf enum value: ENTITY_CATEGORY_CONFIG = 1;
     */
    EntityCategory[EntityCategory["CONFIG"] = 1] = "CONFIG";
    /**
     * @generated from protobuf enum value: ENTITY_CATEGORY_DIAGNOSTIC = 2;
     */
    EntityCategory[EntityCategory["DIAGNOSTIC"] = 2] = "DIAGNOSTIC";
})(EntityCategory = exports.EntityCategory || (exports.EntityCategory = {}));
/**
 * @generated from protobuf enum LegacyCoverState
 */
var LegacyCoverState;
(function (LegacyCoverState) {
    /**
     * @generated from protobuf enum value: LEGACY_COVER_STATE_OPEN = 0;
     */
    LegacyCoverState[LegacyCoverState["OPEN"] = 0] = "OPEN";
    /**
     * @generated from protobuf enum value: LEGACY_COVER_STATE_CLOSED = 1;
     */
    LegacyCoverState[LegacyCoverState["CLOSED"] = 1] = "CLOSED";
})(LegacyCoverState = exports.LegacyCoverState || (exports.LegacyCoverState = {}));
/**
 * @generated from protobuf enum CoverOperation
 */
var CoverOperation;
(function (CoverOperation) {
    /**
     * @generated from protobuf enum value: COVER_OPERATION_IDLE = 0;
     */
    CoverOperation[CoverOperation["IDLE"] = 0] = "IDLE";
    /**
     * @generated from protobuf enum value: COVER_OPERATION_IS_OPENING = 1;
     */
    CoverOperation[CoverOperation["IS_OPENING"] = 1] = "IS_OPENING";
    /**
     * @generated from protobuf enum value: COVER_OPERATION_IS_CLOSING = 2;
     */
    CoverOperation[CoverOperation["IS_CLOSING"] = 2] = "IS_CLOSING";
})(CoverOperation = exports.CoverOperation || (exports.CoverOperation = {}));
/**
 * @generated from protobuf enum LegacyCoverCommand
 */
var LegacyCoverCommand;
(function (LegacyCoverCommand) {
    /**
     * @generated from protobuf enum value: LEGACY_COVER_COMMAND_OPEN = 0;
     */
    LegacyCoverCommand[LegacyCoverCommand["OPEN"] = 0] = "OPEN";
    /**
     * @generated from protobuf enum value: LEGACY_COVER_COMMAND_CLOSE = 1;
     */
    LegacyCoverCommand[LegacyCoverCommand["CLOSE"] = 1] = "CLOSE";
    /**
     * @generated from protobuf enum value: LEGACY_COVER_COMMAND_STOP = 2;
     */
    LegacyCoverCommand[LegacyCoverCommand["STOP"] = 2] = "STOP";
})(LegacyCoverCommand = exports.LegacyCoverCommand || (exports.LegacyCoverCommand = {}));
/**
 * @generated from protobuf enum FanSpeed
 */
var FanSpeed;
(function (FanSpeed) {
    /**
     * @generated from protobuf enum value: FAN_SPEED_LOW = 0;
     */
    FanSpeed[FanSpeed["LOW"] = 0] = "LOW";
    /**
     * @generated from protobuf enum value: FAN_SPEED_MEDIUM = 1;
     */
    FanSpeed[FanSpeed["MEDIUM"] = 1] = "MEDIUM";
    /**
     * @generated from protobuf enum value: FAN_SPEED_HIGH = 2;
     */
    FanSpeed[FanSpeed["HIGH"] = 2] = "HIGH";
})(FanSpeed = exports.FanSpeed || (exports.FanSpeed = {}));
/**
 * @generated from protobuf enum FanDirection
 */
var FanDirection;
(function (FanDirection) {
    /**
     * @generated from protobuf enum value: FAN_DIRECTION_FORWARD = 0;
     */
    FanDirection[FanDirection["FORWARD"] = 0] = "FORWARD";
    /**
     * @generated from protobuf enum value: FAN_DIRECTION_REVERSE = 1;
     */
    FanDirection[FanDirection["REVERSE"] = 1] = "REVERSE";
})(FanDirection = exports.FanDirection || (exports.FanDirection = {}));
/**
 * ==================== SENSOR ====================
 *
 * @generated from protobuf enum SensorStateClass
 */
var SensorStateClass;
(function (SensorStateClass) {
    /**
     * @generated from protobuf enum value: STATE_CLASS_NONE = 0;
     */
    SensorStateClass[SensorStateClass["STATE_CLASS_NONE"] = 0] = "STATE_CLASS_NONE";
    /**
     * @generated from protobuf enum value: STATE_CLASS_MEASUREMENT = 1;
     */
    SensorStateClass[SensorStateClass["STATE_CLASS_MEASUREMENT"] = 1] = "STATE_CLASS_MEASUREMENT";
    /**
     * @generated from protobuf enum value: STATE_CLASS_TOTAL_INCREASING = 2;
     */
    SensorStateClass[SensorStateClass["STATE_CLASS_TOTAL_INCREASING"] = 2] = "STATE_CLASS_TOTAL_INCREASING";
    /**
     * @generated from protobuf enum value: STATE_CLASS_TOTAL = 3;
     */
    SensorStateClass[SensorStateClass["STATE_CLASS_TOTAL"] = 3] = "STATE_CLASS_TOTAL";
})(SensorStateClass = exports.SensorStateClass || (exports.SensorStateClass = {}));
/**
 * @generated from protobuf enum SensorLastResetType
 */
var SensorLastResetType;
(function (SensorLastResetType) {
    /**
     * @generated from protobuf enum value: LAST_RESET_NONE = 0;
     */
    SensorLastResetType[SensorLastResetType["LAST_RESET_NONE"] = 0] = "LAST_RESET_NONE";
    /**
     * @generated from protobuf enum value: LAST_RESET_NEVER = 1;
     */
    SensorLastResetType[SensorLastResetType["LAST_RESET_NEVER"] = 1] = "LAST_RESET_NEVER";
    /**
     * @generated from protobuf enum value: LAST_RESET_AUTO = 2;
     */
    SensorLastResetType[SensorLastResetType["LAST_RESET_AUTO"] = 2] = "LAST_RESET_AUTO";
})(SensorLastResetType = exports.SensorLastResetType || (exports.SensorLastResetType = {}));
/**
 * ==================== SUBSCRIBE LOGS ====================
 *
 * @generated from protobuf enum LogLevel
 */
var LogLevel;
(function (LogLevel) {
    /**
     * @generated from protobuf enum value: LOG_LEVEL_NONE = 0;
     */
    LogLevel[LogLevel["NONE"] = 0] = "NONE";
    /**
     * @generated from protobuf enum value: LOG_LEVEL_ERROR = 1;
     */
    LogLevel[LogLevel["ERROR"] = 1] = "ERROR";
    /**
     * @generated from protobuf enum value: LOG_LEVEL_WARN = 2;
     */
    LogLevel[LogLevel["WARN"] = 2] = "WARN";
    /**
     * @generated from protobuf enum value: LOG_LEVEL_INFO = 3;
     */
    LogLevel[LogLevel["INFO"] = 3] = "INFO";
    /**
     * @generated from protobuf enum value: LOG_LEVEL_CONFIG = 4;
     */
    LogLevel[LogLevel["CONFIG"] = 4] = "CONFIG";
    /**
     * @generated from protobuf enum value: LOG_LEVEL_DEBUG = 5;
     */
    LogLevel[LogLevel["DEBUG"] = 5] = "DEBUG";
    /**
     * @generated from protobuf enum value: LOG_LEVEL_VERBOSE = 6;
     */
    LogLevel[LogLevel["VERBOSE"] = 6] = "VERBOSE";
    /**
     * @generated from protobuf enum value: LOG_LEVEL_VERY_VERBOSE = 7;
     */
    LogLevel[LogLevel["VERY_VERBOSE"] = 7] = "VERY_VERBOSE";
})(LogLevel = exports.LogLevel || (exports.LogLevel = {}));
/**
 * ==================== USER-DEFINES SERVICES ====================
 *
 * @generated from protobuf enum ServiceArgType
 */
var ServiceArgType;
(function (ServiceArgType) {
    /**
     * @generated from protobuf enum value: SERVICE_ARG_TYPE_BOOL = 0;
     */
    ServiceArgType[ServiceArgType["BOOL"] = 0] = "BOOL";
    /**
     * @generated from protobuf enum value: SERVICE_ARG_TYPE_INT = 1;
     */
    ServiceArgType[ServiceArgType["INT"] = 1] = "INT";
    /**
     * @generated from protobuf enum value: SERVICE_ARG_TYPE_FLOAT = 2;
     */
    ServiceArgType[ServiceArgType["FLOAT"] = 2] = "FLOAT";
    /**
     * @generated from protobuf enum value: SERVICE_ARG_TYPE_STRING = 3;
     */
    ServiceArgType[ServiceArgType["STRING"] = 3] = "STRING";
    /**
     * @generated from protobuf enum value: SERVICE_ARG_TYPE_BOOL_ARRAY = 4;
     */
    ServiceArgType[ServiceArgType["BOOL_ARRAY"] = 4] = "BOOL_ARRAY";
    /**
     * @generated from protobuf enum value: SERVICE_ARG_TYPE_INT_ARRAY = 5;
     */
    ServiceArgType[ServiceArgType["INT_ARRAY"] = 5] = "INT_ARRAY";
    /**
     * @generated from protobuf enum value: SERVICE_ARG_TYPE_FLOAT_ARRAY = 6;
     */
    ServiceArgType[ServiceArgType["FLOAT_ARRAY"] = 6] = "FLOAT_ARRAY";
    /**
     * @generated from protobuf enum value: SERVICE_ARG_TYPE_STRING_ARRAY = 7;
     */
    ServiceArgType[ServiceArgType["STRING_ARRAY"] = 7] = "STRING_ARRAY";
})(ServiceArgType = exports.ServiceArgType || (exports.ServiceArgType = {}));
/**
 * ==================== CLIMATE ====================
 *
 * @generated from protobuf enum ClimateMode
 */
var ClimateMode;
(function (ClimateMode) {
    /**
     * @generated from protobuf enum value: CLIMATE_MODE_OFF = 0;
     */
    ClimateMode[ClimateMode["OFF"] = 0] = "OFF";
    /**
     * @generated from protobuf enum value: CLIMATE_MODE_HEAT_COOL = 1;
     */
    ClimateMode[ClimateMode["HEAT_COOL"] = 1] = "HEAT_COOL";
    /**
     * @generated from protobuf enum value: CLIMATE_MODE_COOL = 2;
     */
    ClimateMode[ClimateMode["COOL"] = 2] = "COOL";
    /**
     * @generated from protobuf enum value: CLIMATE_MODE_HEAT = 3;
     */
    ClimateMode[ClimateMode["HEAT"] = 3] = "HEAT";
    /**
     * @generated from protobuf enum value: CLIMATE_MODE_FAN_ONLY = 4;
     */
    ClimateMode[ClimateMode["FAN_ONLY"] = 4] = "FAN_ONLY";
    /**
     * @generated from protobuf enum value: CLIMATE_MODE_DRY = 5;
     */
    ClimateMode[ClimateMode["DRY"] = 5] = "DRY";
    /**
     * @generated from protobuf enum value: CLIMATE_MODE_AUTO = 6;
     */
    ClimateMode[ClimateMode["AUTO"] = 6] = "AUTO";
})(ClimateMode = exports.ClimateMode || (exports.ClimateMode = {}));
/**
 * @generated from protobuf enum ClimateFanMode
 */
var ClimateFanMode;
(function (ClimateFanMode) {
    /**
     * @generated from protobuf enum value: CLIMATE_FAN_ON = 0;
     */
    ClimateFanMode[ClimateFanMode["CLIMATE_FAN_ON"] = 0] = "CLIMATE_FAN_ON";
    /**
     * @generated from protobuf enum value: CLIMATE_FAN_OFF = 1;
     */
    ClimateFanMode[ClimateFanMode["CLIMATE_FAN_OFF"] = 1] = "CLIMATE_FAN_OFF";
    /**
     * @generated from protobuf enum value: CLIMATE_FAN_AUTO = 2;
     */
    ClimateFanMode[ClimateFanMode["CLIMATE_FAN_AUTO"] = 2] = "CLIMATE_FAN_AUTO";
    /**
     * @generated from protobuf enum value: CLIMATE_FAN_LOW = 3;
     */
    ClimateFanMode[ClimateFanMode["CLIMATE_FAN_LOW"] = 3] = "CLIMATE_FAN_LOW";
    /**
     * @generated from protobuf enum value: CLIMATE_FAN_MEDIUM = 4;
     */
    ClimateFanMode[ClimateFanMode["CLIMATE_FAN_MEDIUM"] = 4] = "CLIMATE_FAN_MEDIUM";
    /**
     * @generated from protobuf enum value: CLIMATE_FAN_HIGH = 5;
     */
    ClimateFanMode[ClimateFanMode["CLIMATE_FAN_HIGH"] = 5] = "CLIMATE_FAN_HIGH";
    /**
     * @generated from protobuf enum value: CLIMATE_FAN_MIDDLE = 6;
     */
    ClimateFanMode[ClimateFanMode["CLIMATE_FAN_MIDDLE"] = 6] = "CLIMATE_FAN_MIDDLE";
    /**
     * @generated from protobuf enum value: CLIMATE_FAN_FOCUS = 7;
     */
    ClimateFanMode[ClimateFanMode["CLIMATE_FAN_FOCUS"] = 7] = "CLIMATE_FAN_FOCUS";
    /**
     * @generated from protobuf enum value: CLIMATE_FAN_DIFFUSE = 8;
     */
    ClimateFanMode[ClimateFanMode["CLIMATE_FAN_DIFFUSE"] = 8] = "CLIMATE_FAN_DIFFUSE";
    /**
     * @generated from protobuf enum value: CLIMATE_FAN_QUIET = 9;
     */
    ClimateFanMode[ClimateFanMode["CLIMATE_FAN_QUIET"] = 9] = "CLIMATE_FAN_QUIET";
})(ClimateFanMode = exports.ClimateFanMode || (exports.ClimateFanMode = {}));
/**
 * @generated from protobuf enum ClimateSwingMode
 */
var ClimateSwingMode;
(function (ClimateSwingMode) {
    /**
     * @generated from protobuf enum value: CLIMATE_SWING_OFF = 0;
     */
    ClimateSwingMode[ClimateSwingMode["CLIMATE_SWING_OFF"] = 0] = "CLIMATE_SWING_OFF";
    /**
     * @generated from protobuf enum value: CLIMATE_SWING_BOTH = 1;
     */
    ClimateSwingMode[ClimateSwingMode["CLIMATE_SWING_BOTH"] = 1] = "CLIMATE_SWING_BOTH";
    /**
     * @generated from protobuf enum value: CLIMATE_SWING_VERTICAL = 2;
     */
    ClimateSwingMode[ClimateSwingMode["CLIMATE_SWING_VERTICAL"] = 2] = "CLIMATE_SWING_VERTICAL";
    /**
     * @generated from protobuf enum value: CLIMATE_SWING_HORIZONTAL = 3;
     */
    ClimateSwingMode[ClimateSwingMode["CLIMATE_SWING_HORIZONTAL"] = 3] = "CLIMATE_SWING_HORIZONTAL";
})(ClimateSwingMode = exports.ClimateSwingMode || (exports.ClimateSwingMode = {}));
/**
 * @generated from protobuf enum ClimateAction
 */
var ClimateAction;
(function (ClimateAction) {
    /**
     * @generated from protobuf enum value: CLIMATE_ACTION_OFF = 0;
     */
    ClimateAction[ClimateAction["OFF"] = 0] = "OFF";
    /**
     * values same as mode for readability
     *
     * @generated from protobuf enum value: CLIMATE_ACTION_COOLING = 2;
     */
    ClimateAction[ClimateAction["COOLING"] = 2] = "COOLING";
    /**
     * @generated from protobuf enum value: CLIMATE_ACTION_HEATING = 3;
     */
    ClimateAction[ClimateAction["HEATING"] = 3] = "HEATING";
    /**
     * @generated from protobuf enum value: CLIMATE_ACTION_IDLE = 4;
     */
    ClimateAction[ClimateAction["IDLE"] = 4] = "IDLE";
    /**
     * @generated from protobuf enum value: CLIMATE_ACTION_DRYING = 5;
     */
    ClimateAction[ClimateAction["DRYING"] = 5] = "DRYING";
    /**
     * @generated from protobuf enum value: CLIMATE_ACTION_FAN = 6;
     */
    ClimateAction[ClimateAction["FAN"] = 6] = "FAN";
})(ClimateAction = exports.ClimateAction || (exports.ClimateAction = {}));
/**
 * @generated from protobuf enum ClimatePreset
 */
var ClimatePreset;
(function (ClimatePreset) {
    /**
     * @generated from protobuf enum value: CLIMATE_PRESET_NONE = 0;
     */
    ClimatePreset[ClimatePreset["NONE"] = 0] = "NONE";
    /**
     * @generated from protobuf enum value: CLIMATE_PRESET_HOME = 1;
     */
    ClimatePreset[ClimatePreset["HOME"] = 1] = "HOME";
    /**
     * @generated from protobuf enum value: CLIMATE_PRESET_AWAY = 2;
     */
    ClimatePreset[ClimatePreset["AWAY"] = 2] = "AWAY";
    /**
     * @generated from protobuf enum value: CLIMATE_PRESET_BOOST = 3;
     */
    ClimatePreset[ClimatePreset["BOOST"] = 3] = "BOOST";
    /**
     * @generated from protobuf enum value: CLIMATE_PRESET_COMFORT = 4;
     */
    ClimatePreset[ClimatePreset["COMFORT"] = 4] = "COMFORT";
    /**
     * @generated from protobuf enum value: CLIMATE_PRESET_ECO = 5;
     */
    ClimatePreset[ClimatePreset["ECO"] = 5] = "ECO";
    /**
     * @generated from protobuf enum value: CLIMATE_PRESET_SLEEP = 6;
     */
    ClimatePreset[ClimatePreset["SLEEP"] = 6] = "SLEEP";
    /**
     * @generated from protobuf enum value: CLIMATE_PRESET_ACTIVITY = 7;
     */
    ClimatePreset[ClimatePreset["ACTIVITY"] = 7] = "ACTIVITY";
})(ClimatePreset = exports.ClimatePreset || (exports.ClimatePreset = {}));
/**
 * ==================== NUMBER ====================
 *
 * @generated from protobuf enum NumberMode
 */
var NumberMode;
(function (NumberMode) {
    /**
     * @generated from protobuf enum value: NUMBER_MODE_AUTO = 0;
     */
    NumberMode[NumberMode["AUTO"] = 0] = "AUTO";
    /**
     * @generated from protobuf enum value: NUMBER_MODE_BOX = 1;
     */
    NumberMode[NumberMode["BOX"] = 1] = "BOX";
    /**
     * @generated from protobuf enum value: NUMBER_MODE_SLIDER = 2;
     */
    NumberMode[NumberMode["SLIDER"] = 2] = "SLIDER";
})(NumberMode = exports.NumberMode || (exports.NumberMode = {}));
/**
 * ==================== LOCK ====================
 *
 * @generated from protobuf enum LockState
 */
var LockState;
(function (LockState) {
    /**
     * @generated from protobuf enum value: LOCK_STATE_NONE = 0;
     */
    LockState[LockState["NONE"] = 0] = "NONE";
    /**
     * @generated from protobuf enum value: LOCK_STATE_LOCKED = 1;
     */
    LockState[LockState["LOCKED"] = 1] = "LOCKED";
    /**
     * @generated from protobuf enum value: LOCK_STATE_UNLOCKED = 2;
     */
    LockState[LockState["UNLOCKED"] = 2] = "UNLOCKED";
    /**
     * @generated from protobuf enum value: LOCK_STATE_JAMMED = 3;
     */
    LockState[LockState["JAMMED"] = 3] = "JAMMED";
    /**
     * @generated from protobuf enum value: LOCK_STATE_LOCKING = 4;
     */
    LockState[LockState["LOCKING"] = 4] = "LOCKING";
    /**
     * @generated from protobuf enum value: LOCK_STATE_UNLOCKING = 5;
     */
    LockState[LockState["UNLOCKING"] = 5] = "UNLOCKING";
})(LockState = exports.LockState || (exports.LockState = {}));
/**
 * @generated from protobuf enum LockCommand
 */
var LockCommand;
(function (LockCommand) {
    /**
     * @generated from protobuf enum value: LOCK_UNLOCK = 0;
     */
    LockCommand[LockCommand["LOCK_UNLOCK"] = 0] = "LOCK_UNLOCK";
    /**
     * @generated from protobuf enum value: LOCK_LOCK = 1;
     */
    LockCommand[LockCommand["LOCK_LOCK"] = 1] = "LOCK_LOCK";
    /**
     * @generated from protobuf enum value: LOCK_OPEN = 2;
     */
    LockCommand[LockCommand["LOCK_OPEN"] = 2] = "LOCK_OPEN";
})(LockCommand = exports.LockCommand || (exports.LockCommand = {}));
/**
 * ==================== MEDIA PLAYER ====================
 *
 * @generated from protobuf enum MediaPlayerState
 */
var MediaPlayerState;
(function (MediaPlayerState) {
    /**
     * @generated from protobuf enum value: MEDIA_PLAYER_STATE_NONE = 0;
     */
    MediaPlayerState[MediaPlayerState["NONE"] = 0] = "NONE";
    /**
     * @generated from protobuf enum value: MEDIA_PLAYER_STATE_IDLE = 1;
     */
    MediaPlayerState[MediaPlayerState["IDLE"] = 1] = "IDLE";
    /**
     * @generated from protobuf enum value: MEDIA_PLAYER_STATE_PLAYING = 2;
     */
    MediaPlayerState[MediaPlayerState["PLAYING"] = 2] = "PLAYING";
    /**
     * @generated from protobuf enum value: MEDIA_PLAYER_STATE_PAUSED = 3;
     */
    MediaPlayerState[MediaPlayerState["PAUSED"] = 3] = "PAUSED";
})(MediaPlayerState = exports.MediaPlayerState || (exports.MediaPlayerState = {}));
/**
 * @generated from protobuf enum MediaPlayerCommand
 */
var MediaPlayerCommand;
(function (MediaPlayerCommand) {
    /**
     * @generated from protobuf enum value: MEDIA_PLAYER_COMMAND_PLAY = 0;
     */
    MediaPlayerCommand[MediaPlayerCommand["PLAY"] = 0] = "PLAY";
    /**
     * @generated from protobuf enum value: MEDIA_PLAYER_COMMAND_PAUSE = 1;
     */
    MediaPlayerCommand[MediaPlayerCommand["PAUSE"] = 1] = "PAUSE";
    /**
     * @generated from protobuf enum value: MEDIA_PLAYER_COMMAND_STOP = 2;
     */
    MediaPlayerCommand[MediaPlayerCommand["STOP"] = 2] = "STOP";
    /**
     * @generated from protobuf enum value: MEDIA_PLAYER_COMMAND_MUTE = 3;
     */
    MediaPlayerCommand[MediaPlayerCommand["MUTE"] = 3] = "MUTE";
    /**
     * @generated from protobuf enum value: MEDIA_PLAYER_COMMAND_UNMUTE = 4;
     */
    MediaPlayerCommand[MediaPlayerCommand["UNMUTE"] = 4] = "UNMUTE";
})(MediaPlayerCommand = exports.MediaPlayerCommand || (exports.MediaPlayerCommand = {}));
/**
 * @generated from protobuf enum BluetoothDeviceRequestType
 */
var BluetoothDeviceRequestType;
(function (BluetoothDeviceRequestType) {
    /**
     * @generated from protobuf enum value: BLUETOOTH_DEVICE_REQUEST_TYPE_CONNECT = 0;
     */
    BluetoothDeviceRequestType[BluetoothDeviceRequestType["CONNECT"] = 0] = "CONNECT";
    /**
     * @generated from protobuf enum value: BLUETOOTH_DEVICE_REQUEST_TYPE_DISCONNECT = 1;
     */
    BluetoothDeviceRequestType[BluetoothDeviceRequestType["DISCONNECT"] = 1] = "DISCONNECT";
    /**
     * @generated from protobuf enum value: BLUETOOTH_DEVICE_REQUEST_TYPE_PAIR = 2;
     */
    BluetoothDeviceRequestType[BluetoothDeviceRequestType["PAIR"] = 2] = "PAIR";
    /**
     * @generated from protobuf enum value: BLUETOOTH_DEVICE_REQUEST_TYPE_UNPAIR = 3;
     */
    BluetoothDeviceRequestType[BluetoothDeviceRequestType["UNPAIR"] = 3] = "UNPAIR";
    /**
     * @generated from protobuf enum value: BLUETOOTH_DEVICE_REQUEST_TYPE_CONNECT_V3_WITH_CACHE = 4;
     */
    BluetoothDeviceRequestType[BluetoothDeviceRequestType["CONNECT_V3_WITH_CACHE"] = 4] = "CONNECT_V3_WITH_CACHE";
    /**
     * @generated from protobuf enum value: BLUETOOTH_DEVICE_REQUEST_TYPE_CONNECT_V3_WITHOUT_CACHE = 5;
     */
    BluetoothDeviceRequestType[BluetoothDeviceRequestType["CONNECT_V3_WITHOUT_CACHE"] = 5] = "CONNECT_V3_WITHOUT_CACHE";
    /**
     * @generated from protobuf enum value: BLUETOOTH_DEVICE_REQUEST_TYPE_CLEAR_CACHE = 6;
     */
    BluetoothDeviceRequestType[BluetoothDeviceRequestType["CLEAR_CACHE"] = 6] = "CLEAR_CACHE";
})(BluetoothDeviceRequestType = exports.BluetoothDeviceRequestType || (exports.BluetoothDeviceRequestType = {}));
/**
 * @generated from protobuf enum VoiceAssistantEvent
 */
var VoiceAssistantEvent;
(function (VoiceAssistantEvent) {
    /**
     * @generated from protobuf enum value: VOICE_ASSISTANT_ERROR = 0;
     */
    VoiceAssistantEvent[VoiceAssistantEvent["VOICE_ASSISTANT_ERROR"] = 0] = "VOICE_ASSISTANT_ERROR";
    /**
     * @generated from protobuf enum value: VOICE_ASSISTANT_RUN_START = 1;
     */
    VoiceAssistantEvent[VoiceAssistantEvent["VOICE_ASSISTANT_RUN_START"] = 1] = "VOICE_ASSISTANT_RUN_START";
    /**
     * @generated from protobuf enum value: VOICE_ASSISTANT_RUN_END = 2;
     */
    VoiceAssistantEvent[VoiceAssistantEvent["VOICE_ASSISTANT_RUN_END"] = 2] = "VOICE_ASSISTANT_RUN_END";
    /**
     * @generated from protobuf enum value: VOICE_ASSISTANT_STT_START = 3;
     */
    VoiceAssistantEvent[VoiceAssistantEvent["VOICE_ASSISTANT_STT_START"] = 3] = "VOICE_ASSISTANT_STT_START";
    /**
     * @generated from protobuf enum value: VOICE_ASSISTANT_STT_END = 4;
     */
    VoiceAssistantEvent[VoiceAssistantEvent["VOICE_ASSISTANT_STT_END"] = 4] = "VOICE_ASSISTANT_STT_END";
    /**
     * @generated from protobuf enum value: VOICE_ASSISTANT_INTENT_START = 5;
     */
    VoiceAssistantEvent[VoiceAssistantEvent["VOICE_ASSISTANT_INTENT_START"] = 5] = "VOICE_ASSISTANT_INTENT_START";
    /**
     * @generated from protobuf enum value: VOICE_ASSISTANT_INTENT_END = 6;
     */
    VoiceAssistantEvent[VoiceAssistantEvent["VOICE_ASSISTANT_INTENT_END"] = 6] = "VOICE_ASSISTANT_INTENT_END";
    /**
     * @generated from protobuf enum value: VOICE_ASSISTANT_TTS_START = 7;
     */
    VoiceAssistantEvent[VoiceAssistantEvent["VOICE_ASSISTANT_TTS_START"] = 7] = "VOICE_ASSISTANT_TTS_START";
    /**
     * @generated from protobuf enum value: VOICE_ASSISTANT_TTS_END = 8;
     */
    VoiceAssistantEvent[VoiceAssistantEvent["VOICE_ASSISTANT_TTS_END"] = 8] = "VOICE_ASSISTANT_TTS_END";
})(VoiceAssistantEvent = exports.VoiceAssistantEvent || (exports.VoiceAssistantEvent = {}));
/**
 * ==================== ALARM CONTROL PANEL ====================
 *
 * @generated from protobuf enum AlarmControlPanelState
 */
var AlarmControlPanelState;
(function (AlarmControlPanelState) {
    /**
     * @generated from protobuf enum value: ALARM_STATE_DISARMED = 0;
     */
    AlarmControlPanelState[AlarmControlPanelState["ALARM_STATE_DISARMED"] = 0] = "ALARM_STATE_DISARMED";
    /**
     * @generated from protobuf enum value: ALARM_STATE_ARMED_HOME = 1;
     */
    AlarmControlPanelState[AlarmControlPanelState["ALARM_STATE_ARMED_HOME"] = 1] = "ALARM_STATE_ARMED_HOME";
    /**
     * @generated from protobuf enum value: ALARM_STATE_ARMED_AWAY = 2;
     */
    AlarmControlPanelState[AlarmControlPanelState["ALARM_STATE_ARMED_AWAY"] = 2] = "ALARM_STATE_ARMED_AWAY";
    /**
     * @generated from protobuf enum value: ALARM_STATE_ARMED_NIGHT = 3;
     */
    AlarmControlPanelState[AlarmControlPanelState["ALARM_STATE_ARMED_NIGHT"] = 3] = "ALARM_STATE_ARMED_NIGHT";
    /**
     * @generated from protobuf enum value: ALARM_STATE_ARMED_VACATION = 4;
     */
    AlarmControlPanelState[AlarmControlPanelState["ALARM_STATE_ARMED_VACATION"] = 4] = "ALARM_STATE_ARMED_VACATION";
    /**
     * @generated from protobuf enum value: ALARM_STATE_ARMED_CUSTOM_BYPASS = 5;
     */
    AlarmControlPanelState[AlarmControlPanelState["ALARM_STATE_ARMED_CUSTOM_BYPASS"] = 5] = "ALARM_STATE_ARMED_CUSTOM_BYPASS";
    /**
     * @generated from protobuf enum value: ALARM_STATE_PENDING = 6;
     */
    AlarmControlPanelState[AlarmControlPanelState["ALARM_STATE_PENDING"] = 6] = "ALARM_STATE_PENDING";
    /**
     * @generated from protobuf enum value: ALARM_STATE_ARMING = 7;
     */
    AlarmControlPanelState[AlarmControlPanelState["ALARM_STATE_ARMING"] = 7] = "ALARM_STATE_ARMING";
    /**
     * @generated from protobuf enum value: ALARM_STATE_DISARMING = 8;
     */
    AlarmControlPanelState[AlarmControlPanelState["ALARM_STATE_DISARMING"] = 8] = "ALARM_STATE_DISARMING";
    /**
     * @generated from protobuf enum value: ALARM_STATE_TRIGGERED = 9;
     */
    AlarmControlPanelState[AlarmControlPanelState["ALARM_STATE_TRIGGERED"] = 9] = "ALARM_STATE_TRIGGERED";
})(AlarmControlPanelState = exports.AlarmControlPanelState || (exports.AlarmControlPanelState = {}));
/**
 * @generated from protobuf enum AlarmControlPanelStateCommand
 */
var AlarmControlPanelStateCommand;
(function (AlarmControlPanelStateCommand) {
    /**
     * @generated from protobuf enum value: ALARM_CONTROL_PANEL_DISARM = 0;
     */
    AlarmControlPanelStateCommand[AlarmControlPanelStateCommand["ALARM_CONTROL_PANEL_DISARM"] = 0] = "ALARM_CONTROL_PANEL_DISARM";
    /**
     * @generated from protobuf enum value: ALARM_CONTROL_PANEL_ARM_AWAY = 1;
     */
    AlarmControlPanelStateCommand[AlarmControlPanelStateCommand["ALARM_CONTROL_PANEL_ARM_AWAY"] = 1] = "ALARM_CONTROL_PANEL_ARM_AWAY";
    /**
     * @generated from protobuf enum value: ALARM_CONTROL_PANEL_ARM_HOME = 2;
     */
    AlarmControlPanelStateCommand[AlarmControlPanelStateCommand["ALARM_CONTROL_PANEL_ARM_HOME"] = 2] = "ALARM_CONTROL_PANEL_ARM_HOME";
    /**
     * @generated from protobuf enum value: ALARM_CONTROL_PANEL_ARM_NIGHT = 3;
     */
    AlarmControlPanelStateCommand[AlarmControlPanelStateCommand["ALARM_CONTROL_PANEL_ARM_NIGHT"] = 3] = "ALARM_CONTROL_PANEL_ARM_NIGHT";
    /**
     * @generated from protobuf enum value: ALARM_CONTROL_PANEL_ARM_VACATION = 4;
     */
    AlarmControlPanelStateCommand[AlarmControlPanelStateCommand["ALARM_CONTROL_PANEL_ARM_VACATION"] = 4] = "ALARM_CONTROL_PANEL_ARM_VACATION";
    /**
     * @generated from protobuf enum value: ALARM_CONTROL_PANEL_ARM_CUSTOM_BYPASS = 5;
     */
    AlarmControlPanelStateCommand[AlarmControlPanelStateCommand["ALARM_CONTROL_PANEL_ARM_CUSTOM_BYPASS"] = 5] = "ALARM_CONTROL_PANEL_ARM_CUSTOM_BYPASS";
    /**
     * @generated from protobuf enum value: ALARM_CONTROL_PANEL_TRIGGER = 6;
     */
    AlarmControlPanelStateCommand[AlarmControlPanelStateCommand["ALARM_CONTROL_PANEL_TRIGGER"] = 6] = "ALARM_CONTROL_PANEL_TRIGGER";
})(AlarmControlPanelStateCommand = exports.AlarmControlPanelStateCommand || (exports.AlarmControlPanelStateCommand = {}));
// @generated message type with reflection information, may provide speed optimized methods
class HelloRequest$Type extends runtime_5.MessageType {
    constructor() {
        super("HelloRequest", [
            { no: 1, name: "client_info", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "api_version_major", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "api_version_minor", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ], { id: 1, source: "SOURCE_CLIENT", no_delay: true });
    }
    create(value) {
        const message = { clientInfo: "", apiVersionMajor: 0, apiVersionMinor: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string client_info */ 1:
                    message.clientInfo = reader.string();
                    break;
                case /* uint32 api_version_major */ 2:
                    message.apiVersionMajor = reader.uint32();
                    break;
                case /* uint32 api_version_minor */ 3:
                    message.apiVersionMinor = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string client_info = 1; */
        if (message.clientInfo !== "")
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.clientInfo);
        /* uint32 api_version_major = 2; */
        if (message.apiVersionMajor !== 0)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.apiVersionMajor);
        /* uint32 api_version_minor = 3; */
        if (message.apiVersionMinor !== 0)
            writer.tag(3, runtime_1.WireType.Varint).uint32(message.apiVersionMinor);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message HelloRequest
 */
exports.HelloRequest = new HelloRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HelloResponse$Type extends runtime_5.MessageType {
    constructor() {
        super("HelloResponse", [
            { no: 1, name: "api_version_major", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "api_version_minor", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "server_info", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { id: 2, source: "SOURCE_SERVER", no_delay: true });
    }
    create(value) {
        const message = { apiVersionMajor: 0, apiVersionMinor: 0, serverInfo: "", name: "" };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 api_version_major */ 1:
                    message.apiVersionMajor = reader.uint32();
                    break;
                case /* uint32 api_version_minor */ 2:
                    message.apiVersionMinor = reader.uint32();
                    break;
                case /* string server_info */ 3:
                    message.serverInfo = reader.string();
                    break;
                case /* string name */ 4:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint32 api_version_major = 1; */
        if (message.apiVersionMajor !== 0)
            writer.tag(1, runtime_1.WireType.Varint).uint32(message.apiVersionMajor);
        /* uint32 api_version_minor = 2; */
        if (message.apiVersionMinor !== 0)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.apiVersionMinor);
        /* string server_info = 3; */
        if (message.serverInfo !== "")
            writer.tag(3, runtime_1.WireType.LengthDelimited).string(message.serverInfo);
        /* string name = 4; */
        if (message.name !== "")
            writer.tag(4, runtime_1.WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message HelloResponse
 */
exports.HelloResponse = new HelloResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ConnectRequest$Type extends runtime_5.MessageType {
    constructor() {
        super("ConnectRequest", [
            { no: 1, name: "password", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { id: 3, source: "SOURCE_CLIENT", no_delay: true });
    }
    create(value) {
        const message = { password: "" };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string password */ 1:
                    message.password = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string password = 1; */
        if (message.password !== "")
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.password);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ConnectRequest
 */
exports.ConnectRequest = new ConnectRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ConnectResponse$Type extends runtime_5.MessageType {
    constructor() {
        super("ConnectResponse", [
            { no: 1, name: "invalid_password", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ], { id: 4, source: "SOURCE_SERVER", no_delay: true });
    }
    create(value) {
        const message = { invalidPassword: false };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool invalid_password */ 1:
                    message.invalidPassword = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* bool invalid_password = 1; */
        if (message.invalidPassword !== false)
            writer.tag(1, runtime_1.WireType.Varint).bool(message.invalidPassword);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ConnectResponse
 */
exports.ConnectResponse = new ConnectResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DisconnectRequest$Type extends runtime_5.MessageType {
    constructor() {
        super("DisconnectRequest", [], { id: 5, source: "SOURCE_BOTH", no_delay: true });
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        return target ?? this.create();
    }
    internalBinaryWrite(message, writer, options) {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DisconnectRequest
 */
exports.DisconnectRequest = new DisconnectRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DisconnectResponse$Type extends runtime_5.MessageType {
    constructor() {
        super("DisconnectResponse", [], { id: 6, source: "SOURCE_BOTH", no_delay: true });
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        return target ?? this.create();
    }
    internalBinaryWrite(message, writer, options) {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DisconnectResponse
 */
exports.DisconnectResponse = new DisconnectResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PingRequest$Type extends runtime_5.MessageType {
    constructor() {
        super("PingRequest", [], { id: 7, source: "SOURCE_BOTH" });
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        return target ?? this.create();
    }
    internalBinaryWrite(message, writer, options) {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message PingRequest
 */
exports.PingRequest = new PingRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PingResponse$Type extends runtime_5.MessageType {
    constructor() {
        super("PingResponse", [], { id: 8, source: "SOURCE_BOTH" });
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        return target ?? this.create();
    }
    internalBinaryWrite(message, writer, options) {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message PingResponse
 */
exports.PingResponse = new PingResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeviceInfoRequest$Type extends runtime_5.MessageType {
    constructor() {
        super("DeviceInfoRequest", [], { id: 9, source: "SOURCE_CLIENT" });
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        return target ?? this.create();
    }
    internalBinaryWrite(message, writer, options) {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DeviceInfoRequest
 */
exports.DeviceInfoRequest = new DeviceInfoRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeviceInfoResponse$Type extends runtime_5.MessageType {
    constructor() {
        super("DeviceInfoResponse", [
            { no: 1, name: "uses_password", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "mac_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "esphome_version", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "compilation_time", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "model", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "has_deep_sleep", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "project_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "project_version", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "webserver_port", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 11, name: "legacy_bluetooth_proxy_version", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 15, name: "bluetooth_proxy_feature_flags", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 12, name: "manufacturer", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 13, name: "friendly_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 14, name: "voice_assistant_version", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ], { id: 10, source: "SOURCE_SERVER" });
    }
    create(value) {
        const message = { usesPassword: false, name: "", macAddress: "", esphomeVersion: "", compilationTime: "", model: "", hasDeepSleep: false, projectName: "", projectVersion: "", webserverPort: 0, legacyBluetoothProxyVersion: 0, bluetoothProxyFeatureFlags: 0, manufacturer: "", friendlyName: "", voiceAssistantVersion: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool uses_password */ 1:
                    message.usesPassword = reader.bool();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* string mac_address */ 3:
                    message.macAddress = reader.string();
                    break;
                case /* string esphome_version */ 4:
                    message.esphomeVersion = reader.string();
                    break;
                case /* string compilation_time */ 5:
                    message.compilationTime = reader.string();
                    break;
                case /* string model */ 6:
                    message.model = reader.string();
                    break;
                case /* bool has_deep_sleep */ 7:
                    message.hasDeepSleep = reader.bool();
                    break;
                case /* string project_name */ 8:
                    message.projectName = reader.string();
                    break;
                case /* string project_version */ 9:
                    message.projectVersion = reader.string();
                    break;
                case /* uint32 webserver_port */ 10:
                    message.webserverPort = reader.uint32();
                    break;
                case /* uint32 legacy_bluetooth_proxy_version */ 11:
                    message.legacyBluetoothProxyVersion = reader.uint32();
                    break;
                case /* uint32 bluetooth_proxy_feature_flags */ 15:
                    message.bluetoothProxyFeatureFlags = reader.uint32();
                    break;
                case /* string manufacturer */ 12:
                    message.manufacturer = reader.string();
                    break;
                case /* string friendly_name */ 13:
                    message.friendlyName = reader.string();
                    break;
                case /* uint32 voice_assistant_version */ 14:
                    message.voiceAssistantVersion = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* bool uses_password = 1; */
        if (message.usesPassword !== false)
            writer.tag(1, runtime_1.WireType.Varint).bool(message.usesPassword);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.name);
        /* string mac_address = 3; */
        if (message.macAddress !== "")
            writer.tag(3, runtime_1.WireType.LengthDelimited).string(message.macAddress);
        /* string esphome_version = 4; */
        if (message.esphomeVersion !== "")
            writer.tag(4, runtime_1.WireType.LengthDelimited).string(message.esphomeVersion);
        /* string compilation_time = 5; */
        if (message.compilationTime !== "")
            writer.tag(5, runtime_1.WireType.LengthDelimited).string(message.compilationTime);
        /* string model = 6; */
        if (message.model !== "")
            writer.tag(6, runtime_1.WireType.LengthDelimited).string(message.model);
        /* bool has_deep_sleep = 7; */
        if (message.hasDeepSleep !== false)
            writer.tag(7, runtime_1.WireType.Varint).bool(message.hasDeepSleep);
        /* string project_name = 8; */
        if (message.projectName !== "")
            writer.tag(8, runtime_1.WireType.LengthDelimited).string(message.projectName);
        /* string project_version = 9; */
        if (message.projectVersion !== "")
            writer.tag(9, runtime_1.WireType.LengthDelimited).string(message.projectVersion);
        /* uint32 webserver_port = 10; */
        if (message.webserverPort !== 0)
            writer.tag(10, runtime_1.WireType.Varint).uint32(message.webserverPort);
        /* uint32 legacy_bluetooth_proxy_version = 11; */
        if (message.legacyBluetoothProxyVersion !== 0)
            writer.tag(11, runtime_1.WireType.Varint).uint32(message.legacyBluetoothProxyVersion);
        /* uint32 bluetooth_proxy_feature_flags = 15; */
        if (message.bluetoothProxyFeatureFlags !== 0)
            writer.tag(15, runtime_1.WireType.Varint).uint32(message.bluetoothProxyFeatureFlags);
        /* string manufacturer = 12; */
        if (message.manufacturer !== "")
            writer.tag(12, runtime_1.WireType.LengthDelimited).string(message.manufacturer);
        /* string friendly_name = 13; */
        if (message.friendlyName !== "")
            writer.tag(13, runtime_1.WireType.LengthDelimited).string(message.friendlyName);
        /* uint32 voice_assistant_version = 14; */
        if (message.voiceAssistantVersion !== 0)
            writer.tag(14, runtime_1.WireType.Varint).uint32(message.voiceAssistantVersion);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DeviceInfoResponse
 */
exports.DeviceInfoResponse = new DeviceInfoResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListEntitiesRequest$Type extends runtime_5.MessageType {
    constructor() {
        super("ListEntitiesRequest", [], { id: 11, source: "SOURCE_CLIENT" });
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        return target ?? this.create();
    }
    internalBinaryWrite(message, writer, options) {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ListEntitiesRequest
 */
exports.ListEntitiesRequest = new ListEntitiesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListEntitiesDoneResponse$Type extends runtime_5.MessageType {
    constructor() {
        super("ListEntitiesDoneResponse", [], { id: 19, source: "SOURCE_SERVER", no_delay: true });
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        return target ?? this.create();
    }
    internalBinaryWrite(message, writer, options) {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ListEntitiesDoneResponse
 */
exports.ListEntitiesDoneResponse = new ListEntitiesDoneResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeStatesRequest$Type extends runtime_5.MessageType {
    constructor() {
        super("SubscribeStatesRequest", [], { id: 20, source: "SOURCE_CLIENT" });
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        return target ?? this.create();
    }
    internalBinaryWrite(message, writer, options) {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SubscribeStatesRequest
 */
exports.SubscribeStatesRequest = new SubscribeStatesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListEntitiesBinarySensorResponse$Type extends runtime_5.MessageType {
    constructor() {
        super("ListEntitiesBinarySensorResponse", [
            { no: 1, name: "object_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "key", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ },
            { no: 3, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "unique_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "device_class", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "is_status_binary_sensor", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "disabled_by_default", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "icon", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "entity_category", kind: "enum", T: () => ["EntityCategory", EntityCategory, "ENTITY_CATEGORY_"] }
        ], { id: 12, source: "SOURCE_SERVER", ifdef: "USE_BINARY_SENSOR" });
    }
    create(value) {
        const message = { objectId: "", key: 0, name: "", uniqueId: "", deviceClass: "", isStatusBinarySensor: false, disabledByDefault: false, icon: "", entityCategory: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string object_id */ 1:
                    message.objectId = reader.string();
                    break;
                case /* fixed32 key */ 2:
                    message.key = reader.fixed32();
                    break;
                case /* string name */ 3:
                    message.name = reader.string();
                    break;
                case /* string unique_id */ 4:
                    message.uniqueId = reader.string();
                    break;
                case /* string device_class */ 5:
                    message.deviceClass = reader.string();
                    break;
                case /* bool is_status_binary_sensor */ 6:
                    message.isStatusBinarySensor = reader.bool();
                    break;
                case /* bool disabled_by_default */ 7:
                    message.disabledByDefault = reader.bool();
                    break;
                case /* string icon */ 8:
                    message.icon = reader.string();
                    break;
                case /* EntityCategory entity_category */ 9:
                    message.entityCategory = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string object_id = 1; */
        if (message.objectId !== "")
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.objectId);
        /* fixed32 key = 2; */
        if (message.key !== 0)
            writer.tag(2, runtime_1.WireType.Bit32).fixed32(message.key);
        /* string name = 3; */
        if (message.name !== "")
            writer.tag(3, runtime_1.WireType.LengthDelimited).string(message.name);
        /* string unique_id = 4; */
        if (message.uniqueId !== "")
            writer.tag(4, runtime_1.WireType.LengthDelimited).string(message.uniqueId);
        /* string device_class = 5; */
        if (message.deviceClass !== "")
            writer.tag(5, runtime_1.WireType.LengthDelimited).string(message.deviceClass);
        /* bool is_status_binary_sensor = 6; */
        if (message.isStatusBinarySensor !== false)
            writer.tag(6, runtime_1.WireType.Varint).bool(message.isStatusBinarySensor);
        /* bool disabled_by_default = 7; */
        if (message.disabledByDefault !== false)
            writer.tag(7, runtime_1.WireType.Varint).bool(message.disabledByDefault);
        /* string icon = 8; */
        if (message.icon !== "")
            writer.tag(8, runtime_1.WireType.LengthDelimited).string(message.icon);
        /* EntityCategory entity_category = 9; */
        if (message.entityCategory !== 0)
            writer.tag(9, runtime_1.WireType.Varint).int32(message.entityCategory);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ListEntitiesBinarySensorResponse
 */
exports.ListEntitiesBinarySensorResponse = new ListEntitiesBinarySensorResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BinarySensorStateResponse$Type extends runtime_5.MessageType {
    constructor() {
        super("BinarySensorStateResponse", [
            { no: 1, name: "key", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ },
            { no: 2, name: "state", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "missing_state", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ], { id: 21, source: "SOURCE_SERVER", ifdef: "USE_BINARY_SENSOR", no_delay: true });
    }
    create(value) {
        const message = { key: 0, state: false, missingState: false };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* fixed32 key */ 1:
                    message.key = reader.fixed32();
                    break;
                case /* bool state */ 2:
                    message.state = reader.bool();
                    break;
                case /* bool missing_state */ 3:
                    message.missingState = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* fixed32 key = 1; */
        if (message.key !== 0)
            writer.tag(1, runtime_1.WireType.Bit32).fixed32(message.key);
        /* bool state = 2; */
        if (message.state !== false)
            writer.tag(2, runtime_1.WireType.Varint).bool(message.state);
        /* bool missing_state = 3; */
        if (message.missingState !== false)
            writer.tag(3, runtime_1.WireType.Varint).bool(message.missingState);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message BinarySensorStateResponse
 */
exports.BinarySensorStateResponse = new BinarySensorStateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListEntitiesCoverResponse$Type extends runtime_5.MessageType {
    constructor() {
        super("ListEntitiesCoverResponse", [
            { no: 1, name: "object_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "key", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ },
            { no: 3, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "unique_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "assumed_state", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "supports_position", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "supports_tilt", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "device_class", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "disabled_by_default", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 10, name: "icon", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "entity_category", kind: "enum", T: () => ["EntityCategory", EntityCategory, "ENTITY_CATEGORY_"] },
            { no: 12, name: "supports_stop", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ], { id: 13, source: "SOURCE_SERVER", ifdef: "USE_COVER" });
    }
    create(value) {
        const message = { objectId: "", key: 0, name: "", uniqueId: "", assumedState: false, supportsPosition: false, supportsTilt: false, deviceClass: "", disabledByDefault: false, icon: "", entityCategory: 0, supportsStop: false };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string object_id */ 1:
                    message.objectId = reader.string();
                    break;
                case /* fixed32 key */ 2:
                    message.key = reader.fixed32();
                    break;
                case /* string name */ 3:
                    message.name = reader.string();
                    break;
                case /* string unique_id */ 4:
                    message.uniqueId = reader.string();
                    break;
                case /* bool assumed_state */ 5:
                    message.assumedState = reader.bool();
                    break;
                case /* bool supports_position */ 6:
                    message.supportsPosition = reader.bool();
                    break;
                case /* bool supports_tilt */ 7:
                    message.supportsTilt = reader.bool();
                    break;
                case /* string device_class */ 8:
                    message.deviceClass = reader.string();
                    break;
                case /* bool disabled_by_default */ 9:
                    message.disabledByDefault = reader.bool();
                    break;
                case /* string icon */ 10:
                    message.icon = reader.string();
                    break;
                case /* EntityCategory entity_category */ 11:
                    message.entityCategory = reader.int32();
                    break;
                case /* bool supports_stop */ 12:
                    message.supportsStop = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string object_id = 1; */
        if (message.objectId !== "")
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.objectId);
        /* fixed32 key = 2; */
        if (message.key !== 0)
            writer.tag(2, runtime_1.WireType.Bit32).fixed32(message.key);
        /* string name = 3; */
        if (message.name !== "")
            writer.tag(3, runtime_1.WireType.LengthDelimited).string(message.name);
        /* string unique_id = 4; */
        if (message.uniqueId !== "")
            writer.tag(4, runtime_1.WireType.LengthDelimited).string(message.uniqueId);
        /* bool assumed_state = 5; */
        if (message.assumedState !== false)
            writer.tag(5, runtime_1.WireType.Varint).bool(message.assumedState);
        /* bool supports_position = 6; */
        if (message.supportsPosition !== false)
            writer.tag(6, runtime_1.WireType.Varint).bool(message.supportsPosition);
        /* bool supports_tilt = 7; */
        if (message.supportsTilt !== false)
            writer.tag(7, runtime_1.WireType.Varint).bool(message.supportsTilt);
        /* string device_class = 8; */
        if (message.deviceClass !== "")
            writer.tag(8, runtime_1.WireType.LengthDelimited).string(message.deviceClass);
        /* bool disabled_by_default = 9; */
        if (message.disabledByDefault !== false)
            writer.tag(9, runtime_1.WireType.Varint).bool(message.disabledByDefault);
        /* string icon = 10; */
        if (message.icon !== "")
            writer.tag(10, runtime_1.WireType.LengthDelimited).string(message.icon);
        /* EntityCategory entity_category = 11; */
        if (message.entityCategory !== 0)
            writer.tag(11, runtime_1.WireType.Varint).int32(message.entityCategory);
        /* bool supports_stop = 12; */
        if (message.supportsStop !== false)
            writer.tag(12, runtime_1.WireType.Varint).bool(message.supportsStop);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ListEntitiesCoverResponse
 */
exports.ListEntitiesCoverResponse = new ListEntitiesCoverResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CoverStateResponse$Type extends runtime_5.MessageType {
    constructor() {
        super("CoverStateResponse", [
            { no: 1, name: "key", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ },
            { no: 2, name: "legacy_state", kind: "enum", T: () => ["LegacyCoverState", LegacyCoverState, "LEGACY_COVER_STATE_"] },
            { no: 3, name: "position", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "tilt", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 5, name: "current_operation", kind: "enum", T: () => ["CoverOperation", CoverOperation, "COVER_OPERATION_"] }
        ], { id: 22, source: "SOURCE_SERVER", ifdef: "USE_COVER", no_delay: true });
    }
    create(value) {
        const message = { key: 0, legacyState: 0, position: 0, tilt: 0, currentOperation: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* fixed32 key */ 1:
                    message.key = reader.fixed32();
                    break;
                case /* LegacyCoverState legacy_state */ 2:
                    message.legacyState = reader.int32();
                    break;
                case /* float position */ 3:
                    message.position = reader.float();
                    break;
                case /* float tilt */ 4:
                    message.tilt = reader.float();
                    break;
                case /* CoverOperation current_operation */ 5:
                    message.currentOperation = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* fixed32 key = 1; */
        if (message.key !== 0)
            writer.tag(1, runtime_1.WireType.Bit32).fixed32(message.key);
        /* LegacyCoverState legacy_state = 2; */
        if (message.legacyState !== 0)
            writer.tag(2, runtime_1.WireType.Varint).int32(message.legacyState);
        /* float position = 3; */
        if (message.position !== 0)
            writer.tag(3, runtime_1.WireType.Bit32).float(message.position);
        /* float tilt = 4; */
        if (message.tilt !== 0)
            writer.tag(4, runtime_1.WireType.Bit32).float(message.tilt);
        /* CoverOperation current_operation = 5; */
        if (message.currentOperation !== 0)
            writer.tag(5, runtime_1.WireType.Varint).int32(message.currentOperation);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CoverStateResponse
 */
exports.CoverStateResponse = new CoverStateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CoverCommandRequest$Type extends runtime_5.MessageType {
    constructor() {
        super("CoverCommandRequest", [
            { no: 1, name: "key", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ },
            { no: 2, name: "has_legacy_command", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "legacy_command", kind: "enum", T: () => ["LegacyCoverCommand", LegacyCoverCommand, "LEGACY_COVER_COMMAND_"] },
            { no: 4, name: "has_position", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "position", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 6, name: "has_tilt", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "tilt", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 8, name: "stop", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ], { id: 30, source: "SOURCE_CLIENT", ifdef: "USE_COVER", no_delay: true });
    }
    create(value) {
        const message = { key: 0, hasLegacyCommand: false, legacyCommand: 0, hasPosition: false, position: 0, hasTilt: false, tilt: 0, stop: false };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* fixed32 key */ 1:
                    message.key = reader.fixed32();
                    break;
                case /* bool has_legacy_command */ 2:
                    message.hasLegacyCommand = reader.bool();
                    break;
                case /* LegacyCoverCommand legacy_command */ 3:
                    message.legacyCommand = reader.int32();
                    break;
                case /* bool has_position */ 4:
                    message.hasPosition = reader.bool();
                    break;
                case /* float position */ 5:
                    message.position = reader.float();
                    break;
                case /* bool has_tilt */ 6:
                    message.hasTilt = reader.bool();
                    break;
                case /* float tilt */ 7:
                    message.tilt = reader.float();
                    break;
                case /* bool stop */ 8:
                    message.stop = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* fixed32 key = 1; */
        if (message.key !== 0)
            writer.tag(1, runtime_1.WireType.Bit32).fixed32(message.key);
        /* bool has_legacy_command = 2; */
        if (message.hasLegacyCommand !== false)
            writer.tag(2, runtime_1.WireType.Varint).bool(message.hasLegacyCommand);
        /* LegacyCoverCommand legacy_command = 3; */
        if (message.legacyCommand !== 0)
            writer.tag(3, runtime_1.WireType.Varint).int32(message.legacyCommand);
        /* bool has_position = 4; */
        if (message.hasPosition !== false)
            writer.tag(4, runtime_1.WireType.Varint).bool(message.hasPosition);
        /* float position = 5; */
        if (message.position !== 0)
            writer.tag(5, runtime_1.WireType.Bit32).float(message.position);
        /* bool has_tilt = 6; */
        if (message.hasTilt !== false)
            writer.tag(6, runtime_1.WireType.Varint).bool(message.hasTilt);
        /* float tilt = 7; */
        if (message.tilt !== 0)
            writer.tag(7, runtime_1.WireType.Bit32).float(message.tilt);
        /* bool stop = 8; */
        if (message.stop !== false)
            writer.tag(8, runtime_1.WireType.Varint).bool(message.stop);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CoverCommandRequest
 */
exports.CoverCommandRequest = new CoverCommandRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListEntitiesFanResponse$Type extends runtime_5.MessageType {
    constructor() {
        super("ListEntitiesFanResponse", [
            { no: 1, name: "object_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "key", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ },
            { no: 3, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "unique_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "supports_oscillation", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "supports_speed", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "supports_direction", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "supported_speed_levels", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 9, name: "disabled_by_default", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 10, name: "icon", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "entity_category", kind: "enum", T: () => ["EntityCategory", EntityCategory, "ENTITY_CATEGORY_"] }
        ], { id: 14, source: "SOURCE_SERVER", ifdef: "USE_FAN" });
    }
    create(value) {
        const message = { objectId: "", key: 0, name: "", uniqueId: "", supportsOscillation: false, supportsSpeed: false, supportsDirection: false, supportedSpeedLevels: 0, disabledByDefault: false, icon: "", entityCategory: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string object_id */ 1:
                    message.objectId = reader.string();
                    break;
                case /* fixed32 key */ 2:
                    message.key = reader.fixed32();
                    break;
                case /* string name */ 3:
                    message.name = reader.string();
                    break;
                case /* string unique_id */ 4:
                    message.uniqueId = reader.string();
                    break;
                case /* bool supports_oscillation */ 5:
                    message.supportsOscillation = reader.bool();
                    break;
                case /* bool supports_speed */ 6:
                    message.supportsSpeed = reader.bool();
                    break;
                case /* bool supports_direction */ 7:
                    message.supportsDirection = reader.bool();
                    break;
                case /* int32 supported_speed_levels */ 8:
                    message.supportedSpeedLevels = reader.int32();
                    break;
                case /* bool disabled_by_default */ 9:
                    message.disabledByDefault = reader.bool();
                    break;
                case /* string icon */ 10:
                    message.icon = reader.string();
                    break;
                case /* EntityCategory entity_category */ 11:
                    message.entityCategory = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string object_id = 1; */
        if (message.objectId !== "")
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.objectId);
        /* fixed32 key = 2; */
        if (message.key !== 0)
            writer.tag(2, runtime_1.WireType.Bit32).fixed32(message.key);
        /* string name = 3; */
        if (message.name !== "")
            writer.tag(3, runtime_1.WireType.LengthDelimited).string(message.name);
        /* string unique_id = 4; */
        if (message.uniqueId !== "")
            writer.tag(4, runtime_1.WireType.LengthDelimited).string(message.uniqueId);
        /* bool supports_oscillation = 5; */
        if (message.supportsOscillation !== false)
            writer.tag(5, runtime_1.WireType.Varint).bool(message.supportsOscillation);
        /* bool supports_speed = 6; */
        if (message.supportsSpeed !== false)
            writer.tag(6, runtime_1.WireType.Varint).bool(message.supportsSpeed);
        /* bool supports_direction = 7; */
        if (message.supportsDirection !== false)
            writer.tag(7, runtime_1.WireType.Varint).bool(message.supportsDirection);
        /* int32 supported_speed_levels = 8; */
        if (message.supportedSpeedLevels !== 0)
            writer.tag(8, runtime_1.WireType.Varint).int32(message.supportedSpeedLevels);
        /* bool disabled_by_default = 9; */
        if (message.disabledByDefault !== false)
            writer.tag(9, runtime_1.WireType.Varint).bool(message.disabledByDefault);
        /* string icon = 10; */
        if (message.icon !== "")
            writer.tag(10, runtime_1.WireType.LengthDelimited).string(message.icon);
        /* EntityCategory entity_category = 11; */
        if (message.entityCategory !== 0)
            writer.tag(11, runtime_1.WireType.Varint).int32(message.entityCategory);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ListEntitiesFanResponse
 */
exports.ListEntitiesFanResponse = new ListEntitiesFanResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FanStateResponse$Type extends runtime_5.MessageType {
    constructor() {
        super("FanStateResponse", [
            { no: 1, name: "key", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ },
            { no: 2, name: "state", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "oscillating", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "speed", kind: "enum", T: () => ["FanSpeed", FanSpeed, "FAN_SPEED_"] },
            { no: 5, name: "direction", kind: "enum", T: () => ["FanDirection", FanDirection, "FAN_DIRECTION_"] },
            { no: 6, name: "speed_level", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ], { id: 23, source: "SOURCE_SERVER", ifdef: "USE_FAN", no_delay: true });
    }
    create(value) {
        const message = { key: 0, state: false, oscillating: false, speed: 0, direction: 0, speedLevel: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* fixed32 key */ 1:
                    message.key = reader.fixed32();
                    break;
                case /* bool state */ 2:
                    message.state = reader.bool();
                    break;
                case /* bool oscillating */ 3:
                    message.oscillating = reader.bool();
                    break;
                case /* FanSpeed speed = 4 [deprecated = true];*/ 4:
                    message.speed = reader.int32();
                    break;
                case /* FanDirection direction */ 5:
                    message.direction = reader.int32();
                    break;
                case /* int32 speed_level */ 6:
                    message.speedLevel = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* fixed32 key = 1; */
        if (message.key !== 0)
            writer.tag(1, runtime_1.WireType.Bit32).fixed32(message.key);
        /* bool state = 2; */
        if (message.state !== false)
            writer.tag(2, runtime_1.WireType.Varint).bool(message.state);
        /* bool oscillating = 3; */
        if (message.oscillating !== false)
            writer.tag(3, runtime_1.WireType.Varint).bool(message.oscillating);
        /* FanSpeed speed = 4 [deprecated = true]; */
        if (message.speed !== 0)
            writer.tag(4, runtime_1.WireType.Varint).int32(message.speed);
        /* FanDirection direction = 5; */
        if (message.direction !== 0)
            writer.tag(5, runtime_1.WireType.Varint).int32(message.direction);
        /* int32 speed_level = 6; */
        if (message.speedLevel !== 0)
            writer.tag(6, runtime_1.WireType.Varint).int32(message.speedLevel);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message FanStateResponse
 */
exports.FanStateResponse = new FanStateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FanCommandRequest$Type extends runtime_5.MessageType {
    constructor() {
        super("FanCommandRequest", [
            { no: 1, name: "key", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ },
            { no: 2, name: "has_state", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "state", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "has_speed", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "speed", kind: "enum", T: () => ["FanSpeed", FanSpeed, "FAN_SPEED_"] },
            { no: 6, name: "has_oscillating", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "oscillating", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "has_direction", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "direction", kind: "enum", T: () => ["FanDirection", FanDirection, "FAN_DIRECTION_"] },
            { no: 10, name: "has_speed_level", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 11, name: "speed_level", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ], { id: 31, source: "SOURCE_CLIENT", ifdef: "USE_FAN", no_delay: true });
    }
    create(value) {
        const message = { key: 0, hasState: false, state: false, hasSpeed: false, speed: 0, hasOscillating: false, oscillating: false, hasDirection: false, direction: 0, hasSpeedLevel: false, speedLevel: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* fixed32 key */ 1:
                    message.key = reader.fixed32();
                    break;
                case /* bool has_state */ 2:
                    message.hasState = reader.bool();
                    break;
                case /* bool state */ 3:
                    message.state = reader.bool();
                    break;
                case /* bool has_speed = 4 [deprecated = true];*/ 4:
                    message.hasSpeed = reader.bool();
                    break;
                case /* FanSpeed speed = 5 [deprecated = true];*/ 5:
                    message.speed = reader.int32();
                    break;
                case /* bool has_oscillating */ 6:
                    message.hasOscillating = reader.bool();
                    break;
                case /* bool oscillating */ 7:
                    message.oscillating = reader.bool();
                    break;
                case /* bool has_direction */ 8:
                    message.hasDirection = reader.bool();
                    break;
                case /* FanDirection direction */ 9:
                    message.direction = reader.int32();
                    break;
                case /* bool has_speed_level */ 10:
                    message.hasSpeedLevel = reader.bool();
                    break;
                case /* int32 speed_level */ 11:
                    message.speedLevel = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* fixed32 key = 1; */
        if (message.key !== 0)
            writer.tag(1, runtime_1.WireType.Bit32).fixed32(message.key);
        /* bool has_state = 2; */
        if (message.hasState !== false)
            writer.tag(2, runtime_1.WireType.Varint).bool(message.hasState);
        /* bool state = 3; */
        if (message.state !== false)
            writer.tag(3, runtime_1.WireType.Varint).bool(message.state);
        /* bool has_speed = 4 [deprecated = true]; */
        if (message.hasSpeed !== false)
            writer.tag(4, runtime_1.WireType.Varint).bool(message.hasSpeed);
        /* FanSpeed speed = 5 [deprecated = true]; */
        if (message.speed !== 0)
            writer.tag(5, runtime_1.WireType.Varint).int32(message.speed);
        /* bool has_oscillating = 6; */
        if (message.hasOscillating !== false)
            writer.tag(6, runtime_1.WireType.Varint).bool(message.hasOscillating);
        /* bool oscillating = 7; */
        if (message.oscillating !== false)
            writer.tag(7, runtime_1.WireType.Varint).bool(message.oscillating);
        /* bool has_direction = 8; */
        if (message.hasDirection !== false)
            writer.tag(8, runtime_1.WireType.Varint).bool(message.hasDirection);
        /* FanDirection direction = 9; */
        if (message.direction !== 0)
            writer.tag(9, runtime_1.WireType.Varint).int32(message.direction);
        /* bool has_speed_level = 10; */
        if (message.hasSpeedLevel !== false)
            writer.tag(10, runtime_1.WireType.Varint).bool(message.hasSpeedLevel);
        /* int32 speed_level = 11; */
        if (message.speedLevel !== 0)
            writer.tag(11, runtime_1.WireType.Varint).int32(message.speedLevel);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message FanCommandRequest
 */
exports.FanCommandRequest = new FanCommandRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListEntitiesLightResponse$Type extends runtime_5.MessageType {
    constructor() {
        super("ListEntitiesLightResponse", [
            { no: 1, name: "object_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "key", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ },
            { no: 3, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "unique_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "supported_color_modes", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "legacy_supports_brightness", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "legacy_supports_rgb", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "legacy_supports_white_value", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "legacy_supports_color_temperature", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "min_mireds", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 10, name: "max_mireds", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 11, name: "effects", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 13, name: "disabled_by_default", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 14, name: "icon", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 15, name: "entity_category", kind: "enum", T: () => ["EntityCategory", EntityCategory, "ENTITY_CATEGORY_"] }
        ], { id: 15, source: "SOURCE_SERVER", ifdef: "USE_LIGHT" });
    }
    create(value) {
        const message = { objectId: "", key: 0, name: "", uniqueId: "", supportedColorModes: [], legacySupportsBrightness: false, legacySupportsRgb: false, legacySupportsWhiteValue: false, legacySupportsColorTemperature: false, minMireds: 0, maxMireds: 0, effects: [], disabledByDefault: false, icon: "", entityCategory: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string object_id */ 1:
                    message.objectId = reader.string();
                    break;
                case /* fixed32 key */ 2:
                    message.key = reader.fixed32();
                    break;
                case /* string name */ 3:
                    message.name = reader.string();
                    break;
                case /* string unique_id */ 4:
                    message.uniqueId = reader.string();
                    break;
                case /* repeated int32 supported_color_modes */ 12:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.supportedColorModes.push(reader.int32());
                    else
                        message.supportedColorModes.push(reader.int32());
                    break;
                case /* bool legacy_supports_brightness = 5 [deprecated = true];*/ 5:
                    message.legacySupportsBrightness = reader.bool();
                    break;
                case /* bool legacy_supports_rgb = 6 [deprecated = true];*/ 6:
                    message.legacySupportsRgb = reader.bool();
                    break;
                case /* bool legacy_supports_white_value = 7 [deprecated = true];*/ 7:
                    message.legacySupportsWhiteValue = reader.bool();
                    break;
                case /* bool legacy_supports_color_temperature = 8 [deprecated = true];*/ 8:
                    message.legacySupportsColorTemperature = reader.bool();
                    break;
                case /* float min_mireds */ 9:
                    message.minMireds = reader.float();
                    break;
                case /* float max_mireds */ 10:
                    message.maxMireds = reader.float();
                    break;
                case /* repeated string effects */ 11:
                    message.effects.push(reader.string());
                    break;
                case /* bool disabled_by_default */ 13:
                    message.disabledByDefault = reader.bool();
                    break;
                case /* string icon */ 14:
                    message.icon = reader.string();
                    break;
                case /* EntityCategory entity_category */ 15:
                    message.entityCategory = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string object_id = 1; */
        if (message.objectId !== "")
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.objectId);
        /* fixed32 key = 2; */
        if (message.key !== 0)
            writer.tag(2, runtime_1.WireType.Bit32).fixed32(message.key);
        /* string name = 3; */
        if (message.name !== "")
            writer.tag(3, runtime_1.WireType.LengthDelimited).string(message.name);
        /* string unique_id = 4; */
        if (message.uniqueId !== "")
            writer.tag(4, runtime_1.WireType.LengthDelimited).string(message.uniqueId);
        /* repeated int32 supported_color_modes = 12; */
        if (message.supportedColorModes.length) {
            writer.tag(12, runtime_1.WireType.LengthDelimited).fork();
            for (let i = 0; i < message.supportedColorModes.length; i++)
                writer.int32(message.supportedColorModes[i]);
            writer.join();
        }
        /* bool legacy_supports_brightness = 5 [deprecated = true]; */
        if (message.legacySupportsBrightness !== false)
            writer.tag(5, runtime_1.WireType.Varint).bool(message.legacySupportsBrightness);
        /* bool legacy_supports_rgb = 6 [deprecated = true]; */
        if (message.legacySupportsRgb !== false)
            writer.tag(6, runtime_1.WireType.Varint).bool(message.legacySupportsRgb);
        /* bool legacy_supports_white_value = 7 [deprecated = true]; */
        if (message.legacySupportsWhiteValue !== false)
            writer.tag(7, runtime_1.WireType.Varint).bool(message.legacySupportsWhiteValue);
        /* bool legacy_supports_color_temperature = 8 [deprecated = true]; */
        if (message.legacySupportsColorTemperature !== false)
            writer.tag(8, runtime_1.WireType.Varint).bool(message.legacySupportsColorTemperature);
        /* float min_mireds = 9; */
        if (message.minMireds !== 0)
            writer.tag(9, runtime_1.WireType.Bit32).float(message.minMireds);
        /* float max_mireds = 10; */
        if (message.maxMireds !== 0)
            writer.tag(10, runtime_1.WireType.Bit32).float(message.maxMireds);
        /* repeated string effects = 11; */
        for (let i = 0; i < message.effects.length; i++)
            writer.tag(11, runtime_1.WireType.LengthDelimited).string(message.effects[i]);
        /* bool disabled_by_default = 13; */
        if (message.disabledByDefault !== false)
            writer.tag(13, runtime_1.WireType.Varint).bool(message.disabledByDefault);
        /* string icon = 14; */
        if (message.icon !== "")
            writer.tag(14, runtime_1.WireType.LengthDelimited).string(message.icon);
        /* EntityCategory entity_category = 15; */
        if (message.entityCategory !== 0)
            writer.tag(15, runtime_1.WireType.Varint).int32(message.entityCategory);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ListEntitiesLightResponse
 */
exports.ListEntitiesLightResponse = new ListEntitiesLightResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LightStateResponse$Type extends runtime_5.MessageType {
    constructor() {
        super("LightStateResponse", [
            { no: 1, name: "key", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ },
            { no: 2, name: "state", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "brightness", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 11, name: "color_mode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 10, name: "color_brightness", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "red", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 5, name: "green", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 6, name: "blue", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 7, name: "white", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 8, name: "color_temperature", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 12, name: "cold_white", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 13, name: "warm_white", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 9, name: "effect", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { id: 24, source: "SOURCE_SERVER", ifdef: "USE_LIGHT", no_delay: true });
    }
    create(value) {
        const message = { key: 0, state: false, brightness: 0, colorMode: 0, colorBrightness: 0, red: 0, green: 0, blue: 0, white: 0, colorTemperature: 0, coldWhite: 0, warmWhite: 0, effect: "" };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* fixed32 key */ 1:
                    message.key = reader.fixed32();
                    break;
                case /* bool state */ 2:
                    message.state = reader.bool();
                    break;
                case /* float brightness */ 3:
                    message.brightness = reader.float();
                    break;
                case /* int32 color_mode */ 11:
                    message.colorMode = reader.int32();
                    break;
                case /* float color_brightness */ 10:
                    message.colorBrightness = reader.float();
                    break;
                case /* float red */ 4:
                    message.red = reader.float();
                    break;
                case /* float green */ 5:
                    message.green = reader.float();
                    break;
                case /* float blue */ 6:
                    message.blue = reader.float();
                    break;
                case /* float white */ 7:
                    message.white = reader.float();
                    break;
                case /* float color_temperature */ 8:
                    message.colorTemperature = reader.float();
                    break;
                case /* float cold_white */ 12:
                    message.coldWhite = reader.float();
                    break;
                case /* float warm_white */ 13:
                    message.warmWhite = reader.float();
                    break;
                case /* string effect */ 9:
                    message.effect = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* fixed32 key = 1; */
        if (message.key !== 0)
            writer.tag(1, runtime_1.WireType.Bit32).fixed32(message.key);
        /* bool state = 2; */
        if (message.state !== false)
            writer.tag(2, runtime_1.WireType.Varint).bool(message.state);
        /* float brightness = 3; */
        if (message.brightness !== 0)
            writer.tag(3, runtime_1.WireType.Bit32).float(message.brightness);
        /* int32 color_mode = 11; */
        if (message.colorMode !== 0)
            writer.tag(11, runtime_1.WireType.Varint).int32(message.colorMode);
        /* float color_brightness = 10; */
        if (message.colorBrightness !== 0)
            writer.tag(10, runtime_1.WireType.Bit32).float(message.colorBrightness);
        /* float red = 4; */
        if (message.red !== 0)
            writer.tag(4, runtime_1.WireType.Bit32).float(message.red);
        /* float green = 5; */
        if (message.green !== 0)
            writer.tag(5, runtime_1.WireType.Bit32).float(message.green);
        /* float blue = 6; */
        if (message.blue !== 0)
            writer.tag(6, runtime_1.WireType.Bit32).float(message.blue);
        /* float white = 7; */
        if (message.white !== 0)
            writer.tag(7, runtime_1.WireType.Bit32).float(message.white);
        /* float color_temperature = 8; */
        if (message.colorTemperature !== 0)
            writer.tag(8, runtime_1.WireType.Bit32).float(message.colorTemperature);
        /* float cold_white = 12; */
        if (message.coldWhite !== 0)
            writer.tag(12, runtime_1.WireType.Bit32).float(message.coldWhite);
        /* float warm_white = 13; */
        if (message.warmWhite !== 0)
            writer.tag(13, runtime_1.WireType.Bit32).float(message.warmWhite);
        /* string effect = 9; */
        if (message.effect !== "")
            writer.tag(9, runtime_1.WireType.LengthDelimited).string(message.effect);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message LightStateResponse
 */
exports.LightStateResponse = new LightStateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LightCommandRequest$Type extends runtime_5.MessageType {
    constructor() {
        super("LightCommandRequest", [
            { no: 1, name: "key", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ },
            { no: 2, name: "has_state", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "state", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "has_brightness", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "brightness", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 22, name: "has_color_mode", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 23, name: "color_mode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 20, name: "has_color_brightness", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 21, name: "color_brightness", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 6, name: "has_rgb", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "red", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 8, name: "green", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 9, name: "blue", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 10, name: "has_white", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 11, name: "white", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 12, name: "has_color_temperature", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 13, name: "color_temperature", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 24, name: "has_cold_white", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 25, name: "cold_white", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 26, name: "has_warm_white", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 27, name: "warm_white", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 14, name: "has_transition_length", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 15, name: "transition_length", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 16, name: "has_flash_length", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 17, name: "flash_length", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 18, name: "has_effect", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 19, name: "effect", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { id: 32, source: "SOURCE_CLIENT", ifdef: "USE_LIGHT", no_delay: true });
    }
    create(value) {
        const message = { key: 0, hasState: false, state: false, hasBrightness: false, brightness: 0, hasColorMode: false, colorMode: 0, hasColorBrightness: false, colorBrightness: 0, hasRgb: false, red: 0, green: 0, blue: 0, hasWhite: false, white: 0, hasColorTemperature: false, colorTemperature: 0, hasColdWhite: false, coldWhite: 0, hasWarmWhite: false, warmWhite: 0, hasTransitionLength: false, transitionLength: 0, hasFlashLength: false, flashLength: 0, hasEffect: false, effect: "" };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* fixed32 key */ 1:
                    message.key = reader.fixed32();
                    break;
                case /* bool has_state */ 2:
                    message.hasState = reader.bool();
                    break;
                case /* bool state */ 3:
                    message.state = reader.bool();
                    break;
                case /* bool has_brightness */ 4:
                    message.hasBrightness = reader.bool();
                    break;
                case /* float brightness */ 5:
                    message.brightness = reader.float();
                    break;
                case /* bool has_color_mode */ 22:
                    message.hasColorMode = reader.bool();
                    break;
                case /* int32 color_mode */ 23:
                    message.colorMode = reader.int32();
                    break;
                case /* bool has_color_brightness */ 20:
                    message.hasColorBrightness = reader.bool();
                    break;
                case /* float color_brightness */ 21:
                    message.colorBrightness = reader.float();
                    break;
                case /* bool has_rgb */ 6:
                    message.hasRgb = reader.bool();
                    break;
                case /* float red */ 7:
                    message.red = reader.float();
                    break;
                case /* float green */ 8:
                    message.green = reader.float();
                    break;
                case /* float blue */ 9:
                    message.blue = reader.float();
                    break;
                case /* bool has_white */ 10:
                    message.hasWhite = reader.bool();
                    break;
                case /* float white */ 11:
                    message.white = reader.float();
                    break;
                case /* bool has_color_temperature */ 12:
                    message.hasColorTemperature = reader.bool();
                    break;
                case /* float color_temperature */ 13:
                    message.colorTemperature = reader.float();
                    break;
                case /* bool has_cold_white */ 24:
                    message.hasColdWhite = reader.bool();
                    break;
                case /* float cold_white */ 25:
                    message.coldWhite = reader.float();
                    break;
                case /* bool has_warm_white */ 26:
                    message.hasWarmWhite = reader.bool();
                    break;
                case /* float warm_white */ 27:
                    message.warmWhite = reader.float();
                    break;
                case /* bool has_transition_length */ 14:
                    message.hasTransitionLength = reader.bool();
                    break;
                case /* uint32 transition_length */ 15:
                    message.transitionLength = reader.uint32();
                    break;
                case /* bool has_flash_length */ 16:
                    message.hasFlashLength = reader.bool();
                    break;
                case /* uint32 flash_length */ 17:
                    message.flashLength = reader.uint32();
                    break;
                case /* bool has_effect */ 18:
                    message.hasEffect = reader.bool();
                    break;
                case /* string effect */ 19:
                    message.effect = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* fixed32 key = 1; */
        if (message.key !== 0)
            writer.tag(1, runtime_1.WireType.Bit32).fixed32(message.key);
        /* bool has_state = 2; */
        if (message.hasState !== false)
            writer.tag(2, runtime_1.WireType.Varint).bool(message.hasState);
        /* bool state = 3; */
        if (message.state !== false)
            writer.tag(3, runtime_1.WireType.Varint).bool(message.state);
        /* bool has_brightness = 4; */
        if (message.hasBrightness !== false)
            writer.tag(4, runtime_1.WireType.Varint).bool(message.hasBrightness);
        /* float brightness = 5; */
        if (message.brightness !== 0)
            writer.tag(5, runtime_1.WireType.Bit32).float(message.brightness);
        /* bool has_color_mode = 22; */
        if (message.hasColorMode !== false)
            writer.tag(22, runtime_1.WireType.Varint).bool(message.hasColorMode);
        /* int32 color_mode = 23; */
        if (message.colorMode !== 0)
            writer.tag(23, runtime_1.WireType.Varint).int32(message.colorMode);
        /* bool has_color_brightness = 20; */
        if (message.hasColorBrightness !== false)
            writer.tag(20, runtime_1.WireType.Varint).bool(message.hasColorBrightness);
        /* float color_brightness = 21; */
        if (message.colorBrightness !== 0)
            writer.tag(21, runtime_1.WireType.Bit32).float(message.colorBrightness);
        /* bool has_rgb = 6; */
        if (message.hasRgb !== false)
            writer.tag(6, runtime_1.WireType.Varint).bool(message.hasRgb);
        /* float red = 7; */
        if (message.red !== 0)
            writer.tag(7, runtime_1.WireType.Bit32).float(message.red);
        /* float green = 8; */
        if (message.green !== 0)
            writer.tag(8, runtime_1.WireType.Bit32).float(message.green);
        /* float blue = 9; */
        if (message.blue !== 0)
            writer.tag(9, runtime_1.WireType.Bit32).float(message.blue);
        /* bool has_white = 10; */
        if (message.hasWhite !== false)
            writer.tag(10, runtime_1.WireType.Varint).bool(message.hasWhite);
        /* float white = 11; */
        if (message.white !== 0)
            writer.tag(11, runtime_1.WireType.Bit32).float(message.white);
        /* bool has_color_temperature = 12; */
        if (message.hasColorTemperature !== false)
            writer.tag(12, runtime_1.WireType.Varint).bool(message.hasColorTemperature);
        /* float color_temperature = 13; */
        if (message.colorTemperature !== 0)
            writer.tag(13, runtime_1.WireType.Bit32).float(message.colorTemperature);
        /* bool has_cold_white = 24; */
        if (message.hasColdWhite !== false)
            writer.tag(24, runtime_1.WireType.Varint).bool(message.hasColdWhite);
        /* float cold_white = 25; */
        if (message.coldWhite !== 0)
            writer.tag(25, runtime_1.WireType.Bit32).float(message.coldWhite);
        /* bool has_warm_white = 26; */
        if (message.hasWarmWhite !== false)
            writer.tag(26, runtime_1.WireType.Varint).bool(message.hasWarmWhite);
        /* float warm_white = 27; */
        if (message.warmWhite !== 0)
            writer.tag(27, runtime_1.WireType.Bit32).float(message.warmWhite);
        /* bool has_transition_length = 14; */
        if (message.hasTransitionLength !== false)
            writer.tag(14, runtime_1.WireType.Varint).bool(message.hasTransitionLength);
        /* uint32 transition_length = 15; */
        if (message.transitionLength !== 0)
            writer.tag(15, runtime_1.WireType.Varint).uint32(message.transitionLength);
        /* bool has_flash_length = 16; */
        if (message.hasFlashLength !== false)
            writer.tag(16, runtime_1.WireType.Varint).bool(message.hasFlashLength);
        /* uint32 flash_length = 17; */
        if (message.flashLength !== 0)
            writer.tag(17, runtime_1.WireType.Varint).uint32(message.flashLength);
        /* bool has_effect = 18; */
        if (message.hasEffect !== false)
            writer.tag(18, runtime_1.WireType.Varint).bool(message.hasEffect);
        /* string effect = 19; */
        if (message.effect !== "")
            writer.tag(19, runtime_1.WireType.LengthDelimited).string(message.effect);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message LightCommandRequest
 */
exports.LightCommandRequest = new LightCommandRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListEntitiesSensorResponse$Type extends runtime_5.MessageType {
    constructor() {
        super("ListEntitiesSensorResponse", [
            { no: 1, name: "object_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "key", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ },
            { no: 3, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "unique_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "icon", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "unit_of_measurement", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "accuracy_decimals", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "force_update", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "device_class", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "state_class", kind: "enum", T: () => ["SensorStateClass", SensorStateClass] },
            { no: 11, name: "last_reset_type", kind: "enum", T: () => ["SensorLastResetType", SensorLastResetType] },
            { no: 12, name: "disabled_by_default", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 13, name: "entity_category", kind: "enum", T: () => ["EntityCategory", EntityCategory, "ENTITY_CATEGORY_"] }
        ], { id: 16, source: "SOURCE_SERVER", ifdef: "USE_SENSOR" });
    }
    create(value) {
        const message = { objectId: "", key: 0, name: "", uniqueId: "", icon: "", unitOfMeasurement: "", accuracyDecimals: 0, forceUpdate: false, deviceClass: "", stateClass: 0, lastResetType: 0, disabledByDefault: false, entityCategory: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string object_id */ 1:
                    message.objectId = reader.string();
                    break;
                case /* fixed32 key */ 2:
                    message.key = reader.fixed32();
                    break;
                case /* string name */ 3:
                    message.name = reader.string();
                    break;
                case /* string unique_id */ 4:
                    message.uniqueId = reader.string();
                    break;
                case /* string icon */ 5:
                    message.icon = reader.string();
                    break;
                case /* string unit_of_measurement */ 6:
                    message.unitOfMeasurement = reader.string();
                    break;
                case /* int32 accuracy_decimals */ 7:
                    message.accuracyDecimals = reader.int32();
                    break;
                case /* bool force_update */ 8:
                    message.forceUpdate = reader.bool();
                    break;
                case /* string device_class */ 9:
                    message.deviceClass = reader.string();
                    break;
                case /* SensorStateClass state_class */ 10:
                    message.stateClass = reader.int32();
                    break;
                case /* SensorLastResetType last_reset_type */ 11:
                    message.lastResetType = reader.int32();
                    break;
                case /* bool disabled_by_default */ 12:
                    message.disabledByDefault = reader.bool();
                    break;
                case /* EntityCategory entity_category */ 13:
                    message.entityCategory = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string object_id = 1; */
        if (message.objectId !== "")
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.objectId);
        /* fixed32 key = 2; */
        if (message.key !== 0)
            writer.tag(2, runtime_1.WireType.Bit32).fixed32(message.key);
        /* string name = 3; */
        if (message.name !== "")
            writer.tag(3, runtime_1.WireType.LengthDelimited).string(message.name);
        /* string unique_id = 4; */
        if (message.uniqueId !== "")
            writer.tag(4, runtime_1.WireType.LengthDelimited).string(message.uniqueId);
        /* string icon = 5; */
        if (message.icon !== "")
            writer.tag(5, runtime_1.WireType.LengthDelimited).string(message.icon);
        /* string unit_of_measurement = 6; */
        if (message.unitOfMeasurement !== "")
            writer.tag(6, runtime_1.WireType.LengthDelimited).string(message.unitOfMeasurement);
        /* int32 accuracy_decimals = 7; */
        if (message.accuracyDecimals !== 0)
            writer.tag(7, runtime_1.WireType.Varint).int32(message.accuracyDecimals);
        /* bool force_update = 8; */
        if (message.forceUpdate !== false)
            writer.tag(8, runtime_1.WireType.Varint).bool(message.forceUpdate);
        /* string device_class = 9; */
        if (message.deviceClass !== "")
            writer.tag(9, runtime_1.WireType.LengthDelimited).string(message.deviceClass);
        /* SensorStateClass state_class = 10; */
        if (message.stateClass !== 0)
            writer.tag(10, runtime_1.WireType.Varint).int32(message.stateClass);
        /* SensorLastResetType last_reset_type = 11; */
        if (message.lastResetType !== 0)
            writer.tag(11, runtime_1.WireType.Varint).int32(message.lastResetType);
        /* bool disabled_by_default = 12; */
        if (message.disabledByDefault !== false)
            writer.tag(12, runtime_1.WireType.Varint).bool(message.disabledByDefault);
        /* EntityCategory entity_category = 13; */
        if (message.entityCategory !== 0)
            writer.tag(13, runtime_1.WireType.Varint).int32(message.entityCategory);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ListEntitiesSensorResponse
 */
exports.ListEntitiesSensorResponse = new ListEntitiesSensorResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SensorStateResponse$Type extends runtime_5.MessageType {
    constructor() {
        super("SensorStateResponse", [
            { no: 1, name: "key", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ },
            { no: 2, name: "state", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "missing_state", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ], { id: 25, source: "SOURCE_SERVER", ifdef: "USE_SENSOR", no_delay: true });
    }
    create(value) {
        const message = { key: 0, state: 0, missingState: false };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* fixed32 key */ 1:
                    message.key = reader.fixed32();
                    break;
                case /* float state */ 2:
                    message.state = reader.float();
                    break;
                case /* bool missing_state */ 3:
                    message.missingState = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* fixed32 key = 1; */
        if (message.key !== 0)
            writer.tag(1, runtime_1.WireType.Bit32).fixed32(message.key);
        /* float state = 2; */
        if (message.state !== 0)
            writer.tag(2, runtime_1.WireType.Bit32).float(message.state);
        /* bool missing_state = 3; */
        if (message.missingState !== false)
            writer.tag(3, runtime_1.WireType.Varint).bool(message.missingState);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SensorStateResponse
 */
exports.SensorStateResponse = new SensorStateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListEntitiesSwitchResponse$Type extends runtime_5.MessageType {
    constructor() {
        super("ListEntitiesSwitchResponse", [
            { no: 1, name: "object_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "key", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ },
            { no: 3, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "unique_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "icon", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "assumed_state", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "disabled_by_default", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "entity_category", kind: "enum", T: () => ["EntityCategory", EntityCategory, "ENTITY_CATEGORY_"] },
            { no: 9, name: "device_class", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { id: 17, source: "SOURCE_SERVER", ifdef: "USE_SWITCH" });
    }
    create(value) {
        const message = { objectId: "", key: 0, name: "", uniqueId: "", icon: "", assumedState: false, disabledByDefault: false, entityCategory: 0, deviceClass: "" };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string object_id */ 1:
                    message.objectId = reader.string();
                    break;
                case /* fixed32 key */ 2:
                    message.key = reader.fixed32();
                    break;
                case /* string name */ 3:
                    message.name = reader.string();
                    break;
                case /* string unique_id */ 4:
                    message.uniqueId = reader.string();
                    break;
                case /* string icon */ 5:
                    message.icon = reader.string();
                    break;
                case /* bool assumed_state */ 6:
                    message.assumedState = reader.bool();
                    break;
                case /* bool disabled_by_default */ 7:
                    message.disabledByDefault = reader.bool();
                    break;
                case /* EntityCategory entity_category */ 8:
                    message.entityCategory = reader.int32();
                    break;
                case /* string device_class */ 9:
                    message.deviceClass = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string object_id = 1; */
        if (message.objectId !== "")
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.objectId);
        /* fixed32 key = 2; */
        if (message.key !== 0)
            writer.tag(2, runtime_1.WireType.Bit32).fixed32(message.key);
        /* string name = 3; */
        if (message.name !== "")
            writer.tag(3, runtime_1.WireType.LengthDelimited).string(message.name);
        /* string unique_id = 4; */
        if (message.uniqueId !== "")
            writer.tag(4, runtime_1.WireType.LengthDelimited).string(message.uniqueId);
        /* string icon = 5; */
        if (message.icon !== "")
            writer.tag(5, runtime_1.WireType.LengthDelimited).string(message.icon);
        /* bool assumed_state = 6; */
        if (message.assumedState !== false)
            writer.tag(6, runtime_1.WireType.Varint).bool(message.assumedState);
        /* bool disabled_by_default = 7; */
        if (message.disabledByDefault !== false)
            writer.tag(7, runtime_1.WireType.Varint).bool(message.disabledByDefault);
        /* EntityCategory entity_category = 8; */
        if (message.entityCategory !== 0)
            writer.tag(8, runtime_1.WireType.Varint).int32(message.entityCategory);
        /* string device_class = 9; */
        if (message.deviceClass !== "")
            writer.tag(9, runtime_1.WireType.LengthDelimited).string(message.deviceClass);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ListEntitiesSwitchResponse
 */
exports.ListEntitiesSwitchResponse = new ListEntitiesSwitchResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SwitchStateResponse$Type extends runtime_5.MessageType {
    constructor() {
        super("SwitchStateResponse", [
            { no: 1, name: "key", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ },
            { no: 2, name: "state", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ], { id: 26, source: "SOURCE_SERVER", ifdef: "USE_SWITCH", no_delay: true });
    }
    create(value) {
        const message = { key: 0, state: false };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* fixed32 key */ 1:
                    message.key = reader.fixed32();
                    break;
                case /* bool state */ 2:
                    message.state = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* fixed32 key = 1; */
        if (message.key !== 0)
            writer.tag(1, runtime_1.WireType.Bit32).fixed32(message.key);
        /* bool state = 2; */
        if (message.state !== false)
            writer.tag(2, runtime_1.WireType.Varint).bool(message.state);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SwitchStateResponse
 */
exports.SwitchStateResponse = new SwitchStateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SwitchCommandRequest$Type extends runtime_5.MessageType {
    constructor() {
        super("SwitchCommandRequest", [
            { no: 1, name: "key", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ },
            { no: 2, name: "state", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ], { id: 33, source: "SOURCE_CLIENT", ifdef: "USE_SWITCH", no_delay: true });
    }
    create(value) {
        const message = { key: 0, state: false };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* fixed32 key */ 1:
                    message.key = reader.fixed32();
                    break;
                case /* bool state */ 2:
                    message.state = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* fixed32 key = 1; */
        if (message.key !== 0)
            writer.tag(1, runtime_1.WireType.Bit32).fixed32(message.key);
        /* bool state = 2; */
        if (message.state !== false)
            writer.tag(2, runtime_1.WireType.Varint).bool(message.state);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SwitchCommandRequest
 */
exports.SwitchCommandRequest = new SwitchCommandRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListEntitiesTextSensorResponse$Type extends runtime_5.MessageType {
    constructor() {
        super("ListEntitiesTextSensorResponse", [
            { no: 1, name: "object_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "key", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ },
            { no: 3, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "unique_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "icon", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "disabled_by_default", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "entity_category", kind: "enum", T: () => ["EntityCategory", EntityCategory, "ENTITY_CATEGORY_"] }
        ], { id: 18, source: "SOURCE_SERVER", ifdef: "USE_TEXT_SENSOR" });
    }
    create(value) {
        const message = { objectId: "", key: 0, name: "", uniqueId: "", icon: "", disabledByDefault: false, entityCategory: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string object_id */ 1:
                    message.objectId = reader.string();
                    break;
                case /* fixed32 key */ 2:
                    message.key = reader.fixed32();
                    break;
                case /* string name */ 3:
                    message.name = reader.string();
                    break;
                case /* string unique_id */ 4:
                    message.uniqueId = reader.string();
                    break;
                case /* string icon */ 5:
                    message.icon = reader.string();
                    break;
                case /* bool disabled_by_default */ 6:
                    message.disabledByDefault = reader.bool();
                    break;
                case /* EntityCategory entity_category */ 7:
                    message.entityCategory = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string object_id = 1; */
        if (message.objectId !== "")
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.objectId);
        /* fixed32 key = 2; */
        if (message.key !== 0)
            writer.tag(2, runtime_1.WireType.Bit32).fixed32(message.key);
        /* string name = 3; */
        if (message.name !== "")
            writer.tag(3, runtime_1.WireType.LengthDelimited).string(message.name);
        /* string unique_id = 4; */
        if (message.uniqueId !== "")
            writer.tag(4, runtime_1.WireType.LengthDelimited).string(message.uniqueId);
        /* string icon = 5; */
        if (message.icon !== "")
            writer.tag(5, runtime_1.WireType.LengthDelimited).string(message.icon);
        /* bool disabled_by_default = 6; */
        if (message.disabledByDefault !== false)
            writer.tag(6, runtime_1.WireType.Varint).bool(message.disabledByDefault);
        /* EntityCategory entity_category = 7; */
        if (message.entityCategory !== 0)
            writer.tag(7, runtime_1.WireType.Varint).int32(message.entityCategory);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ListEntitiesTextSensorResponse
 */
exports.ListEntitiesTextSensorResponse = new ListEntitiesTextSensorResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TextSensorStateResponse$Type extends runtime_5.MessageType {
    constructor() {
        super("TextSensorStateResponse", [
            { no: 1, name: "key", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ },
            { no: 2, name: "state", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "missing_state", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ], { id: 27, source: "SOURCE_SERVER", ifdef: "USE_TEXT_SENSOR", no_delay: true });
    }
    create(value) {
        const message = { key: 0, state: "", missingState: false };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* fixed32 key */ 1:
                    message.key = reader.fixed32();
                    break;
                case /* string state */ 2:
                    message.state = reader.string();
                    break;
                case /* bool missing_state */ 3:
                    message.missingState = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* fixed32 key = 1; */
        if (message.key !== 0)
            writer.tag(1, runtime_1.WireType.Bit32).fixed32(message.key);
        /* string state = 2; */
        if (message.state !== "")
            writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.state);
        /* bool missing_state = 3; */
        if (message.missingState !== false)
            writer.tag(3, runtime_1.WireType.Varint).bool(message.missingState);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TextSensorStateResponse
 */
exports.TextSensorStateResponse = new TextSensorStateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeLogsRequest$Type extends runtime_5.MessageType {
    constructor() {
        super("SubscribeLogsRequest", [
            { no: 1, name: "level", kind: "enum", T: () => ["LogLevel", LogLevel, "LOG_LEVEL_"] },
            { no: 2, name: "dump_config", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ], { id: 28, source: "SOURCE_CLIENT" });
    }
    create(value) {
        const message = { level: 0, dumpConfig: false };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* LogLevel level */ 1:
                    message.level = reader.int32();
                    break;
                case /* bool dump_config */ 2:
                    message.dumpConfig = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* LogLevel level = 1; */
        if (message.level !== 0)
            writer.tag(1, runtime_1.WireType.Varint).int32(message.level);
        /* bool dump_config = 2; */
        if (message.dumpConfig !== false)
            writer.tag(2, runtime_1.WireType.Varint).bool(message.dumpConfig);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SubscribeLogsRequest
 */
exports.SubscribeLogsRequest = new SubscribeLogsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeLogsResponse$Type extends runtime_5.MessageType {
    constructor() {
        super("SubscribeLogsResponse", [
            { no: 1, name: "level", kind: "enum", T: () => ["LogLevel", LogLevel, "LOG_LEVEL_"] },
            { no: 3, name: "message", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 4, name: "send_failed", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ], { id: 29, source: "SOURCE_SERVER", log: false, no_delay: false });
    }
    create(value) {
        const message = { level: 0, message: new Uint8Array(0), sendFailed: false };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* LogLevel level */ 1:
                    message.level = reader.int32();
                    break;
                case /* bytes message */ 3:
                    message.message = reader.bytes();
                    break;
                case /* bool send_failed */ 4:
                    message.sendFailed = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* LogLevel level = 1; */
        if (message.level !== 0)
            writer.tag(1, runtime_1.WireType.Varint).int32(message.level);
        /* bytes message = 3; */
        if (message.message.length)
            writer.tag(3, runtime_1.WireType.LengthDelimited).bytes(message.message);
        /* bool send_failed = 4; */
        if (message.sendFailed !== false)
            writer.tag(4, runtime_1.WireType.Varint).bool(message.sendFailed);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SubscribeLogsResponse
 */
exports.SubscribeLogsResponse = new SubscribeLogsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeHomeassistantServicesRequest$Type extends runtime_5.MessageType {
    constructor() {
        super("SubscribeHomeassistantServicesRequest", [], { id: 34, source: "SOURCE_CLIENT" });
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        return target ?? this.create();
    }
    internalBinaryWrite(message, writer, options) {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SubscribeHomeassistantServicesRequest
 */
exports.SubscribeHomeassistantServicesRequest = new SubscribeHomeassistantServicesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HomeassistantServiceMap$Type extends runtime_5.MessageType {
    constructor() {
        super("HomeassistantServiceMap", [
            { no: 1, name: "key", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "value", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = { key: "", value: "" };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string key */ 1:
                    message.key = reader.string();
                    break;
                case /* string value */ 2:
                    message.value = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string key = 1; */
        if (message.key !== "")
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.key);
        /* string value = 2; */
        if (message.value !== "")
            writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message HomeassistantServiceMap
 */
exports.HomeassistantServiceMap = new HomeassistantServiceMap$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HomeassistantServiceResponse$Type extends runtime_5.MessageType {
    constructor() {
        super("HomeassistantServiceResponse", [
            { no: 1, name: "service", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "data", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => exports.HomeassistantServiceMap },
            { no: 3, name: "data_template", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => exports.HomeassistantServiceMap },
            { no: 4, name: "variables", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => exports.HomeassistantServiceMap },
            { no: 5, name: "is_event", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ], { id: 35, source: "SOURCE_SERVER", no_delay: true });
    }
    create(value) {
        const message = { service: "", data: [], dataTemplate: [], variables: [], isEvent: false };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string service */ 1:
                    message.service = reader.string();
                    break;
                case /* repeated HomeassistantServiceMap data */ 2:
                    message.data.push(exports.HomeassistantServiceMap.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated HomeassistantServiceMap data_template */ 3:
                    message.dataTemplate.push(exports.HomeassistantServiceMap.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated HomeassistantServiceMap variables */ 4:
                    message.variables.push(exports.HomeassistantServiceMap.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* bool is_event */ 5:
                    message.isEvent = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string service = 1; */
        if (message.service !== "")
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.service);
        /* repeated HomeassistantServiceMap data = 2; */
        for (let i = 0; i < message.data.length; i++)
            exports.HomeassistantServiceMap.internalBinaryWrite(message.data[i], writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated HomeassistantServiceMap data_template = 3; */
        for (let i = 0; i < message.dataTemplate.length; i++)
            exports.HomeassistantServiceMap.internalBinaryWrite(message.dataTemplate[i], writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated HomeassistantServiceMap variables = 4; */
        for (let i = 0; i < message.variables.length; i++)
            exports.HomeassistantServiceMap.internalBinaryWrite(message.variables[i], writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* bool is_event = 5; */
        if (message.isEvent !== false)
            writer.tag(5, runtime_1.WireType.Varint).bool(message.isEvent);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message HomeassistantServiceResponse
 */
exports.HomeassistantServiceResponse = new HomeassistantServiceResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeHomeAssistantStatesRequest$Type extends runtime_5.MessageType {
    constructor() {
        super("SubscribeHomeAssistantStatesRequest", [], { id: 38, source: "SOURCE_CLIENT" });
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        return target ?? this.create();
    }
    internalBinaryWrite(message, writer, options) {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SubscribeHomeAssistantStatesRequest
 */
exports.SubscribeHomeAssistantStatesRequest = new SubscribeHomeAssistantStatesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeHomeAssistantStateResponse$Type extends runtime_5.MessageType {
    constructor() {
        super("SubscribeHomeAssistantStateResponse", [
            { no: 1, name: "entity_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "attribute", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { id: 39, source: "SOURCE_SERVER" });
    }
    create(value) {
        const message = { entityId: "", attribute: "" };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string entity_id */ 1:
                    message.entityId = reader.string();
                    break;
                case /* string attribute */ 2:
                    message.attribute = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string entity_id = 1; */
        if (message.entityId !== "")
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.entityId);
        /* string attribute = 2; */
        if (message.attribute !== "")
            writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.attribute);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SubscribeHomeAssistantStateResponse
 */
exports.SubscribeHomeAssistantStateResponse = new SubscribeHomeAssistantStateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HomeAssistantStateResponse$Type extends runtime_5.MessageType {
    constructor() {
        super("HomeAssistantStateResponse", [
            { no: 1, name: "entity_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "state", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "attribute", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { id: 40, source: "SOURCE_CLIENT", no_delay: true });
    }
    create(value) {
        const message = { entityId: "", state: "", attribute: "" };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string entity_id */ 1:
                    message.entityId = reader.string();
                    break;
                case /* string state */ 2:
                    message.state = reader.string();
                    break;
                case /* string attribute */ 3:
                    message.attribute = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string entity_id = 1; */
        if (message.entityId !== "")
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.entityId);
        /* string state = 2; */
        if (message.state !== "")
            writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.state);
        /* string attribute = 3; */
        if (message.attribute !== "")
            writer.tag(3, runtime_1.WireType.LengthDelimited).string(message.attribute);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message HomeAssistantStateResponse
 */
exports.HomeAssistantStateResponse = new HomeAssistantStateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetTimeRequest$Type extends runtime_5.MessageType {
    constructor() {
        super("GetTimeRequest", [], { id: 36, source: "SOURCE_BOTH" });
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        return target ?? this.create();
    }
    internalBinaryWrite(message, writer, options) {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetTimeRequest
 */
exports.GetTimeRequest = new GetTimeRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetTimeResponse$Type extends runtime_5.MessageType {
    constructor() {
        super("GetTimeResponse", [
            { no: 1, name: "epoch_seconds", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ }
        ], { id: 37, source: "SOURCE_BOTH", no_delay: true });
    }
    create(value) {
        const message = { epochSeconds: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* fixed32 epoch_seconds */ 1:
                    message.epochSeconds = reader.fixed32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* fixed32 epoch_seconds = 1; */
        if (message.epochSeconds !== 0)
            writer.tag(1, runtime_1.WireType.Bit32).fixed32(message.epochSeconds);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetTimeResponse
 */
exports.GetTimeResponse = new GetTimeResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListEntitiesServicesArgument$Type extends runtime_5.MessageType {
    constructor() {
        super("ListEntitiesServicesArgument", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "type", kind: "enum", T: () => ["ServiceArgType", ServiceArgType, "SERVICE_ARG_TYPE_"] }
        ]);
    }
    create(value) {
        const message = { name: "", type: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* ServiceArgType type */ 2:
                    message.type = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.name);
        /* ServiceArgType type = 2; */
        if (message.type !== 0)
            writer.tag(2, runtime_1.WireType.Varint).int32(message.type);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ListEntitiesServicesArgument
 */
exports.ListEntitiesServicesArgument = new ListEntitiesServicesArgument$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListEntitiesServicesResponse$Type extends runtime_5.MessageType {
    constructor() {
        super("ListEntitiesServicesResponse", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "key", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ },
            { no: 3, name: "args", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => exports.ListEntitiesServicesArgument }
        ], { id: 41, source: "SOURCE_SERVER" });
    }
    create(value) {
        const message = { name: "", key: 0, args: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* fixed32 key */ 2:
                    message.key = reader.fixed32();
                    break;
                case /* repeated ListEntitiesServicesArgument args */ 3:
                    message.args.push(exports.ListEntitiesServicesArgument.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.name);
        /* fixed32 key = 2; */
        if (message.key !== 0)
            writer.tag(2, runtime_1.WireType.Bit32).fixed32(message.key);
        /* repeated ListEntitiesServicesArgument args = 3; */
        for (let i = 0; i < message.args.length; i++)
            exports.ListEntitiesServicesArgument.internalBinaryWrite(message.args[i], writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ListEntitiesServicesResponse
 */
exports.ListEntitiesServicesResponse = new ListEntitiesServicesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExecuteServiceArgument$Type extends runtime_5.MessageType {
    constructor() {
        super("ExecuteServiceArgument", [
            { no: 1, name: "bool_", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "legacy_int", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "float_", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "string_", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "int_", kind: "scalar", T: 17 /*ScalarType.SINT32*/ },
            { no: 6, name: "bool_array", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "int_array", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 17 /*ScalarType.SINT32*/ },
            { no: 8, name: "float_array", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 2 /*ScalarType.FLOAT*/ },
            { no: 9, name: "string_array", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = { bool: false, legacyInt: 0, float: 0, string: "", int: 0, boolArray: [], intArray: [], floatArray: [], stringArray: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool bool_ */ 1:
                    message.bool = reader.bool();
                    break;
                case /* int32 legacy_int */ 2:
                    message.legacyInt = reader.int32();
                    break;
                case /* float float_ */ 3:
                    message.float = reader.float();
                    break;
                case /* string string_ */ 4:
                    message.string = reader.string();
                    break;
                case /* sint32 int_ */ 5:
                    message.int = reader.sint32();
                    break;
                case /* repeated bool bool_array = 6 [packed = false];*/ 6:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.boolArray.push(reader.bool());
                    else
                        message.boolArray.push(reader.bool());
                    break;
                case /* repeated sint32 int_array = 7 [packed = false];*/ 7:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.intArray.push(reader.sint32());
                    else
                        message.intArray.push(reader.sint32());
                    break;
                case /* repeated float float_array = 8 [packed = false];*/ 8:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.floatArray.push(reader.float());
                    else
                        message.floatArray.push(reader.float());
                    break;
                case /* repeated string string_array */ 9:
                    message.stringArray.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* bool bool_ = 1; */
        if (message.bool !== false)
            writer.tag(1, runtime_1.WireType.Varint).bool(message.bool);
        /* int32 legacy_int = 2; */
        if (message.legacyInt !== 0)
            writer.tag(2, runtime_1.WireType.Varint).int32(message.legacyInt);
        /* float float_ = 3; */
        if (message.float !== 0)
            writer.tag(3, runtime_1.WireType.Bit32).float(message.float);
        /* string string_ = 4; */
        if (message.string !== "")
            writer.tag(4, runtime_1.WireType.LengthDelimited).string(message.string);
        /* sint32 int_ = 5; */
        if (message.int !== 0)
            writer.tag(5, runtime_1.WireType.Varint).sint32(message.int);
        /* repeated bool bool_array = 6 [packed = false]; */
        for (let i = 0; i < message.boolArray.length; i++)
            writer.tag(6, runtime_1.WireType.Varint).bool(message.boolArray[i]);
        /* repeated sint32 int_array = 7 [packed = false]; */
        for (let i = 0; i < message.intArray.length; i++)
            writer.tag(7, runtime_1.WireType.Varint).sint32(message.intArray[i]);
        /* repeated float float_array = 8 [packed = false]; */
        for (let i = 0; i < message.floatArray.length; i++)
            writer.tag(8, runtime_1.WireType.Bit32).float(message.floatArray[i]);
        /* repeated string string_array = 9; */
        for (let i = 0; i < message.stringArray.length; i++)
            writer.tag(9, runtime_1.WireType.LengthDelimited).string(message.stringArray[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ExecuteServiceArgument
 */
exports.ExecuteServiceArgument = new ExecuteServiceArgument$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExecuteServiceRequest$Type extends runtime_5.MessageType {
    constructor() {
        super("ExecuteServiceRequest", [
            { no: 1, name: "key", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ },
            { no: 2, name: "args", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => exports.ExecuteServiceArgument }
        ], { id: 42, source: "SOURCE_CLIENT", no_delay: true });
    }
    create(value) {
        const message = { key: 0, args: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* fixed32 key */ 1:
                    message.key = reader.fixed32();
                    break;
                case /* repeated ExecuteServiceArgument args */ 2:
                    message.args.push(exports.ExecuteServiceArgument.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* fixed32 key = 1; */
        if (message.key !== 0)
            writer.tag(1, runtime_1.WireType.Bit32).fixed32(message.key);
        /* repeated ExecuteServiceArgument args = 2; */
        for (let i = 0; i < message.args.length; i++)
            exports.ExecuteServiceArgument.internalBinaryWrite(message.args[i], writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ExecuteServiceRequest
 */
exports.ExecuteServiceRequest = new ExecuteServiceRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListEntitiesCameraResponse$Type extends runtime_5.MessageType {
    constructor() {
        super("ListEntitiesCameraResponse", [
            { no: 1, name: "object_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "key", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ },
            { no: 3, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "unique_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "disabled_by_default", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "icon", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "entity_category", kind: "enum", T: () => ["EntityCategory", EntityCategory, "ENTITY_CATEGORY_"] }
        ], { id: 43, source: "SOURCE_SERVER", ifdef: "USE_ESP32_CAMERA" });
    }
    create(value) {
        const message = { objectId: "", key: 0, name: "", uniqueId: "", disabledByDefault: false, icon: "", entityCategory: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string object_id */ 1:
                    message.objectId = reader.string();
                    break;
                case /* fixed32 key */ 2:
                    message.key = reader.fixed32();
                    break;
                case /* string name */ 3:
                    message.name = reader.string();
                    break;
                case /* string unique_id */ 4:
                    message.uniqueId = reader.string();
                    break;
                case /* bool disabled_by_default */ 5:
                    message.disabledByDefault = reader.bool();
                    break;
                case /* string icon */ 6:
                    message.icon = reader.string();
                    break;
                case /* EntityCategory entity_category */ 7:
                    message.entityCategory = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string object_id = 1; */
        if (message.objectId !== "")
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.objectId);
        /* fixed32 key = 2; */
        if (message.key !== 0)
            writer.tag(2, runtime_1.WireType.Bit32).fixed32(message.key);
        /* string name = 3; */
        if (message.name !== "")
            writer.tag(3, runtime_1.WireType.LengthDelimited).string(message.name);
        /* string unique_id = 4; */
        if (message.uniqueId !== "")
            writer.tag(4, runtime_1.WireType.LengthDelimited).string(message.uniqueId);
        /* bool disabled_by_default = 5; */
        if (message.disabledByDefault !== false)
            writer.tag(5, runtime_1.WireType.Varint).bool(message.disabledByDefault);
        /* string icon = 6; */
        if (message.icon !== "")
            writer.tag(6, runtime_1.WireType.LengthDelimited).string(message.icon);
        /* EntityCategory entity_category = 7; */
        if (message.entityCategory !== 0)
            writer.tag(7, runtime_1.WireType.Varint).int32(message.entityCategory);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ListEntitiesCameraResponse
 */
exports.ListEntitiesCameraResponse = new ListEntitiesCameraResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CameraImageResponse$Type extends runtime_5.MessageType {
    constructor() {
        super("CameraImageResponse", [
            { no: 1, name: "key", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ },
            { no: 2, name: "data", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "done", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ], { id: 44, source: "SOURCE_SERVER", ifdef: "USE_ESP32_CAMERA" });
    }
    create(value) {
        const message = { key: 0, data: new Uint8Array(0), done: false };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* fixed32 key */ 1:
                    message.key = reader.fixed32();
                    break;
                case /* bytes data */ 2:
                    message.data = reader.bytes();
                    break;
                case /* bool done */ 3:
                    message.done = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* fixed32 key = 1; */
        if (message.key !== 0)
            writer.tag(1, runtime_1.WireType.Bit32).fixed32(message.key);
        /* bytes data = 2; */
        if (message.data.length)
            writer.tag(2, runtime_1.WireType.LengthDelimited).bytes(message.data);
        /* bool done = 3; */
        if (message.done !== false)
            writer.tag(3, runtime_1.WireType.Varint).bool(message.done);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CameraImageResponse
 */
exports.CameraImageResponse = new CameraImageResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CameraImageRequest$Type extends runtime_5.MessageType {
    constructor() {
        super("CameraImageRequest", [
            { no: 1, name: "single", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "stream", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ], { id: 45, source: "SOURCE_CLIENT", ifdef: "USE_ESP32_CAMERA", no_delay: true });
    }
    create(value) {
        const message = { single: false, stream: false };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool single */ 1:
                    message.single = reader.bool();
                    break;
                case /* bool stream */ 2:
                    message.stream = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* bool single = 1; */
        if (message.single !== false)
            writer.tag(1, runtime_1.WireType.Varint).bool(message.single);
        /* bool stream = 2; */
        if (message.stream !== false)
            writer.tag(2, runtime_1.WireType.Varint).bool(message.stream);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CameraImageRequest
 */
exports.CameraImageRequest = new CameraImageRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListEntitiesClimateResponse$Type extends runtime_5.MessageType {
    constructor() {
        super("ListEntitiesClimateResponse", [
            { no: 1, name: "object_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "key", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ },
            { no: 3, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "unique_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "supports_current_temperature", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "supports_two_point_target_temperature", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "supported_modes", kind: "enum", repeat: 1 /*RepeatType.PACKED*/, T: () => ["ClimateMode", ClimateMode, "CLIMATE_MODE_"] },
            { no: 8, name: "visual_min_temperature", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 9, name: "visual_max_temperature", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 10, name: "visual_target_temperature_step", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 11, name: "legacy_supports_away", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 12, name: "supports_action", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 13, name: "supported_fan_modes", kind: "enum", repeat: 1 /*RepeatType.PACKED*/, T: () => ["ClimateFanMode", ClimateFanMode] },
            { no: 14, name: "supported_swing_modes", kind: "enum", repeat: 1 /*RepeatType.PACKED*/, T: () => ["ClimateSwingMode", ClimateSwingMode] },
            { no: 15, name: "supported_custom_fan_modes", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 16, name: "supported_presets", kind: "enum", repeat: 1 /*RepeatType.PACKED*/, T: () => ["ClimatePreset", ClimatePreset, "CLIMATE_PRESET_"] },
            { no: 17, name: "supported_custom_presets", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 18, name: "disabled_by_default", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 19, name: "icon", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 20, name: "entity_category", kind: "enum", T: () => ["EntityCategory", EntityCategory, "ENTITY_CATEGORY_"] },
            { no: 21, name: "visual_current_temperature_step", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ], { id: 46, source: "SOURCE_SERVER", ifdef: "USE_CLIMATE" });
    }
    create(value) {
        const message = { objectId: "", key: 0, name: "", uniqueId: "", supportsCurrentTemperature: false, supportsTwoPointTargetTemperature: false, supportedModes: [], visualMinTemperature: 0, visualMaxTemperature: 0, visualTargetTemperatureStep: 0, legacySupportsAway: false, supportsAction: false, supportedFanModes: [], supportedSwingModes: [], supportedCustomFanModes: [], supportedPresets: [], supportedCustomPresets: [], disabledByDefault: false, icon: "", entityCategory: 0, visualCurrentTemperatureStep: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string object_id */ 1:
                    message.objectId = reader.string();
                    break;
                case /* fixed32 key */ 2:
                    message.key = reader.fixed32();
                    break;
                case /* string name */ 3:
                    message.name = reader.string();
                    break;
                case /* string unique_id */ 4:
                    message.uniqueId = reader.string();
                    break;
                case /* bool supports_current_temperature */ 5:
                    message.supportsCurrentTemperature = reader.bool();
                    break;
                case /* bool supports_two_point_target_temperature */ 6:
                    message.supportsTwoPointTargetTemperature = reader.bool();
                    break;
                case /* repeated ClimateMode supported_modes */ 7:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.supportedModes.push(reader.int32());
                    else
                        message.supportedModes.push(reader.int32());
                    break;
                case /* float visual_min_temperature */ 8:
                    message.visualMinTemperature = reader.float();
                    break;
                case /* float visual_max_temperature */ 9:
                    message.visualMaxTemperature = reader.float();
                    break;
                case /* float visual_target_temperature_step */ 10:
                    message.visualTargetTemperatureStep = reader.float();
                    break;
                case /* bool legacy_supports_away */ 11:
                    message.legacySupportsAway = reader.bool();
                    break;
                case /* bool supports_action */ 12:
                    message.supportsAction = reader.bool();
                    break;
                case /* repeated ClimateFanMode supported_fan_modes */ 13:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.supportedFanModes.push(reader.int32());
                    else
                        message.supportedFanModes.push(reader.int32());
                    break;
                case /* repeated ClimateSwingMode supported_swing_modes */ 14:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.supportedSwingModes.push(reader.int32());
                    else
                        message.supportedSwingModes.push(reader.int32());
                    break;
                case /* repeated string supported_custom_fan_modes */ 15:
                    message.supportedCustomFanModes.push(reader.string());
                    break;
                case /* repeated ClimatePreset supported_presets */ 16:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.supportedPresets.push(reader.int32());
                    else
                        message.supportedPresets.push(reader.int32());
                    break;
                case /* repeated string supported_custom_presets */ 17:
                    message.supportedCustomPresets.push(reader.string());
                    break;
                case /* bool disabled_by_default */ 18:
                    message.disabledByDefault = reader.bool();
                    break;
                case /* string icon */ 19:
                    message.icon = reader.string();
                    break;
                case /* EntityCategory entity_category */ 20:
                    message.entityCategory = reader.int32();
                    break;
                case /* float visual_current_temperature_step */ 21:
                    message.visualCurrentTemperatureStep = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string object_id = 1; */
        if (message.objectId !== "")
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.objectId);
        /* fixed32 key = 2; */
        if (message.key !== 0)
            writer.tag(2, runtime_1.WireType.Bit32).fixed32(message.key);
        /* string name = 3; */
        if (message.name !== "")
            writer.tag(3, runtime_1.WireType.LengthDelimited).string(message.name);
        /* string unique_id = 4; */
        if (message.uniqueId !== "")
            writer.tag(4, runtime_1.WireType.LengthDelimited).string(message.uniqueId);
        /* bool supports_current_temperature = 5; */
        if (message.supportsCurrentTemperature !== false)
            writer.tag(5, runtime_1.WireType.Varint).bool(message.supportsCurrentTemperature);
        /* bool supports_two_point_target_temperature = 6; */
        if (message.supportsTwoPointTargetTemperature !== false)
            writer.tag(6, runtime_1.WireType.Varint).bool(message.supportsTwoPointTargetTemperature);
        /* repeated ClimateMode supported_modes = 7; */
        if (message.supportedModes.length) {
            writer.tag(7, runtime_1.WireType.LengthDelimited).fork();
            for (let i = 0; i < message.supportedModes.length; i++)
                writer.int32(message.supportedModes[i]);
            writer.join();
        }
        /* float visual_min_temperature = 8; */
        if (message.visualMinTemperature !== 0)
            writer.tag(8, runtime_1.WireType.Bit32).float(message.visualMinTemperature);
        /* float visual_max_temperature = 9; */
        if (message.visualMaxTemperature !== 0)
            writer.tag(9, runtime_1.WireType.Bit32).float(message.visualMaxTemperature);
        /* float visual_target_temperature_step = 10; */
        if (message.visualTargetTemperatureStep !== 0)
            writer.tag(10, runtime_1.WireType.Bit32).float(message.visualTargetTemperatureStep);
        /* bool legacy_supports_away = 11; */
        if (message.legacySupportsAway !== false)
            writer.tag(11, runtime_1.WireType.Varint).bool(message.legacySupportsAway);
        /* bool supports_action = 12; */
        if (message.supportsAction !== false)
            writer.tag(12, runtime_1.WireType.Varint).bool(message.supportsAction);
        /* repeated ClimateFanMode supported_fan_modes = 13; */
        if (message.supportedFanModes.length) {
            writer.tag(13, runtime_1.WireType.LengthDelimited).fork();
            for (let i = 0; i < message.supportedFanModes.length; i++)
                writer.int32(message.supportedFanModes[i]);
            writer.join();
        }
        /* repeated ClimateSwingMode supported_swing_modes = 14; */
        if (message.supportedSwingModes.length) {
            writer.tag(14, runtime_1.WireType.LengthDelimited).fork();
            for (let i = 0; i < message.supportedSwingModes.length; i++)
                writer.int32(message.supportedSwingModes[i]);
            writer.join();
        }
        /* repeated string supported_custom_fan_modes = 15; */
        for (let i = 0; i < message.supportedCustomFanModes.length; i++)
            writer.tag(15, runtime_1.WireType.LengthDelimited).string(message.supportedCustomFanModes[i]);
        /* repeated ClimatePreset supported_presets = 16; */
        if (message.supportedPresets.length) {
            writer.tag(16, runtime_1.WireType.LengthDelimited).fork();
            for (let i = 0; i < message.supportedPresets.length; i++)
                writer.int32(message.supportedPresets[i]);
            writer.join();
        }
        /* repeated string supported_custom_presets = 17; */
        for (let i = 0; i < message.supportedCustomPresets.length; i++)
            writer.tag(17, runtime_1.WireType.LengthDelimited).string(message.supportedCustomPresets[i]);
        /* bool disabled_by_default = 18; */
        if (message.disabledByDefault !== false)
            writer.tag(18, runtime_1.WireType.Varint).bool(message.disabledByDefault);
        /* string icon = 19; */
        if (message.icon !== "")
            writer.tag(19, runtime_1.WireType.LengthDelimited).string(message.icon);
        /* EntityCategory entity_category = 20; */
        if (message.entityCategory !== 0)
            writer.tag(20, runtime_1.WireType.Varint).int32(message.entityCategory);
        /* float visual_current_temperature_step = 21; */
        if (message.visualCurrentTemperatureStep !== 0)
            writer.tag(21, runtime_1.WireType.Bit32).float(message.visualCurrentTemperatureStep);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ListEntitiesClimateResponse
 */
exports.ListEntitiesClimateResponse = new ListEntitiesClimateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ClimateStateResponse$Type extends runtime_5.MessageType {
    constructor() {
        super("ClimateStateResponse", [
            { no: 1, name: "key", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ },
            { no: 2, name: "mode", kind: "enum", T: () => ["ClimateMode", ClimateMode, "CLIMATE_MODE_"] },
            { no: 3, name: "current_temperature", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "target_temperature", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 5, name: "target_temperature_low", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 6, name: "target_temperature_high", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 7, name: "legacy_away", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "action", kind: "enum", T: () => ["ClimateAction", ClimateAction, "CLIMATE_ACTION_"] },
            { no: 9, name: "fan_mode", kind: "enum", T: () => ["ClimateFanMode", ClimateFanMode] },
            { no: 10, name: "swing_mode", kind: "enum", T: () => ["ClimateSwingMode", ClimateSwingMode] },
            { no: 11, name: "custom_fan_mode", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "preset", kind: "enum", T: () => ["ClimatePreset", ClimatePreset, "CLIMATE_PRESET_"] },
            { no: 13, name: "custom_preset", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { id: 47, source: "SOURCE_SERVER", ifdef: "USE_CLIMATE", no_delay: true });
    }
    create(value) {
        const message = { key: 0, mode: 0, currentTemperature: 0, targetTemperature: 0, targetTemperatureLow: 0, targetTemperatureHigh: 0, legacyAway: false, action: 0, fanMode: 0, swingMode: 0, customFanMode: "", preset: 0, customPreset: "" };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* fixed32 key */ 1:
                    message.key = reader.fixed32();
                    break;
                case /* ClimateMode mode */ 2:
                    message.mode = reader.int32();
                    break;
                case /* float current_temperature */ 3:
                    message.currentTemperature = reader.float();
                    break;
                case /* float target_temperature */ 4:
                    message.targetTemperature = reader.float();
                    break;
                case /* float target_temperature_low */ 5:
                    message.targetTemperatureLow = reader.float();
                    break;
                case /* float target_temperature_high */ 6:
                    message.targetTemperatureHigh = reader.float();
                    break;
                case /* bool legacy_away */ 7:
                    message.legacyAway = reader.bool();
                    break;
                case /* ClimateAction action */ 8:
                    message.action = reader.int32();
                    break;
                case /* ClimateFanMode fan_mode */ 9:
                    message.fanMode = reader.int32();
                    break;
                case /* ClimateSwingMode swing_mode */ 10:
                    message.swingMode = reader.int32();
                    break;
                case /* string custom_fan_mode */ 11:
                    message.customFanMode = reader.string();
                    break;
                case /* ClimatePreset preset */ 12:
                    message.preset = reader.int32();
                    break;
                case /* string custom_preset */ 13:
                    message.customPreset = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* fixed32 key = 1; */
        if (message.key !== 0)
            writer.tag(1, runtime_1.WireType.Bit32).fixed32(message.key);
        /* ClimateMode mode = 2; */
        if (message.mode !== 0)
            writer.tag(2, runtime_1.WireType.Varint).int32(message.mode);
        /* float current_temperature = 3; */
        if (message.currentTemperature !== 0)
            writer.tag(3, runtime_1.WireType.Bit32).float(message.currentTemperature);
        /* float target_temperature = 4; */
        if (message.targetTemperature !== 0)
            writer.tag(4, runtime_1.WireType.Bit32).float(message.targetTemperature);
        /* float target_temperature_low = 5; */
        if (message.targetTemperatureLow !== 0)
            writer.tag(5, runtime_1.WireType.Bit32).float(message.targetTemperatureLow);
        /* float target_temperature_high = 6; */
        if (message.targetTemperatureHigh !== 0)
            writer.tag(6, runtime_1.WireType.Bit32).float(message.targetTemperatureHigh);
        /* bool legacy_away = 7; */
        if (message.legacyAway !== false)
            writer.tag(7, runtime_1.WireType.Varint).bool(message.legacyAway);
        /* ClimateAction action = 8; */
        if (message.action !== 0)
            writer.tag(8, runtime_1.WireType.Varint).int32(message.action);
        /* ClimateFanMode fan_mode = 9; */
        if (message.fanMode !== 0)
            writer.tag(9, runtime_1.WireType.Varint).int32(message.fanMode);
        /* ClimateSwingMode swing_mode = 10; */
        if (message.swingMode !== 0)
            writer.tag(10, runtime_1.WireType.Varint).int32(message.swingMode);
        /* string custom_fan_mode = 11; */
        if (message.customFanMode !== "")
            writer.tag(11, runtime_1.WireType.LengthDelimited).string(message.customFanMode);
        /* ClimatePreset preset = 12; */
        if (message.preset !== 0)
            writer.tag(12, runtime_1.WireType.Varint).int32(message.preset);
        /* string custom_preset = 13; */
        if (message.customPreset !== "")
            writer.tag(13, runtime_1.WireType.LengthDelimited).string(message.customPreset);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ClimateStateResponse
 */
exports.ClimateStateResponse = new ClimateStateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ClimateCommandRequest$Type extends runtime_5.MessageType {
    constructor() {
        super("ClimateCommandRequest", [
            { no: 1, name: "key", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ },
            { no: 2, name: "has_mode", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "mode", kind: "enum", T: () => ["ClimateMode", ClimateMode, "CLIMATE_MODE_"] },
            { no: 4, name: "has_target_temperature", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "target_temperature", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 6, name: "has_target_temperature_low", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "target_temperature_low", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 8, name: "has_target_temperature_high", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "target_temperature_high", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 10, name: "has_legacy_away", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 11, name: "legacy_away", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 12, name: "has_fan_mode", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 13, name: "fan_mode", kind: "enum", T: () => ["ClimateFanMode", ClimateFanMode] },
            { no: 14, name: "has_swing_mode", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 15, name: "swing_mode", kind: "enum", T: () => ["ClimateSwingMode", ClimateSwingMode] },
            { no: 16, name: "has_custom_fan_mode", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 17, name: "custom_fan_mode", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 18, name: "has_preset", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 19, name: "preset", kind: "enum", T: () => ["ClimatePreset", ClimatePreset, "CLIMATE_PRESET_"] },
            { no: 20, name: "has_custom_preset", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 21, name: "custom_preset", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { id: 48, source: "SOURCE_CLIENT", ifdef: "USE_CLIMATE", no_delay: true });
    }
    create(value) {
        const message = { key: 0, hasMode: false, mode: 0, hasTargetTemperature: false, targetTemperature: 0, hasTargetTemperatureLow: false, targetTemperatureLow: 0, hasTargetTemperatureHigh: false, targetTemperatureHigh: 0, hasLegacyAway: false, legacyAway: false, hasFanMode: false, fanMode: 0, hasSwingMode: false, swingMode: 0, hasCustomFanMode: false, customFanMode: "", hasPreset: false, preset: 0, hasCustomPreset: false, customPreset: "" };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* fixed32 key */ 1:
                    message.key = reader.fixed32();
                    break;
                case /* bool has_mode */ 2:
                    message.hasMode = reader.bool();
                    break;
                case /* ClimateMode mode */ 3:
                    message.mode = reader.int32();
                    break;
                case /* bool has_target_temperature */ 4:
                    message.hasTargetTemperature = reader.bool();
                    break;
                case /* float target_temperature */ 5:
                    message.targetTemperature = reader.float();
                    break;
                case /* bool has_target_temperature_low */ 6:
                    message.hasTargetTemperatureLow = reader.bool();
                    break;
                case /* float target_temperature_low */ 7:
                    message.targetTemperatureLow = reader.float();
                    break;
                case /* bool has_target_temperature_high */ 8:
                    message.hasTargetTemperatureHigh = reader.bool();
                    break;
                case /* float target_temperature_high */ 9:
                    message.targetTemperatureHigh = reader.float();
                    break;
                case /* bool has_legacy_away */ 10:
                    message.hasLegacyAway = reader.bool();
                    break;
                case /* bool legacy_away */ 11:
                    message.legacyAway = reader.bool();
                    break;
                case /* bool has_fan_mode */ 12:
                    message.hasFanMode = reader.bool();
                    break;
                case /* ClimateFanMode fan_mode */ 13:
                    message.fanMode = reader.int32();
                    break;
                case /* bool has_swing_mode */ 14:
                    message.hasSwingMode = reader.bool();
                    break;
                case /* ClimateSwingMode swing_mode */ 15:
                    message.swingMode = reader.int32();
                    break;
                case /* bool has_custom_fan_mode */ 16:
                    message.hasCustomFanMode = reader.bool();
                    break;
                case /* string custom_fan_mode */ 17:
                    message.customFanMode = reader.string();
                    break;
                case /* bool has_preset */ 18:
                    message.hasPreset = reader.bool();
                    break;
                case /* ClimatePreset preset */ 19:
                    message.preset = reader.int32();
                    break;
                case /* bool has_custom_preset */ 20:
                    message.hasCustomPreset = reader.bool();
                    break;
                case /* string custom_preset */ 21:
                    message.customPreset = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* fixed32 key = 1; */
        if (message.key !== 0)
            writer.tag(1, runtime_1.WireType.Bit32).fixed32(message.key);
        /* bool has_mode = 2; */
        if (message.hasMode !== false)
            writer.tag(2, runtime_1.WireType.Varint).bool(message.hasMode);
        /* ClimateMode mode = 3; */
        if (message.mode !== 0)
            writer.tag(3, runtime_1.WireType.Varint).int32(message.mode);
        /* bool has_target_temperature = 4; */
        if (message.hasTargetTemperature !== false)
            writer.tag(4, runtime_1.WireType.Varint).bool(message.hasTargetTemperature);
        /* float target_temperature = 5; */
        if (message.targetTemperature !== 0)
            writer.tag(5, runtime_1.WireType.Bit32).float(message.targetTemperature);
        /* bool has_target_temperature_low = 6; */
        if (message.hasTargetTemperatureLow !== false)
            writer.tag(6, runtime_1.WireType.Varint).bool(message.hasTargetTemperatureLow);
        /* float target_temperature_low = 7; */
        if (message.targetTemperatureLow !== 0)
            writer.tag(7, runtime_1.WireType.Bit32).float(message.targetTemperatureLow);
        /* bool has_target_temperature_high = 8; */
        if (message.hasTargetTemperatureHigh !== false)
            writer.tag(8, runtime_1.WireType.Varint).bool(message.hasTargetTemperatureHigh);
        /* float target_temperature_high = 9; */
        if (message.targetTemperatureHigh !== 0)
            writer.tag(9, runtime_1.WireType.Bit32).float(message.targetTemperatureHigh);
        /* bool has_legacy_away = 10; */
        if (message.hasLegacyAway !== false)
            writer.tag(10, runtime_1.WireType.Varint).bool(message.hasLegacyAway);
        /* bool legacy_away = 11; */
        if (message.legacyAway !== false)
            writer.tag(11, runtime_1.WireType.Varint).bool(message.legacyAway);
        /* bool has_fan_mode = 12; */
        if (message.hasFanMode !== false)
            writer.tag(12, runtime_1.WireType.Varint).bool(message.hasFanMode);
        /* ClimateFanMode fan_mode = 13; */
        if (message.fanMode !== 0)
            writer.tag(13, runtime_1.WireType.Varint).int32(message.fanMode);
        /* bool has_swing_mode = 14; */
        if (message.hasSwingMode !== false)
            writer.tag(14, runtime_1.WireType.Varint).bool(message.hasSwingMode);
        /* ClimateSwingMode swing_mode = 15; */
        if (message.swingMode !== 0)
            writer.tag(15, runtime_1.WireType.Varint).int32(message.swingMode);
        /* bool has_custom_fan_mode = 16; */
        if (message.hasCustomFanMode !== false)
            writer.tag(16, runtime_1.WireType.Varint).bool(message.hasCustomFanMode);
        /* string custom_fan_mode = 17; */
        if (message.customFanMode !== "")
            writer.tag(17, runtime_1.WireType.LengthDelimited).string(message.customFanMode);
        /* bool has_preset = 18; */
        if (message.hasPreset !== false)
            writer.tag(18, runtime_1.WireType.Varint).bool(message.hasPreset);
        /* ClimatePreset preset = 19; */
        if (message.preset !== 0)
            writer.tag(19, runtime_1.WireType.Varint).int32(message.preset);
        /* bool has_custom_preset = 20; */
        if (message.hasCustomPreset !== false)
            writer.tag(20, runtime_1.WireType.Varint).bool(message.hasCustomPreset);
        /* string custom_preset = 21; */
        if (message.customPreset !== "")
            writer.tag(21, runtime_1.WireType.LengthDelimited).string(message.customPreset);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ClimateCommandRequest
 */
exports.ClimateCommandRequest = new ClimateCommandRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListEntitiesNumberResponse$Type extends runtime_5.MessageType {
    constructor() {
        super("ListEntitiesNumberResponse", [
            { no: 1, name: "object_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "key", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ },
            { no: 3, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "unique_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "icon", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "min_value", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 7, name: "max_value", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 8, name: "step", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 9, name: "disabled_by_default", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 10, name: "entity_category", kind: "enum", T: () => ["EntityCategory", EntityCategory, "ENTITY_CATEGORY_"] },
            { no: 11, name: "unit_of_measurement", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "mode", kind: "enum", T: () => ["NumberMode", NumberMode, "NUMBER_MODE_"] },
            { no: 13, name: "device_class", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { id: 49, source: "SOURCE_SERVER", ifdef: "USE_NUMBER" });
    }
    create(value) {
        const message = { objectId: "", key: 0, name: "", uniqueId: "", icon: "", minValue: 0, maxValue: 0, step: 0, disabledByDefault: false, entityCategory: 0, unitOfMeasurement: "", mode: 0, deviceClass: "" };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string object_id */ 1:
                    message.objectId = reader.string();
                    break;
                case /* fixed32 key */ 2:
                    message.key = reader.fixed32();
                    break;
                case /* string name */ 3:
                    message.name = reader.string();
                    break;
                case /* string unique_id */ 4:
                    message.uniqueId = reader.string();
                    break;
                case /* string icon */ 5:
                    message.icon = reader.string();
                    break;
                case /* float min_value */ 6:
                    message.minValue = reader.float();
                    break;
                case /* float max_value */ 7:
                    message.maxValue = reader.float();
                    break;
                case /* float step */ 8:
                    message.step = reader.float();
                    break;
                case /* bool disabled_by_default */ 9:
                    message.disabledByDefault = reader.bool();
                    break;
                case /* EntityCategory entity_category */ 10:
                    message.entityCategory = reader.int32();
                    break;
                case /* string unit_of_measurement */ 11:
                    message.unitOfMeasurement = reader.string();
                    break;
                case /* NumberMode mode */ 12:
                    message.mode = reader.int32();
                    break;
                case /* string device_class */ 13:
                    message.deviceClass = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string object_id = 1; */
        if (message.objectId !== "")
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.objectId);
        /* fixed32 key = 2; */
        if (message.key !== 0)
            writer.tag(2, runtime_1.WireType.Bit32).fixed32(message.key);
        /* string name = 3; */
        if (message.name !== "")
            writer.tag(3, runtime_1.WireType.LengthDelimited).string(message.name);
        /* string unique_id = 4; */
        if (message.uniqueId !== "")
            writer.tag(4, runtime_1.WireType.LengthDelimited).string(message.uniqueId);
        /* string icon = 5; */
        if (message.icon !== "")
            writer.tag(5, runtime_1.WireType.LengthDelimited).string(message.icon);
        /* float min_value = 6; */
        if (message.minValue !== 0)
            writer.tag(6, runtime_1.WireType.Bit32).float(message.minValue);
        /* float max_value = 7; */
        if (message.maxValue !== 0)
            writer.tag(7, runtime_1.WireType.Bit32).float(message.maxValue);
        /* float step = 8; */
        if (message.step !== 0)
            writer.tag(8, runtime_1.WireType.Bit32).float(message.step);
        /* bool disabled_by_default = 9; */
        if (message.disabledByDefault !== false)
            writer.tag(9, runtime_1.WireType.Varint).bool(message.disabledByDefault);
        /* EntityCategory entity_category = 10; */
        if (message.entityCategory !== 0)
            writer.tag(10, runtime_1.WireType.Varint).int32(message.entityCategory);
        /* string unit_of_measurement = 11; */
        if (message.unitOfMeasurement !== "")
            writer.tag(11, runtime_1.WireType.LengthDelimited).string(message.unitOfMeasurement);
        /* NumberMode mode = 12; */
        if (message.mode !== 0)
            writer.tag(12, runtime_1.WireType.Varint).int32(message.mode);
        /* string device_class = 13; */
        if (message.deviceClass !== "")
            writer.tag(13, runtime_1.WireType.LengthDelimited).string(message.deviceClass);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ListEntitiesNumberResponse
 */
exports.ListEntitiesNumberResponse = new ListEntitiesNumberResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class NumberStateResponse$Type extends runtime_5.MessageType {
    constructor() {
        super("NumberStateResponse", [
            { no: 1, name: "key", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ },
            { no: 2, name: "state", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "missing_state", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ], { id: 50, source: "SOURCE_SERVER", ifdef: "USE_NUMBER", no_delay: true });
    }
    create(value) {
        const message = { key: 0, state: 0, missingState: false };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* fixed32 key */ 1:
                    message.key = reader.fixed32();
                    break;
                case /* float state */ 2:
                    message.state = reader.float();
                    break;
                case /* bool missing_state */ 3:
                    message.missingState = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* fixed32 key = 1; */
        if (message.key !== 0)
            writer.tag(1, runtime_1.WireType.Bit32).fixed32(message.key);
        /* float state = 2; */
        if (message.state !== 0)
            writer.tag(2, runtime_1.WireType.Bit32).float(message.state);
        /* bool missing_state = 3; */
        if (message.missingState !== false)
            writer.tag(3, runtime_1.WireType.Varint).bool(message.missingState);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message NumberStateResponse
 */
exports.NumberStateResponse = new NumberStateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class NumberCommandRequest$Type extends runtime_5.MessageType {
    constructor() {
        super("NumberCommandRequest", [
            { no: 1, name: "key", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ },
            { no: 2, name: "state", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ], { id: 51, source: "SOURCE_CLIENT", ifdef: "USE_NUMBER", no_delay: true });
    }
    create(value) {
        const message = { key: 0, state: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* fixed32 key */ 1:
                    message.key = reader.fixed32();
                    break;
                case /* float state */ 2:
                    message.state = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* fixed32 key = 1; */
        if (message.key !== 0)
            writer.tag(1, runtime_1.WireType.Bit32).fixed32(message.key);
        /* float state = 2; */
        if (message.state !== 0)
            writer.tag(2, runtime_1.WireType.Bit32).float(message.state);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message NumberCommandRequest
 */
exports.NumberCommandRequest = new NumberCommandRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListEntitiesSelectResponse$Type extends runtime_5.MessageType {
    constructor() {
        super("ListEntitiesSelectResponse", [
            { no: 1, name: "object_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "key", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ },
            { no: 3, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "unique_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "icon", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "options", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "disabled_by_default", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "entity_category", kind: "enum", T: () => ["EntityCategory", EntityCategory, "ENTITY_CATEGORY_"] }
        ], { id: 52, source: "SOURCE_SERVER", ifdef: "USE_SELECT" });
    }
    create(value) {
        const message = { objectId: "", key: 0, name: "", uniqueId: "", icon: "", options: [], disabledByDefault: false, entityCategory: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string object_id */ 1:
                    message.objectId = reader.string();
                    break;
                case /* fixed32 key */ 2:
                    message.key = reader.fixed32();
                    break;
                case /* string name */ 3:
                    message.name = reader.string();
                    break;
                case /* string unique_id */ 4:
                    message.uniqueId = reader.string();
                    break;
                case /* string icon */ 5:
                    message.icon = reader.string();
                    break;
                case /* repeated string options */ 6:
                    message.options.push(reader.string());
                    break;
                case /* bool disabled_by_default */ 7:
                    message.disabledByDefault = reader.bool();
                    break;
                case /* EntityCategory entity_category */ 8:
                    message.entityCategory = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string object_id = 1; */
        if (message.objectId !== "")
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.objectId);
        /* fixed32 key = 2; */
        if (message.key !== 0)
            writer.tag(2, runtime_1.WireType.Bit32).fixed32(message.key);
        /* string name = 3; */
        if (message.name !== "")
            writer.tag(3, runtime_1.WireType.LengthDelimited).string(message.name);
        /* string unique_id = 4; */
        if (message.uniqueId !== "")
            writer.tag(4, runtime_1.WireType.LengthDelimited).string(message.uniqueId);
        /* string icon = 5; */
        if (message.icon !== "")
            writer.tag(5, runtime_1.WireType.LengthDelimited).string(message.icon);
        /* repeated string options = 6; */
        for (let i = 0; i < message.options.length; i++)
            writer.tag(6, runtime_1.WireType.LengthDelimited).string(message.options[i]);
        /* bool disabled_by_default = 7; */
        if (message.disabledByDefault !== false)
            writer.tag(7, runtime_1.WireType.Varint).bool(message.disabledByDefault);
        /* EntityCategory entity_category = 8; */
        if (message.entityCategory !== 0)
            writer.tag(8, runtime_1.WireType.Varint).int32(message.entityCategory);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ListEntitiesSelectResponse
 */
exports.ListEntitiesSelectResponse = new ListEntitiesSelectResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SelectStateResponse$Type extends runtime_5.MessageType {
    constructor() {
        super("SelectStateResponse", [
            { no: 1, name: "key", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ },
            { no: 2, name: "state", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "missing_state", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ], { id: 53, source: "SOURCE_SERVER", ifdef: "USE_SELECT", no_delay: true });
    }
    create(value) {
        const message = { key: 0, state: "", missingState: false };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* fixed32 key */ 1:
                    message.key = reader.fixed32();
                    break;
                case /* string state */ 2:
                    message.state = reader.string();
                    break;
                case /* bool missing_state */ 3:
                    message.missingState = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* fixed32 key = 1; */
        if (message.key !== 0)
            writer.tag(1, runtime_1.WireType.Bit32).fixed32(message.key);
        /* string state = 2; */
        if (message.state !== "")
            writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.state);
        /* bool missing_state = 3; */
        if (message.missingState !== false)
            writer.tag(3, runtime_1.WireType.Varint).bool(message.missingState);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SelectStateResponse
 */
exports.SelectStateResponse = new SelectStateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SelectCommandRequest$Type extends runtime_5.MessageType {
    constructor() {
        super("SelectCommandRequest", [
            { no: 1, name: "key", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ },
            { no: 2, name: "state", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { id: 54, source: "SOURCE_CLIENT", ifdef: "USE_SELECT", no_delay: true });
    }
    create(value) {
        const message = { key: 0, state: "" };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* fixed32 key */ 1:
                    message.key = reader.fixed32();
                    break;
                case /* string state */ 2:
                    message.state = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* fixed32 key = 1; */
        if (message.key !== 0)
            writer.tag(1, runtime_1.WireType.Bit32).fixed32(message.key);
        /* string state = 2; */
        if (message.state !== "")
            writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.state);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SelectCommandRequest
 */
exports.SelectCommandRequest = new SelectCommandRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListEntitiesSirenResponse$Type extends runtime_5.MessageType {
    constructor() {
        super("ListEntitiesSirenResponse", [
            { no: 1, name: "object_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "key", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ },
            { no: 3, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "unique_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "icon", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "disabled_by_default", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "tones", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "supports_duration", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "supports_volume", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 10, name: "entity_category", kind: "enum", T: () => ["EntityCategory", EntityCategory, "ENTITY_CATEGORY_"] }
        ], { id: 55, source: "SOURCE_SERVER", ifdef: "USE_SIREN" });
    }
    create(value) {
        const message = { objectId: "", key: 0, name: "", uniqueId: "", icon: "", disabledByDefault: false, tones: [], supportsDuration: false, supportsVolume: false, entityCategory: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string object_id */ 1:
                    message.objectId = reader.string();
                    break;
                case /* fixed32 key */ 2:
                    message.key = reader.fixed32();
                    break;
                case /* string name */ 3:
                    message.name = reader.string();
                    break;
                case /* string unique_id */ 4:
                    message.uniqueId = reader.string();
                    break;
                case /* string icon */ 5:
                    message.icon = reader.string();
                    break;
                case /* bool disabled_by_default */ 6:
                    message.disabledByDefault = reader.bool();
                    break;
                case /* repeated string tones */ 7:
                    message.tones.push(reader.string());
                    break;
                case /* bool supports_duration */ 8:
                    message.supportsDuration = reader.bool();
                    break;
                case /* bool supports_volume */ 9:
                    message.supportsVolume = reader.bool();
                    break;
                case /* EntityCategory entity_category */ 10:
                    message.entityCategory = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string object_id = 1; */
        if (message.objectId !== "")
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.objectId);
        /* fixed32 key = 2; */
        if (message.key !== 0)
            writer.tag(2, runtime_1.WireType.Bit32).fixed32(message.key);
        /* string name = 3; */
        if (message.name !== "")
            writer.tag(3, runtime_1.WireType.LengthDelimited).string(message.name);
        /* string unique_id = 4; */
        if (message.uniqueId !== "")
            writer.tag(4, runtime_1.WireType.LengthDelimited).string(message.uniqueId);
        /* string icon = 5; */
        if (message.icon !== "")
            writer.tag(5, runtime_1.WireType.LengthDelimited).string(message.icon);
        /* bool disabled_by_default = 6; */
        if (message.disabledByDefault !== false)
            writer.tag(6, runtime_1.WireType.Varint).bool(message.disabledByDefault);
        /* repeated string tones = 7; */
        for (let i = 0; i < message.tones.length; i++)
            writer.tag(7, runtime_1.WireType.LengthDelimited).string(message.tones[i]);
        /* bool supports_duration = 8; */
        if (message.supportsDuration !== false)
            writer.tag(8, runtime_1.WireType.Varint).bool(message.supportsDuration);
        /* bool supports_volume = 9; */
        if (message.supportsVolume !== false)
            writer.tag(9, runtime_1.WireType.Varint).bool(message.supportsVolume);
        /* EntityCategory entity_category = 10; */
        if (message.entityCategory !== 0)
            writer.tag(10, runtime_1.WireType.Varint).int32(message.entityCategory);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ListEntitiesSirenResponse
 */
exports.ListEntitiesSirenResponse = new ListEntitiesSirenResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SirenStateResponse$Type extends runtime_5.MessageType {
    constructor() {
        super("SirenStateResponse", [
            { no: 1, name: "key", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ },
            { no: 2, name: "state", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ], { id: 56, source: "SOURCE_SERVER", ifdef: "USE_SIREN", no_delay: true });
    }
    create(value) {
        const message = { key: 0, state: false };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* fixed32 key */ 1:
                    message.key = reader.fixed32();
                    break;
                case /* bool state */ 2:
                    message.state = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* fixed32 key = 1; */
        if (message.key !== 0)
            writer.tag(1, runtime_1.WireType.Bit32).fixed32(message.key);
        /* bool state = 2; */
        if (message.state !== false)
            writer.tag(2, runtime_1.WireType.Varint).bool(message.state);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SirenStateResponse
 */
exports.SirenStateResponse = new SirenStateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SirenCommandRequest$Type extends runtime_5.MessageType {
    constructor() {
        super("SirenCommandRequest", [
            { no: 1, name: "key", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ },
            { no: 2, name: "has_state", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "state", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "has_tone", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "tone", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "has_duration", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "duration", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "has_volume", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "volume", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ], { id: 57, source: "SOURCE_CLIENT", ifdef: "USE_SIREN", no_delay: true });
    }
    create(value) {
        const message = { key: 0, hasState: false, state: false, hasTone: false, tone: "", hasDuration: false, duration: 0, hasVolume: false, volume: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* fixed32 key */ 1:
                    message.key = reader.fixed32();
                    break;
                case /* bool has_state */ 2:
                    message.hasState = reader.bool();
                    break;
                case /* bool state */ 3:
                    message.state = reader.bool();
                    break;
                case /* bool has_tone */ 4:
                    message.hasTone = reader.bool();
                    break;
                case /* string tone */ 5:
                    message.tone = reader.string();
                    break;
                case /* bool has_duration */ 6:
                    message.hasDuration = reader.bool();
                    break;
                case /* uint32 duration */ 7:
                    message.duration = reader.uint32();
                    break;
                case /* bool has_volume */ 8:
                    message.hasVolume = reader.bool();
                    break;
                case /* float volume */ 9:
                    message.volume = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* fixed32 key = 1; */
        if (message.key !== 0)
            writer.tag(1, runtime_1.WireType.Bit32).fixed32(message.key);
        /* bool has_state = 2; */
        if (message.hasState !== false)
            writer.tag(2, runtime_1.WireType.Varint).bool(message.hasState);
        /* bool state = 3; */
        if (message.state !== false)
            writer.tag(3, runtime_1.WireType.Varint).bool(message.state);
        /* bool has_tone = 4; */
        if (message.hasTone !== false)
            writer.tag(4, runtime_1.WireType.Varint).bool(message.hasTone);
        /* string tone = 5; */
        if (message.tone !== "")
            writer.tag(5, runtime_1.WireType.LengthDelimited).string(message.tone);
        /* bool has_duration = 6; */
        if (message.hasDuration !== false)
            writer.tag(6, runtime_1.WireType.Varint).bool(message.hasDuration);
        /* uint32 duration = 7; */
        if (message.duration !== 0)
            writer.tag(7, runtime_1.WireType.Varint).uint32(message.duration);
        /* bool has_volume = 8; */
        if (message.hasVolume !== false)
            writer.tag(8, runtime_1.WireType.Varint).bool(message.hasVolume);
        /* float volume = 9; */
        if (message.volume !== 0)
            writer.tag(9, runtime_1.WireType.Bit32).float(message.volume);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SirenCommandRequest
 */
exports.SirenCommandRequest = new SirenCommandRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListEntitiesLockResponse$Type extends runtime_5.MessageType {
    constructor() {
        super("ListEntitiesLockResponse", [
            { no: 1, name: "object_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "key", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ },
            { no: 3, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "unique_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "icon", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "disabled_by_default", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "entity_category", kind: "enum", T: () => ["EntityCategory", EntityCategory, "ENTITY_CATEGORY_"] },
            { no: 8, name: "assumed_state", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "supports_open", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 10, name: "requires_code", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 11, name: "code_format", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { id: 58, source: "SOURCE_SERVER", ifdef: "USE_LOCK" });
    }
    create(value) {
        const message = { objectId: "", key: 0, name: "", uniqueId: "", icon: "", disabledByDefault: false, entityCategory: 0, assumedState: false, supportsOpen: false, requiresCode: false, codeFormat: "" };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string object_id */ 1:
                    message.objectId = reader.string();
                    break;
                case /* fixed32 key */ 2:
                    message.key = reader.fixed32();
                    break;
                case /* string name */ 3:
                    message.name = reader.string();
                    break;
                case /* string unique_id */ 4:
                    message.uniqueId = reader.string();
                    break;
                case /* string icon */ 5:
                    message.icon = reader.string();
                    break;
                case /* bool disabled_by_default */ 6:
                    message.disabledByDefault = reader.bool();
                    break;
                case /* EntityCategory entity_category */ 7:
                    message.entityCategory = reader.int32();
                    break;
                case /* bool assumed_state */ 8:
                    message.assumedState = reader.bool();
                    break;
                case /* bool supports_open */ 9:
                    message.supportsOpen = reader.bool();
                    break;
                case /* bool requires_code */ 10:
                    message.requiresCode = reader.bool();
                    break;
                case /* string code_format */ 11:
                    message.codeFormat = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string object_id = 1; */
        if (message.objectId !== "")
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.objectId);
        /* fixed32 key = 2; */
        if (message.key !== 0)
            writer.tag(2, runtime_1.WireType.Bit32).fixed32(message.key);
        /* string name = 3; */
        if (message.name !== "")
            writer.tag(3, runtime_1.WireType.LengthDelimited).string(message.name);
        /* string unique_id = 4; */
        if (message.uniqueId !== "")
            writer.tag(4, runtime_1.WireType.LengthDelimited).string(message.uniqueId);
        /* string icon = 5; */
        if (message.icon !== "")
            writer.tag(5, runtime_1.WireType.LengthDelimited).string(message.icon);
        /* bool disabled_by_default = 6; */
        if (message.disabledByDefault !== false)
            writer.tag(6, runtime_1.WireType.Varint).bool(message.disabledByDefault);
        /* EntityCategory entity_category = 7; */
        if (message.entityCategory !== 0)
            writer.tag(7, runtime_1.WireType.Varint).int32(message.entityCategory);
        /* bool assumed_state = 8; */
        if (message.assumedState !== false)
            writer.tag(8, runtime_1.WireType.Varint).bool(message.assumedState);
        /* bool supports_open = 9; */
        if (message.supportsOpen !== false)
            writer.tag(9, runtime_1.WireType.Varint).bool(message.supportsOpen);
        /* bool requires_code = 10; */
        if (message.requiresCode !== false)
            writer.tag(10, runtime_1.WireType.Varint).bool(message.requiresCode);
        /* string code_format = 11; */
        if (message.codeFormat !== "")
            writer.tag(11, runtime_1.WireType.LengthDelimited).string(message.codeFormat);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ListEntitiesLockResponse
 */
exports.ListEntitiesLockResponse = new ListEntitiesLockResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LockStateResponse$Type extends runtime_5.MessageType {
    constructor() {
        super("LockStateResponse", [
            { no: 1, name: "key", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ },
            { no: 2, name: "state", kind: "enum", T: () => ["LockState", LockState, "LOCK_STATE_"] }
        ], { id: 59, source: "SOURCE_SERVER", ifdef: "USE_LOCK", no_delay: true });
    }
    create(value) {
        const message = { key: 0, state: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* fixed32 key */ 1:
                    message.key = reader.fixed32();
                    break;
                case /* LockState state */ 2:
                    message.state = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* fixed32 key = 1; */
        if (message.key !== 0)
            writer.tag(1, runtime_1.WireType.Bit32).fixed32(message.key);
        /* LockState state = 2; */
        if (message.state !== 0)
            writer.tag(2, runtime_1.WireType.Varint).int32(message.state);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message LockStateResponse
 */
exports.LockStateResponse = new LockStateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LockCommandRequest$Type extends runtime_5.MessageType {
    constructor() {
        super("LockCommandRequest", [
            { no: 1, name: "key", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ },
            { no: 2, name: "command", kind: "enum", T: () => ["LockCommand", LockCommand] },
            { no: 3, name: "has_code", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "code", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { id: 60, source: "SOURCE_CLIENT", ifdef: "USE_LOCK", no_delay: true });
    }
    create(value) {
        const message = { key: 0, command: 0, hasCode: false, code: "" };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* fixed32 key */ 1:
                    message.key = reader.fixed32();
                    break;
                case /* LockCommand command */ 2:
                    message.command = reader.int32();
                    break;
                case /* bool has_code */ 3:
                    message.hasCode = reader.bool();
                    break;
                case /* string code */ 4:
                    message.code = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* fixed32 key = 1; */
        if (message.key !== 0)
            writer.tag(1, runtime_1.WireType.Bit32).fixed32(message.key);
        /* LockCommand command = 2; */
        if (message.command !== 0)
            writer.tag(2, runtime_1.WireType.Varint).int32(message.command);
        /* bool has_code = 3; */
        if (message.hasCode !== false)
            writer.tag(3, runtime_1.WireType.Varint).bool(message.hasCode);
        /* string code = 4; */
        if (message.code !== "")
            writer.tag(4, runtime_1.WireType.LengthDelimited).string(message.code);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message LockCommandRequest
 */
exports.LockCommandRequest = new LockCommandRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListEntitiesButtonResponse$Type extends runtime_5.MessageType {
    constructor() {
        super("ListEntitiesButtonResponse", [
            { no: 1, name: "object_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "key", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ },
            { no: 3, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "unique_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "icon", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "disabled_by_default", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "entity_category", kind: "enum", T: () => ["EntityCategory", EntityCategory, "ENTITY_CATEGORY_"] },
            { no: 8, name: "device_class", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { id: 61, source: "SOURCE_SERVER", ifdef: "USE_BUTTON" });
    }
    create(value) {
        const message = { objectId: "", key: 0, name: "", uniqueId: "", icon: "", disabledByDefault: false, entityCategory: 0, deviceClass: "" };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string object_id */ 1:
                    message.objectId = reader.string();
                    break;
                case /* fixed32 key */ 2:
                    message.key = reader.fixed32();
                    break;
                case /* string name */ 3:
                    message.name = reader.string();
                    break;
                case /* string unique_id */ 4:
                    message.uniqueId = reader.string();
                    break;
                case /* string icon */ 5:
                    message.icon = reader.string();
                    break;
                case /* bool disabled_by_default */ 6:
                    message.disabledByDefault = reader.bool();
                    break;
                case /* EntityCategory entity_category */ 7:
                    message.entityCategory = reader.int32();
                    break;
                case /* string device_class */ 8:
                    message.deviceClass = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string object_id = 1; */
        if (message.objectId !== "")
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.objectId);
        /* fixed32 key = 2; */
        if (message.key !== 0)
            writer.tag(2, runtime_1.WireType.Bit32).fixed32(message.key);
        /* string name = 3; */
        if (message.name !== "")
            writer.tag(3, runtime_1.WireType.LengthDelimited).string(message.name);
        /* string unique_id = 4; */
        if (message.uniqueId !== "")
            writer.tag(4, runtime_1.WireType.LengthDelimited).string(message.uniqueId);
        /* string icon = 5; */
        if (message.icon !== "")
            writer.tag(5, runtime_1.WireType.LengthDelimited).string(message.icon);
        /* bool disabled_by_default = 6; */
        if (message.disabledByDefault !== false)
            writer.tag(6, runtime_1.WireType.Varint).bool(message.disabledByDefault);
        /* EntityCategory entity_category = 7; */
        if (message.entityCategory !== 0)
            writer.tag(7, runtime_1.WireType.Varint).int32(message.entityCategory);
        /* string device_class = 8; */
        if (message.deviceClass !== "")
            writer.tag(8, runtime_1.WireType.LengthDelimited).string(message.deviceClass);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ListEntitiesButtonResponse
 */
exports.ListEntitiesButtonResponse = new ListEntitiesButtonResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ButtonCommandRequest$Type extends runtime_5.MessageType {
    constructor() {
        super("ButtonCommandRequest", [
            { no: 1, name: "key", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ }
        ], { id: 62, source: "SOURCE_CLIENT", ifdef: "USE_BUTTON", no_delay: true });
    }
    create(value) {
        const message = { key: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* fixed32 key */ 1:
                    message.key = reader.fixed32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* fixed32 key = 1; */
        if (message.key !== 0)
            writer.tag(1, runtime_1.WireType.Bit32).fixed32(message.key);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ButtonCommandRequest
 */
exports.ButtonCommandRequest = new ButtonCommandRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListEntitiesMediaPlayerResponse$Type extends runtime_5.MessageType {
    constructor() {
        super("ListEntitiesMediaPlayerResponse", [
            { no: 1, name: "object_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "key", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ },
            { no: 3, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "unique_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "icon", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "disabled_by_default", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "entity_category", kind: "enum", T: () => ["EntityCategory", EntityCategory, "ENTITY_CATEGORY_"] },
            { no: 8, name: "supports_pause", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ], { id: 63, source: "SOURCE_SERVER", ifdef: "USE_MEDIA_PLAYER" });
    }
    create(value) {
        const message = { objectId: "", key: 0, name: "", uniqueId: "", icon: "", disabledByDefault: false, entityCategory: 0, supportsPause: false };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string object_id */ 1:
                    message.objectId = reader.string();
                    break;
                case /* fixed32 key */ 2:
                    message.key = reader.fixed32();
                    break;
                case /* string name */ 3:
                    message.name = reader.string();
                    break;
                case /* string unique_id */ 4:
                    message.uniqueId = reader.string();
                    break;
                case /* string icon */ 5:
                    message.icon = reader.string();
                    break;
                case /* bool disabled_by_default */ 6:
                    message.disabledByDefault = reader.bool();
                    break;
                case /* EntityCategory entity_category */ 7:
                    message.entityCategory = reader.int32();
                    break;
                case /* bool supports_pause */ 8:
                    message.supportsPause = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string object_id = 1; */
        if (message.objectId !== "")
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.objectId);
        /* fixed32 key = 2; */
        if (message.key !== 0)
            writer.tag(2, runtime_1.WireType.Bit32).fixed32(message.key);
        /* string name = 3; */
        if (message.name !== "")
            writer.tag(3, runtime_1.WireType.LengthDelimited).string(message.name);
        /* string unique_id = 4; */
        if (message.uniqueId !== "")
            writer.tag(4, runtime_1.WireType.LengthDelimited).string(message.uniqueId);
        /* string icon = 5; */
        if (message.icon !== "")
            writer.tag(5, runtime_1.WireType.LengthDelimited).string(message.icon);
        /* bool disabled_by_default = 6; */
        if (message.disabledByDefault !== false)
            writer.tag(6, runtime_1.WireType.Varint).bool(message.disabledByDefault);
        /* EntityCategory entity_category = 7; */
        if (message.entityCategory !== 0)
            writer.tag(7, runtime_1.WireType.Varint).int32(message.entityCategory);
        /* bool supports_pause = 8; */
        if (message.supportsPause !== false)
            writer.tag(8, runtime_1.WireType.Varint).bool(message.supportsPause);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ListEntitiesMediaPlayerResponse
 */
exports.ListEntitiesMediaPlayerResponse = new ListEntitiesMediaPlayerResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MediaPlayerStateResponse$Type extends runtime_5.MessageType {
    constructor() {
        super("MediaPlayerStateResponse", [
            { no: 1, name: "key", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ },
            { no: 2, name: "state", kind: "enum", T: () => ["MediaPlayerState", MediaPlayerState, "MEDIA_PLAYER_STATE_"] },
            { no: 3, name: "volume", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "muted", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ], { id: 64, source: "SOURCE_SERVER", ifdef: "USE_MEDIA_PLAYER", no_delay: true });
    }
    create(value) {
        const message = { key: 0, state: 0, volume: 0, muted: false };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* fixed32 key */ 1:
                    message.key = reader.fixed32();
                    break;
                case /* MediaPlayerState state */ 2:
                    message.state = reader.int32();
                    break;
                case /* float volume */ 3:
                    message.volume = reader.float();
                    break;
                case /* bool muted */ 4:
                    message.muted = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* fixed32 key = 1; */
        if (message.key !== 0)
            writer.tag(1, runtime_1.WireType.Bit32).fixed32(message.key);
        /* MediaPlayerState state = 2; */
        if (message.state !== 0)
            writer.tag(2, runtime_1.WireType.Varint).int32(message.state);
        /* float volume = 3; */
        if (message.volume !== 0)
            writer.tag(3, runtime_1.WireType.Bit32).float(message.volume);
        /* bool muted = 4; */
        if (message.muted !== false)
            writer.tag(4, runtime_1.WireType.Varint).bool(message.muted);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message MediaPlayerStateResponse
 */
exports.MediaPlayerStateResponse = new MediaPlayerStateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MediaPlayerCommandRequest$Type extends runtime_5.MessageType {
    constructor() {
        super("MediaPlayerCommandRequest", [
            { no: 1, name: "key", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ },
            { no: 2, name: "has_command", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "command", kind: "enum", T: () => ["MediaPlayerCommand", MediaPlayerCommand, "MEDIA_PLAYER_COMMAND_"] },
            { no: 4, name: "has_volume", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "volume", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 6, name: "has_media_url", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "media_url", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { id: 65, source: "SOURCE_CLIENT", ifdef: "USE_MEDIA_PLAYER", no_delay: true });
    }
    create(value) {
        const message = { key: 0, hasCommand: false, command: 0, hasVolume: false, volume: 0, hasMediaUrl: false, mediaUrl: "" };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* fixed32 key */ 1:
                    message.key = reader.fixed32();
                    break;
                case /* bool has_command */ 2:
                    message.hasCommand = reader.bool();
                    break;
                case /* MediaPlayerCommand command */ 3:
                    message.command = reader.int32();
                    break;
                case /* bool has_volume */ 4:
                    message.hasVolume = reader.bool();
                    break;
                case /* float volume */ 5:
                    message.volume = reader.float();
                    break;
                case /* bool has_media_url */ 6:
                    message.hasMediaUrl = reader.bool();
                    break;
                case /* string media_url */ 7:
                    message.mediaUrl = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* fixed32 key = 1; */
        if (message.key !== 0)
            writer.tag(1, runtime_1.WireType.Bit32).fixed32(message.key);
        /* bool has_command = 2; */
        if (message.hasCommand !== false)
            writer.tag(2, runtime_1.WireType.Varint).bool(message.hasCommand);
        /* MediaPlayerCommand command = 3; */
        if (message.command !== 0)
            writer.tag(3, runtime_1.WireType.Varint).int32(message.command);
        /* bool has_volume = 4; */
        if (message.hasVolume !== false)
            writer.tag(4, runtime_1.WireType.Varint).bool(message.hasVolume);
        /* float volume = 5; */
        if (message.volume !== 0)
            writer.tag(5, runtime_1.WireType.Bit32).float(message.volume);
        /* bool has_media_url = 6; */
        if (message.hasMediaUrl !== false)
            writer.tag(6, runtime_1.WireType.Varint).bool(message.hasMediaUrl);
        /* string media_url = 7; */
        if (message.mediaUrl !== "")
            writer.tag(7, runtime_1.WireType.LengthDelimited).string(message.mediaUrl);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message MediaPlayerCommandRequest
 */
exports.MediaPlayerCommandRequest = new MediaPlayerCommandRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeBluetoothLEAdvertisementsRequest$Type extends runtime_5.MessageType {
    constructor() {
        super("SubscribeBluetoothLEAdvertisementsRequest", [
            { no: 1, name: "flags", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ], { id: 66, source: "SOURCE_CLIENT" });
    }
    create(value) {
        const message = { flags: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 flags */ 1:
                    message.flags = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* int32 flags = 1; */
        if (message.flags !== 0)
            writer.tag(1, runtime_1.WireType.Varint).int32(message.flags);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SubscribeBluetoothLEAdvertisementsRequest
 */
exports.SubscribeBluetoothLEAdvertisementsRequest = new SubscribeBluetoothLEAdvertisementsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BluetoothServiceData$Type extends runtime_5.MessageType {
    constructor() {
        super("BluetoothServiceData", [
            { no: 1, name: "uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "legacy_data", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "data", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value) {
        const message = { uuid: "", legacyData: [], data: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string uuid */ 1:
                    message.uuid = reader.string();
                    break;
                case /* repeated uint32 legacy_data = 2 [packed = true];*/ 2:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.legacyData.push(reader.uint32());
                    else
                        message.legacyData.push(reader.uint32());
                    break;
                case /* bytes data */ 3:
                    message.data = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string uuid = 1; */
        if (message.uuid !== "")
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.uuid);
        /* repeated uint32 legacy_data = 2 [packed = true]; */
        if (message.legacyData.length) {
            writer.tag(2, runtime_1.WireType.LengthDelimited).fork();
            for (let i = 0; i < message.legacyData.length; i++)
                writer.uint32(message.legacyData[i]);
            writer.join();
        }
        /* bytes data = 3; */
        if (message.data.length)
            writer.tag(3, runtime_1.WireType.LengthDelimited).bytes(message.data);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message BluetoothServiceData
 */
exports.BluetoothServiceData = new BluetoothServiceData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BluetoothLEAdvertisementResponse$Type extends runtime_5.MessageType {
    constructor() {
        super("BluetoothLEAdvertisementResponse", [
            { no: 1, name: "address", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "name", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "rssi", kind: "scalar", T: 17 /*ScalarType.SINT32*/ },
            { no: 4, name: "service_uuids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "service_data", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => exports.BluetoothServiceData },
            { no: 6, name: "manufacturer_data", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => exports.BluetoothServiceData },
            { no: 7, name: "address_type", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ], { id: 67, source: "SOURCE_SERVER", ifdef: "USE_BLUETOOTH_PROXY", no_delay: true });
    }
    create(value) {
        const message = { address: 0n, name: new Uint8Array(0), rssi: 0, serviceUuids: [], serviceData: [], manufacturerData: [], addressType: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 address */ 1:
                    message.address = reader.uint64().toBigInt();
                    break;
                case /* bytes name */ 2:
                    message.name = reader.bytes();
                    break;
                case /* sint32 rssi */ 3:
                    message.rssi = reader.sint32();
                    break;
                case /* repeated string service_uuids */ 4:
                    message.serviceUuids.push(reader.string());
                    break;
                case /* repeated BluetoothServiceData service_data */ 5:
                    message.serviceData.push(exports.BluetoothServiceData.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated BluetoothServiceData manufacturer_data */ 6:
                    message.manufacturerData.push(exports.BluetoothServiceData.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* uint32 address_type */ 7:
                    message.addressType = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint64 address = 1; */
        if (message.address !== 0n)
            writer.tag(1, runtime_1.WireType.Varint).uint64(message.address);
        /* bytes name = 2; */
        if (message.name.length)
            writer.tag(2, runtime_1.WireType.LengthDelimited).bytes(message.name);
        /* sint32 rssi = 3; */
        if (message.rssi !== 0)
            writer.tag(3, runtime_1.WireType.Varint).sint32(message.rssi);
        /* repeated string service_uuids = 4; */
        for (let i = 0; i < message.serviceUuids.length; i++)
            writer.tag(4, runtime_1.WireType.LengthDelimited).string(message.serviceUuids[i]);
        /* repeated BluetoothServiceData service_data = 5; */
        for (let i = 0; i < message.serviceData.length; i++)
            exports.BluetoothServiceData.internalBinaryWrite(message.serviceData[i], writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated BluetoothServiceData manufacturer_data = 6; */
        for (let i = 0; i < message.manufacturerData.length; i++)
            exports.BluetoothServiceData.internalBinaryWrite(message.manufacturerData[i], writer.tag(6, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* uint32 address_type = 7; */
        if (message.addressType !== 0)
            writer.tag(7, runtime_1.WireType.Varint).uint32(message.addressType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message BluetoothLEAdvertisementResponse
 */
exports.BluetoothLEAdvertisementResponse = new BluetoothLEAdvertisementResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BluetoothLERawAdvertisement$Type extends runtime_5.MessageType {
    constructor() {
        super("BluetoothLERawAdvertisement", [
            { no: 1, name: "address", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "rssi", kind: "scalar", T: 17 /*ScalarType.SINT32*/ },
            { no: 3, name: "address_type", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "data", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value) {
        const message = { address: 0n, rssi: 0, addressType: 0, data: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 address */ 1:
                    message.address = reader.uint64().toBigInt();
                    break;
                case /* sint32 rssi */ 2:
                    message.rssi = reader.sint32();
                    break;
                case /* uint32 address_type */ 3:
                    message.addressType = reader.uint32();
                    break;
                case /* bytes data */ 4:
                    message.data = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint64 address = 1; */
        if (message.address !== 0n)
            writer.tag(1, runtime_1.WireType.Varint).uint64(message.address);
        /* sint32 rssi = 2; */
        if (message.rssi !== 0)
            writer.tag(2, runtime_1.WireType.Varint).sint32(message.rssi);
        /* uint32 address_type = 3; */
        if (message.addressType !== 0)
            writer.tag(3, runtime_1.WireType.Varint).uint32(message.addressType);
        /* bytes data = 4; */
        if (message.data.length)
            writer.tag(4, runtime_1.WireType.LengthDelimited).bytes(message.data);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message BluetoothLERawAdvertisement
 */
exports.BluetoothLERawAdvertisement = new BluetoothLERawAdvertisement$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BluetoothLERawAdvertisementsResponse$Type extends runtime_5.MessageType {
    constructor() {
        super("BluetoothLERawAdvertisementsResponse", [
            { no: 1, name: "advertisements", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => exports.BluetoothLERawAdvertisement }
        ], { id: 93, source: "SOURCE_SERVER", ifdef: "USE_BLUETOOTH_PROXY", no_delay: true });
    }
    create(value) {
        const message = { advertisements: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated BluetoothLERawAdvertisement advertisements */ 1:
                    message.advertisements.push(exports.BluetoothLERawAdvertisement.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated BluetoothLERawAdvertisement advertisements = 1; */
        for (let i = 0; i < message.advertisements.length; i++)
            exports.BluetoothLERawAdvertisement.internalBinaryWrite(message.advertisements[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message BluetoothLERawAdvertisementsResponse
 */
exports.BluetoothLERawAdvertisementsResponse = new BluetoothLERawAdvertisementsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BluetoothDeviceRequest$Type extends runtime_5.MessageType {
    constructor() {
        super("BluetoothDeviceRequest", [
            { no: 1, name: "address", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "request_type", kind: "enum", T: () => ["BluetoothDeviceRequestType", BluetoothDeviceRequestType, "BLUETOOTH_DEVICE_REQUEST_TYPE_"] },
            { no: 3, name: "has_address_type", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "address_type", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ], { id: 68, source: "SOURCE_CLIENT", ifdef: "USE_BLUETOOTH_PROXY" });
    }
    create(value) {
        const message = { address: 0n, requestType: 0, hasAddressType: false, addressType: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 address */ 1:
                    message.address = reader.uint64().toBigInt();
                    break;
                case /* BluetoothDeviceRequestType request_type */ 2:
                    message.requestType = reader.int32();
                    break;
                case /* bool has_address_type */ 3:
                    message.hasAddressType = reader.bool();
                    break;
                case /* uint32 address_type */ 4:
                    message.addressType = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint64 address = 1; */
        if (message.address !== 0n)
            writer.tag(1, runtime_1.WireType.Varint).uint64(message.address);
        /* BluetoothDeviceRequestType request_type = 2; */
        if (message.requestType !== 0)
            writer.tag(2, runtime_1.WireType.Varint).int32(message.requestType);
        /* bool has_address_type = 3; */
        if (message.hasAddressType !== false)
            writer.tag(3, runtime_1.WireType.Varint).bool(message.hasAddressType);
        /* uint32 address_type = 4; */
        if (message.addressType !== 0)
            writer.tag(4, runtime_1.WireType.Varint).uint32(message.addressType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message BluetoothDeviceRequest
 */
exports.BluetoothDeviceRequest = new BluetoothDeviceRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BluetoothDeviceConnectionResponse$Type extends runtime_5.MessageType {
    constructor() {
        super("BluetoothDeviceConnectionResponse", [
            { no: 1, name: "address", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "connected", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "mtu", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "error", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ], { id: 69, source: "SOURCE_SERVER", ifdef: "USE_BLUETOOTH_PROXY" });
    }
    create(value) {
        const message = { address: 0n, connected: false, mtu: 0, error: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 address */ 1:
                    message.address = reader.uint64().toBigInt();
                    break;
                case /* bool connected */ 2:
                    message.connected = reader.bool();
                    break;
                case /* uint32 mtu */ 3:
                    message.mtu = reader.uint32();
                    break;
                case /* int32 error */ 4:
                    message.error = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint64 address = 1; */
        if (message.address !== 0n)
            writer.tag(1, runtime_1.WireType.Varint).uint64(message.address);
        /* bool connected = 2; */
        if (message.connected !== false)
            writer.tag(2, runtime_1.WireType.Varint).bool(message.connected);
        /* uint32 mtu = 3; */
        if (message.mtu !== 0)
            writer.tag(3, runtime_1.WireType.Varint).uint32(message.mtu);
        /* int32 error = 4; */
        if (message.error !== 0)
            writer.tag(4, runtime_1.WireType.Varint).int32(message.error);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message BluetoothDeviceConnectionResponse
 */
exports.BluetoothDeviceConnectionResponse = new BluetoothDeviceConnectionResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BluetoothGATTGetServicesRequest$Type extends runtime_5.MessageType {
    constructor() {
        super("BluetoothGATTGetServicesRequest", [
            { no: 1, name: "address", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ], { id: 70, source: "SOURCE_CLIENT", ifdef: "USE_BLUETOOTH_PROXY" });
    }
    create(value) {
        const message = { address: 0n };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 address */ 1:
                    message.address = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint64 address = 1; */
        if (message.address !== 0n)
            writer.tag(1, runtime_1.WireType.Varint).uint64(message.address);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message BluetoothGATTGetServicesRequest
 */
exports.BluetoothGATTGetServicesRequest = new BluetoothGATTGetServicesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BluetoothGATTDescriptor$Type extends runtime_5.MessageType {
    constructor() {
        super("BluetoothGATTDescriptor", [
            { no: 1, name: "uuid", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "handle", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value) {
        const message = { uuid: [], handle: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated uint64 uuid */ 1:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.uuid.push(reader.uint64().toBigInt());
                    else
                        message.uuid.push(reader.uint64().toBigInt());
                    break;
                case /* uint32 handle */ 2:
                    message.handle = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated uint64 uuid = 1; */
        if (message.uuid.length) {
            writer.tag(1, runtime_1.WireType.LengthDelimited).fork();
            for (let i = 0; i < message.uuid.length; i++)
                writer.uint64(message.uuid[i]);
            writer.join();
        }
        /* uint32 handle = 2; */
        if (message.handle !== 0)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.handle);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message BluetoothGATTDescriptor
 */
exports.BluetoothGATTDescriptor = new BluetoothGATTDescriptor$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BluetoothGATTCharacteristic$Type extends runtime_5.MessageType {
    constructor() {
        super("BluetoothGATTCharacteristic", [
            { no: 1, name: "uuid", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "handle", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "properties", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "descriptors", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => exports.BluetoothGATTDescriptor }
        ]);
    }
    create(value) {
        const message = { uuid: [], handle: 0, properties: 0, descriptors: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated uint64 uuid */ 1:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.uuid.push(reader.uint64().toBigInt());
                    else
                        message.uuid.push(reader.uint64().toBigInt());
                    break;
                case /* uint32 handle */ 2:
                    message.handle = reader.uint32();
                    break;
                case /* uint32 properties */ 3:
                    message.properties = reader.uint32();
                    break;
                case /* repeated BluetoothGATTDescriptor descriptors */ 4:
                    message.descriptors.push(exports.BluetoothGATTDescriptor.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated uint64 uuid = 1; */
        if (message.uuid.length) {
            writer.tag(1, runtime_1.WireType.LengthDelimited).fork();
            for (let i = 0; i < message.uuid.length; i++)
                writer.uint64(message.uuid[i]);
            writer.join();
        }
        /* uint32 handle = 2; */
        if (message.handle !== 0)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.handle);
        /* uint32 properties = 3; */
        if (message.properties !== 0)
            writer.tag(3, runtime_1.WireType.Varint).uint32(message.properties);
        /* repeated BluetoothGATTDescriptor descriptors = 4; */
        for (let i = 0; i < message.descriptors.length; i++)
            exports.BluetoothGATTDescriptor.internalBinaryWrite(message.descriptors[i], writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message BluetoothGATTCharacteristic
 */
exports.BluetoothGATTCharacteristic = new BluetoothGATTCharacteristic$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BluetoothGATTService$Type extends runtime_5.MessageType {
    constructor() {
        super("BluetoothGATTService", [
            { no: 1, name: "uuid", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "handle", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "characteristics", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => exports.BluetoothGATTCharacteristic }
        ]);
    }
    create(value) {
        const message = { uuid: [], handle: 0, characteristics: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated uint64 uuid */ 1:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.uuid.push(reader.uint64().toBigInt());
                    else
                        message.uuid.push(reader.uint64().toBigInt());
                    break;
                case /* uint32 handle */ 2:
                    message.handle = reader.uint32();
                    break;
                case /* repeated BluetoothGATTCharacteristic characteristics */ 3:
                    message.characteristics.push(exports.BluetoothGATTCharacteristic.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated uint64 uuid = 1; */
        if (message.uuid.length) {
            writer.tag(1, runtime_1.WireType.LengthDelimited).fork();
            for (let i = 0; i < message.uuid.length; i++)
                writer.uint64(message.uuid[i]);
            writer.join();
        }
        /* uint32 handle = 2; */
        if (message.handle !== 0)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.handle);
        /* repeated BluetoothGATTCharacteristic characteristics = 3; */
        for (let i = 0; i < message.characteristics.length; i++)
            exports.BluetoothGATTCharacteristic.internalBinaryWrite(message.characteristics[i], writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message BluetoothGATTService
 */
exports.BluetoothGATTService = new BluetoothGATTService$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BluetoothGATTGetServicesResponse$Type extends runtime_5.MessageType {
    constructor() {
        super("BluetoothGATTGetServicesResponse", [
            { no: 1, name: "address", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "services", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => exports.BluetoothGATTService }
        ], { id: 71, source: "SOURCE_SERVER", ifdef: "USE_BLUETOOTH_PROXY" });
    }
    create(value) {
        const message = { address: 0n, services: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 address */ 1:
                    message.address = reader.uint64().toBigInt();
                    break;
                case /* repeated BluetoothGATTService services */ 2:
                    message.services.push(exports.BluetoothGATTService.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint64 address = 1; */
        if (message.address !== 0n)
            writer.tag(1, runtime_1.WireType.Varint).uint64(message.address);
        /* repeated BluetoothGATTService services = 2; */
        for (let i = 0; i < message.services.length; i++)
            exports.BluetoothGATTService.internalBinaryWrite(message.services[i], writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message BluetoothGATTGetServicesResponse
 */
exports.BluetoothGATTGetServicesResponse = new BluetoothGATTGetServicesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BluetoothGATTGetServicesDoneResponse$Type extends runtime_5.MessageType {
    constructor() {
        super("BluetoothGATTGetServicesDoneResponse", [
            { no: 1, name: "address", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ], { id: 72, source: "SOURCE_SERVER", ifdef: "USE_BLUETOOTH_PROXY" });
    }
    create(value) {
        const message = { address: 0n };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 address */ 1:
                    message.address = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint64 address = 1; */
        if (message.address !== 0n)
            writer.tag(1, runtime_1.WireType.Varint).uint64(message.address);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message BluetoothGATTGetServicesDoneResponse
 */
exports.BluetoothGATTGetServicesDoneResponse = new BluetoothGATTGetServicesDoneResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BluetoothGATTReadRequest$Type extends runtime_5.MessageType {
    constructor() {
        super("BluetoothGATTReadRequest", [
            { no: 1, name: "address", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "handle", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ], { id: 73, source: "SOURCE_CLIENT", ifdef: "USE_BLUETOOTH_PROXY" });
    }
    create(value) {
        const message = { address: 0n, handle: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 address */ 1:
                    message.address = reader.uint64().toBigInt();
                    break;
                case /* uint32 handle */ 2:
                    message.handle = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint64 address = 1; */
        if (message.address !== 0n)
            writer.tag(1, runtime_1.WireType.Varint).uint64(message.address);
        /* uint32 handle = 2; */
        if (message.handle !== 0)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.handle);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message BluetoothGATTReadRequest
 */
exports.BluetoothGATTReadRequest = new BluetoothGATTReadRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BluetoothGATTReadResponse$Type extends runtime_5.MessageType {
    constructor() {
        super("BluetoothGATTReadResponse", [
            { no: 1, name: "address", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "handle", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "data", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ], { id: 74, source: "SOURCE_SERVER", ifdef: "USE_BLUETOOTH_PROXY" });
    }
    create(value) {
        const message = { address: 0n, handle: 0, data: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 address */ 1:
                    message.address = reader.uint64().toBigInt();
                    break;
                case /* uint32 handle */ 2:
                    message.handle = reader.uint32();
                    break;
                case /* bytes data */ 3:
                    message.data = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint64 address = 1; */
        if (message.address !== 0n)
            writer.tag(1, runtime_1.WireType.Varint).uint64(message.address);
        /* uint32 handle = 2; */
        if (message.handle !== 0)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.handle);
        /* bytes data = 3; */
        if (message.data.length)
            writer.tag(3, runtime_1.WireType.LengthDelimited).bytes(message.data);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message BluetoothGATTReadResponse
 */
exports.BluetoothGATTReadResponse = new BluetoothGATTReadResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BluetoothGATTWriteRequest$Type extends runtime_5.MessageType {
    constructor() {
        super("BluetoothGATTWriteRequest", [
            { no: 1, name: "address", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "handle", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "response", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "data", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ], { id: 75, source: "SOURCE_CLIENT", ifdef: "USE_BLUETOOTH_PROXY" });
    }
    create(value) {
        const message = { address: 0n, handle: 0, response: false, data: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 address */ 1:
                    message.address = reader.uint64().toBigInt();
                    break;
                case /* uint32 handle */ 2:
                    message.handle = reader.uint32();
                    break;
                case /* bool response */ 3:
                    message.response = reader.bool();
                    break;
                case /* bytes data */ 4:
                    message.data = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint64 address = 1; */
        if (message.address !== 0n)
            writer.tag(1, runtime_1.WireType.Varint).uint64(message.address);
        /* uint32 handle = 2; */
        if (message.handle !== 0)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.handle);
        /* bool response = 3; */
        if (message.response !== false)
            writer.tag(3, runtime_1.WireType.Varint).bool(message.response);
        /* bytes data = 4; */
        if (message.data.length)
            writer.tag(4, runtime_1.WireType.LengthDelimited).bytes(message.data);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message BluetoothGATTWriteRequest
 */
exports.BluetoothGATTWriteRequest = new BluetoothGATTWriteRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BluetoothGATTReadDescriptorRequest$Type extends runtime_5.MessageType {
    constructor() {
        super("BluetoothGATTReadDescriptorRequest", [
            { no: 1, name: "address", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "handle", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ], { id: 76, source: "SOURCE_CLIENT", ifdef: "USE_BLUETOOTH_PROXY" });
    }
    create(value) {
        const message = { address: 0n, handle: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 address */ 1:
                    message.address = reader.uint64().toBigInt();
                    break;
                case /* uint32 handle */ 2:
                    message.handle = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint64 address = 1; */
        if (message.address !== 0n)
            writer.tag(1, runtime_1.WireType.Varint).uint64(message.address);
        /* uint32 handle = 2; */
        if (message.handle !== 0)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.handle);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message BluetoothGATTReadDescriptorRequest
 */
exports.BluetoothGATTReadDescriptorRequest = new BluetoothGATTReadDescriptorRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BluetoothGATTWriteDescriptorRequest$Type extends runtime_5.MessageType {
    constructor() {
        super("BluetoothGATTWriteDescriptorRequest", [
            { no: 1, name: "address", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "handle", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "data", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ], { id: 77, source: "SOURCE_CLIENT", ifdef: "USE_BLUETOOTH_PROXY" });
    }
    create(value) {
        const message = { address: 0n, handle: 0, data: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 address */ 1:
                    message.address = reader.uint64().toBigInt();
                    break;
                case /* uint32 handle */ 2:
                    message.handle = reader.uint32();
                    break;
                case /* bytes data */ 3:
                    message.data = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint64 address = 1; */
        if (message.address !== 0n)
            writer.tag(1, runtime_1.WireType.Varint).uint64(message.address);
        /* uint32 handle = 2; */
        if (message.handle !== 0)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.handle);
        /* bytes data = 3; */
        if (message.data.length)
            writer.tag(3, runtime_1.WireType.LengthDelimited).bytes(message.data);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message BluetoothGATTWriteDescriptorRequest
 */
exports.BluetoothGATTWriteDescriptorRequest = new BluetoothGATTWriteDescriptorRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BluetoothGATTNotifyRequest$Type extends runtime_5.MessageType {
    constructor() {
        super("BluetoothGATTNotifyRequest", [
            { no: 1, name: "address", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "handle", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "enable", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ], { id: 78, source: "SOURCE_CLIENT", ifdef: "USE_BLUETOOTH_PROXY" });
    }
    create(value) {
        const message = { address: 0n, handle: 0, enable: false };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 address */ 1:
                    message.address = reader.uint64().toBigInt();
                    break;
                case /* uint32 handle */ 2:
                    message.handle = reader.uint32();
                    break;
                case /* bool enable */ 3:
                    message.enable = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint64 address = 1; */
        if (message.address !== 0n)
            writer.tag(1, runtime_1.WireType.Varint).uint64(message.address);
        /* uint32 handle = 2; */
        if (message.handle !== 0)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.handle);
        /* bool enable = 3; */
        if (message.enable !== false)
            writer.tag(3, runtime_1.WireType.Varint).bool(message.enable);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message BluetoothGATTNotifyRequest
 */
exports.BluetoothGATTNotifyRequest = new BluetoothGATTNotifyRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BluetoothGATTNotifyDataResponse$Type extends runtime_5.MessageType {
    constructor() {
        super("BluetoothGATTNotifyDataResponse", [
            { no: 1, name: "address", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "handle", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "data", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ], { id: 79, source: "SOURCE_SERVER", ifdef: "USE_BLUETOOTH_PROXY" });
    }
    create(value) {
        const message = { address: 0n, handle: 0, data: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 address */ 1:
                    message.address = reader.uint64().toBigInt();
                    break;
                case /* uint32 handle */ 2:
                    message.handle = reader.uint32();
                    break;
                case /* bytes data */ 3:
                    message.data = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint64 address = 1; */
        if (message.address !== 0n)
            writer.tag(1, runtime_1.WireType.Varint).uint64(message.address);
        /* uint32 handle = 2; */
        if (message.handle !== 0)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.handle);
        /* bytes data = 3; */
        if (message.data.length)
            writer.tag(3, runtime_1.WireType.LengthDelimited).bytes(message.data);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message BluetoothGATTNotifyDataResponse
 */
exports.BluetoothGATTNotifyDataResponse = new BluetoothGATTNotifyDataResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeBluetoothConnectionsFreeRequest$Type extends runtime_5.MessageType {
    constructor() {
        super("SubscribeBluetoothConnectionsFreeRequest", [], { id: 80, source: "SOURCE_CLIENT", ifdef: "USE_BLUETOOTH_PROXY" });
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        return target ?? this.create();
    }
    internalBinaryWrite(message, writer, options) {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SubscribeBluetoothConnectionsFreeRequest
 */
exports.SubscribeBluetoothConnectionsFreeRequest = new SubscribeBluetoothConnectionsFreeRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BluetoothConnectionsFreeResponse$Type extends runtime_5.MessageType {
    constructor() {
        super("BluetoothConnectionsFreeResponse", [
            { no: 1, name: "free", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "limit", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ], { id: 81, source: "SOURCE_SERVER", ifdef: "USE_BLUETOOTH_PROXY" });
    }
    create(value) {
        const message = { free: 0, limit: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 free */ 1:
                    message.free = reader.uint32();
                    break;
                case /* uint32 limit */ 2:
                    message.limit = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint32 free = 1; */
        if (message.free !== 0)
            writer.tag(1, runtime_1.WireType.Varint).uint32(message.free);
        /* uint32 limit = 2; */
        if (message.limit !== 0)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.limit);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message BluetoothConnectionsFreeResponse
 */
exports.BluetoothConnectionsFreeResponse = new BluetoothConnectionsFreeResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BluetoothGATTErrorResponse$Type extends runtime_5.MessageType {
    constructor() {
        super("BluetoothGATTErrorResponse", [
            { no: 1, name: "address", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "handle", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "error", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ], { id: 82, source: "SOURCE_SERVER", ifdef: "USE_BLUETOOTH_PROXY" });
    }
    create(value) {
        const message = { address: 0n, handle: 0, error: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 address */ 1:
                    message.address = reader.uint64().toBigInt();
                    break;
                case /* uint32 handle */ 2:
                    message.handle = reader.uint32();
                    break;
                case /* int32 error */ 3:
                    message.error = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint64 address = 1; */
        if (message.address !== 0n)
            writer.tag(1, runtime_1.WireType.Varint).uint64(message.address);
        /* uint32 handle = 2; */
        if (message.handle !== 0)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.handle);
        /* int32 error = 3; */
        if (message.error !== 0)
            writer.tag(3, runtime_1.WireType.Varint).int32(message.error);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message BluetoothGATTErrorResponse
 */
exports.BluetoothGATTErrorResponse = new BluetoothGATTErrorResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BluetoothGATTWriteResponse$Type extends runtime_5.MessageType {
    constructor() {
        super("BluetoothGATTWriteResponse", [
            { no: 1, name: "address", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "handle", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ], { id: 83, source: "SOURCE_SERVER", ifdef: "USE_BLUETOOTH_PROXY" });
    }
    create(value) {
        const message = { address: 0n, handle: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 address */ 1:
                    message.address = reader.uint64().toBigInt();
                    break;
                case /* uint32 handle */ 2:
                    message.handle = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint64 address = 1; */
        if (message.address !== 0n)
            writer.tag(1, runtime_1.WireType.Varint).uint64(message.address);
        /* uint32 handle = 2; */
        if (message.handle !== 0)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.handle);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message BluetoothGATTWriteResponse
 */
exports.BluetoothGATTWriteResponse = new BluetoothGATTWriteResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BluetoothGATTNotifyResponse$Type extends runtime_5.MessageType {
    constructor() {
        super("BluetoothGATTNotifyResponse", [
            { no: 1, name: "address", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "handle", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ], { id: 84, source: "SOURCE_SERVER", ifdef: "USE_BLUETOOTH_PROXY" });
    }
    create(value) {
        const message = { address: 0n, handle: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 address */ 1:
                    message.address = reader.uint64().toBigInt();
                    break;
                case /* uint32 handle */ 2:
                    message.handle = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint64 address = 1; */
        if (message.address !== 0n)
            writer.tag(1, runtime_1.WireType.Varint).uint64(message.address);
        /* uint32 handle = 2; */
        if (message.handle !== 0)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.handle);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message BluetoothGATTNotifyResponse
 */
exports.BluetoothGATTNotifyResponse = new BluetoothGATTNotifyResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BluetoothDevicePairingResponse$Type extends runtime_5.MessageType {
    constructor() {
        super("BluetoothDevicePairingResponse", [
            { no: 1, name: "address", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "paired", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "error", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ], { id: 85, source: "SOURCE_SERVER", ifdef: "USE_BLUETOOTH_PROXY" });
    }
    create(value) {
        const message = { address: 0n, paired: false, error: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 address */ 1:
                    message.address = reader.uint64().toBigInt();
                    break;
                case /* bool paired */ 2:
                    message.paired = reader.bool();
                    break;
                case /* int32 error */ 3:
                    message.error = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint64 address = 1; */
        if (message.address !== 0n)
            writer.tag(1, runtime_1.WireType.Varint).uint64(message.address);
        /* bool paired = 2; */
        if (message.paired !== false)
            writer.tag(2, runtime_1.WireType.Varint).bool(message.paired);
        /* int32 error = 3; */
        if (message.error !== 0)
            writer.tag(3, runtime_1.WireType.Varint).int32(message.error);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message BluetoothDevicePairingResponse
 */
exports.BluetoothDevicePairingResponse = new BluetoothDevicePairingResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BluetoothDeviceUnpairingResponse$Type extends runtime_5.MessageType {
    constructor() {
        super("BluetoothDeviceUnpairingResponse", [
            { no: 1, name: "address", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "success", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "error", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ], { id: 86, source: "SOURCE_SERVER", ifdef: "USE_BLUETOOTH_PROXY" });
    }
    create(value) {
        const message = { address: 0n, success: false, error: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 address */ 1:
                    message.address = reader.uint64().toBigInt();
                    break;
                case /* bool success */ 2:
                    message.success = reader.bool();
                    break;
                case /* int32 error */ 3:
                    message.error = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint64 address = 1; */
        if (message.address !== 0n)
            writer.tag(1, runtime_1.WireType.Varint).uint64(message.address);
        /* bool success = 2; */
        if (message.success !== false)
            writer.tag(2, runtime_1.WireType.Varint).bool(message.success);
        /* int32 error = 3; */
        if (message.error !== 0)
            writer.tag(3, runtime_1.WireType.Varint).int32(message.error);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message BluetoothDeviceUnpairingResponse
 */
exports.BluetoothDeviceUnpairingResponse = new BluetoothDeviceUnpairingResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UnsubscribeBluetoothLEAdvertisementsRequest$Type extends runtime_5.MessageType {
    constructor() {
        super("UnsubscribeBluetoothLEAdvertisementsRequest", [], { id: 87, source: "SOURCE_CLIENT" });
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        return target ?? this.create();
    }
    internalBinaryWrite(message, writer, options) {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message UnsubscribeBluetoothLEAdvertisementsRequest
 */
exports.UnsubscribeBluetoothLEAdvertisementsRequest = new UnsubscribeBluetoothLEAdvertisementsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BluetoothDeviceClearCacheResponse$Type extends runtime_5.MessageType {
    constructor() {
        super("BluetoothDeviceClearCacheResponse", [
            { no: 1, name: "address", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "success", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "error", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ], { id: 88, source: "SOURCE_SERVER", ifdef: "USE_BLUETOOTH_PROXY" });
    }
    create(value) {
        const message = { address: 0n, success: false, error: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 address */ 1:
                    message.address = reader.uint64().toBigInt();
                    break;
                case /* bool success */ 2:
                    message.success = reader.bool();
                    break;
                case /* int32 error */ 3:
                    message.error = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint64 address = 1; */
        if (message.address !== 0n)
            writer.tag(1, runtime_1.WireType.Varint).uint64(message.address);
        /* bool success = 2; */
        if (message.success !== false)
            writer.tag(2, runtime_1.WireType.Varint).bool(message.success);
        /* int32 error = 3; */
        if (message.error !== 0)
            writer.tag(3, runtime_1.WireType.Varint).int32(message.error);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message BluetoothDeviceClearCacheResponse
 */
exports.BluetoothDeviceClearCacheResponse = new BluetoothDeviceClearCacheResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeVoiceAssistantRequest$Type extends runtime_5.MessageType {
    constructor() {
        super("SubscribeVoiceAssistantRequest", [
            { no: 1, name: "subscribe", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ], { id: 89, source: "SOURCE_CLIENT", ifdef: "USE_VOICE_ASSISTANT" });
    }
    create(value) {
        const message = { subscribe: false };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool subscribe */ 1:
                    message.subscribe = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* bool subscribe = 1; */
        if (message.subscribe !== false)
            writer.tag(1, runtime_1.WireType.Varint).bool(message.subscribe);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SubscribeVoiceAssistantRequest
 */
exports.SubscribeVoiceAssistantRequest = new SubscribeVoiceAssistantRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VoiceAssistantRequest$Type extends runtime_5.MessageType {
    constructor() {
        super("VoiceAssistantRequest", [
            { no: 1, name: "start", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "conversation_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "use_vad", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ], { id: 90, source: "SOURCE_SERVER", ifdef: "USE_VOICE_ASSISTANT" });
    }
    create(value) {
        const message = { start: false, conversationId: "", useVad: false };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool start */ 1:
                    message.start = reader.bool();
                    break;
                case /* string conversation_id */ 2:
                    message.conversationId = reader.string();
                    break;
                case /* bool use_vad */ 3:
                    message.useVad = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* bool start = 1; */
        if (message.start !== false)
            writer.tag(1, runtime_1.WireType.Varint).bool(message.start);
        /* string conversation_id = 2; */
        if (message.conversationId !== "")
            writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.conversationId);
        /* bool use_vad = 3; */
        if (message.useVad !== false)
            writer.tag(3, runtime_1.WireType.Varint).bool(message.useVad);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message VoiceAssistantRequest
 */
exports.VoiceAssistantRequest = new VoiceAssistantRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VoiceAssistantResponse$Type extends runtime_5.MessageType {
    constructor() {
        super("VoiceAssistantResponse", [
            { no: 1, name: "port", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "error", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ], { id: 91, source: "SOURCE_CLIENT", ifdef: "USE_VOICE_ASSISTANT" });
    }
    create(value) {
        const message = { port: 0, error: false };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 port */ 1:
                    message.port = reader.uint32();
                    break;
                case /* bool error */ 2:
                    message.error = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint32 port = 1; */
        if (message.port !== 0)
            writer.tag(1, runtime_1.WireType.Varint).uint32(message.port);
        /* bool error = 2; */
        if (message.error !== false)
            writer.tag(2, runtime_1.WireType.Varint).bool(message.error);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message VoiceAssistantResponse
 */
exports.VoiceAssistantResponse = new VoiceAssistantResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VoiceAssistantEventData$Type extends runtime_5.MessageType {
    constructor() {
        super("VoiceAssistantEventData", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "value", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = { name: "", value: "" };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string value */ 2:
                    message.value = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.name);
        /* string value = 2; */
        if (message.value !== "")
            writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message VoiceAssistantEventData
 */
exports.VoiceAssistantEventData = new VoiceAssistantEventData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VoiceAssistantEventResponse$Type extends runtime_5.MessageType {
    constructor() {
        super("VoiceAssistantEventResponse", [
            { no: 1, name: "event_type", kind: "enum", T: () => ["VoiceAssistantEvent", VoiceAssistantEvent] },
            { no: 2, name: "data", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => exports.VoiceAssistantEventData }
        ], { id: 92, source: "SOURCE_CLIENT", ifdef: "USE_VOICE_ASSISTANT" });
    }
    create(value) {
        const message = { eventType: 0, data: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* VoiceAssistantEvent event_type */ 1:
                    message.eventType = reader.int32();
                    break;
                case /* repeated VoiceAssistantEventData data */ 2:
                    message.data.push(exports.VoiceAssistantEventData.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* VoiceAssistantEvent event_type = 1; */
        if (message.eventType !== 0)
            writer.tag(1, runtime_1.WireType.Varint).int32(message.eventType);
        /* repeated VoiceAssistantEventData data = 2; */
        for (let i = 0; i < message.data.length; i++)
            exports.VoiceAssistantEventData.internalBinaryWrite(message.data[i], writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message VoiceAssistantEventResponse
 */
exports.VoiceAssistantEventResponse = new VoiceAssistantEventResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListEntitiesAlarmControlPanelResponse$Type extends runtime_5.MessageType {
    constructor() {
        super("ListEntitiesAlarmControlPanelResponse", [
            { no: 1, name: "object_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "key", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ },
            { no: 3, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "unique_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "icon", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "disabled_by_default", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "entity_category", kind: "enum", T: () => ["EntityCategory", EntityCategory, "ENTITY_CATEGORY_"] },
            { no: 8, name: "supported_features", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "requires_code", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 10, name: "requires_code_to_arm", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ], { id: 94, source: "SOURCE_SERVER", ifdef: "USE_ALARM_CONTROL_PANEL" });
    }
    create(value) {
        const message = { objectId: "", key: 0, name: "", uniqueId: "", icon: "", disabledByDefault: false, entityCategory: 0, supportedFeatures: 0, requiresCode: false, requiresCodeToArm: false };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string object_id */ 1:
                    message.objectId = reader.string();
                    break;
                case /* fixed32 key */ 2:
                    message.key = reader.fixed32();
                    break;
                case /* string name */ 3:
                    message.name = reader.string();
                    break;
                case /* string unique_id */ 4:
                    message.uniqueId = reader.string();
                    break;
                case /* string icon */ 5:
                    message.icon = reader.string();
                    break;
                case /* bool disabled_by_default */ 6:
                    message.disabledByDefault = reader.bool();
                    break;
                case /* EntityCategory entity_category */ 7:
                    message.entityCategory = reader.int32();
                    break;
                case /* uint32 supported_features */ 8:
                    message.supportedFeatures = reader.uint32();
                    break;
                case /* bool requires_code */ 9:
                    message.requiresCode = reader.bool();
                    break;
                case /* bool requires_code_to_arm */ 10:
                    message.requiresCodeToArm = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string object_id = 1; */
        if (message.objectId !== "")
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.objectId);
        /* fixed32 key = 2; */
        if (message.key !== 0)
            writer.tag(2, runtime_1.WireType.Bit32).fixed32(message.key);
        /* string name = 3; */
        if (message.name !== "")
            writer.tag(3, runtime_1.WireType.LengthDelimited).string(message.name);
        /* string unique_id = 4; */
        if (message.uniqueId !== "")
            writer.tag(4, runtime_1.WireType.LengthDelimited).string(message.uniqueId);
        /* string icon = 5; */
        if (message.icon !== "")
            writer.tag(5, runtime_1.WireType.LengthDelimited).string(message.icon);
        /* bool disabled_by_default = 6; */
        if (message.disabledByDefault !== false)
            writer.tag(6, runtime_1.WireType.Varint).bool(message.disabledByDefault);
        /* EntityCategory entity_category = 7; */
        if (message.entityCategory !== 0)
            writer.tag(7, runtime_1.WireType.Varint).int32(message.entityCategory);
        /* uint32 supported_features = 8; */
        if (message.supportedFeatures !== 0)
            writer.tag(8, runtime_1.WireType.Varint).uint32(message.supportedFeatures);
        /* bool requires_code = 9; */
        if (message.requiresCode !== false)
            writer.tag(9, runtime_1.WireType.Varint).bool(message.requiresCode);
        /* bool requires_code_to_arm = 10; */
        if (message.requiresCodeToArm !== false)
            writer.tag(10, runtime_1.WireType.Varint).bool(message.requiresCodeToArm);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ListEntitiesAlarmControlPanelResponse
 */
exports.ListEntitiesAlarmControlPanelResponse = new ListEntitiesAlarmControlPanelResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AlarmControlPanelStateResponse$Type extends runtime_5.MessageType {
    constructor() {
        super("AlarmControlPanelStateResponse", [
            { no: 1, name: "key", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ },
            { no: 2, name: "state", kind: "enum", T: () => ["AlarmControlPanelState", AlarmControlPanelState] }
        ], { id: 95, source: "SOURCE_SERVER", ifdef: "USE_ALARM_CONTROL_PANEL", no_delay: true });
    }
    create(value) {
        const message = { key: 0, state: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* fixed32 key */ 1:
                    message.key = reader.fixed32();
                    break;
                case /* AlarmControlPanelState state */ 2:
                    message.state = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* fixed32 key = 1; */
        if (message.key !== 0)
            writer.tag(1, runtime_1.WireType.Bit32).fixed32(message.key);
        /* AlarmControlPanelState state = 2; */
        if (message.state !== 0)
            writer.tag(2, runtime_1.WireType.Varint).int32(message.state);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AlarmControlPanelStateResponse
 */
exports.AlarmControlPanelStateResponse = new AlarmControlPanelStateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AlarmControlPanelCommandRequest$Type extends runtime_5.MessageType {
    constructor() {
        super("AlarmControlPanelCommandRequest", [
            { no: 1, name: "key", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ },
            { no: 2, name: "command", kind: "enum", T: () => ["AlarmControlPanelStateCommand", AlarmControlPanelStateCommand] },
            { no: 3, name: "code", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { id: 96, source: "SOURCE_CLIENT", ifdef: "USE_ALARM_CONTROL_PANEL", no_delay: true });
    }
    create(value) {
        const message = { key: 0, command: 0, code: "" };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* fixed32 key */ 1:
                    message.key = reader.fixed32();
                    break;
                case /* AlarmControlPanelStateCommand command */ 2:
                    message.command = reader.int32();
                    break;
                case /* string code */ 3:
                    message.code = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* fixed32 key = 1; */
        if (message.key !== 0)
            writer.tag(1, runtime_1.WireType.Bit32).fixed32(message.key);
        /* AlarmControlPanelStateCommand command = 2; */
        if (message.command !== 0)
            writer.tag(2, runtime_1.WireType.Varint).int32(message.command);
        /* string code = 3; */
        if (message.code !== "")
            writer.tag(3, runtime_1.WireType.LengthDelimited).string(message.code);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AlarmControlPanelCommandRequest
 */
exports.AlarmControlPanelCommandRequest = new AlarmControlPanelCommandRequest$Type();
/**
 * @generated ServiceType for protobuf service APIConnection
 */
exports.APIConnection = new runtime_rpc_1.ServiceType("APIConnection", [
    { name: "hello", options: { needs_setup_connection: false, needs_authentication: false }, I: exports.HelloRequest, O: exports.HelloResponse },
    { name: "connect", options: { needs_setup_connection: false, needs_authentication: false }, I: exports.ConnectRequest, O: exports.ConnectResponse },
    { name: "disconnect", options: { needs_setup_connection: false, needs_authentication: false }, I: exports.DisconnectRequest, O: exports.DisconnectResponse },
    { name: "ping", options: { needs_setup_connection: false, needs_authentication: false }, I: exports.PingRequest, O: exports.PingResponse },
    { name: "device_info", options: { needs_authentication: false }, I: exports.DeviceInfoRequest, O: exports.DeviceInfoResponse },
    { name: "list_entities", options: {}, I: exports.ListEntitiesRequest, O: api_options_pb_1.void$ },
    { name: "subscribe_states", options: {}, I: exports.SubscribeStatesRequest, O: api_options_pb_1.void$ },
    { name: "subscribe_logs", options: {}, I: exports.SubscribeLogsRequest, O: api_options_pb_1.void$ },
    { name: "subscribe_homeassistant_services", options: {}, I: exports.SubscribeHomeassistantServicesRequest, O: api_options_pb_1.void$ },
    { name: "subscribe_home_assistant_states", options: {}, I: exports.SubscribeHomeAssistantStatesRequest, O: api_options_pb_1.void$ },
    { name: "get_time", options: { needs_authentication: false }, I: exports.GetTimeRequest, O: exports.GetTimeResponse },
    { name: "execute_service", options: {}, I: exports.ExecuteServiceRequest, O: api_options_pb_1.void$ },
    { name: "cover_command", options: {}, I: exports.CoverCommandRequest, O: api_options_pb_1.void$ },
    { name: "fan_command", options: {}, I: exports.FanCommandRequest, O: api_options_pb_1.void$ },
    { name: "light_command", options: {}, I: exports.LightCommandRequest, O: api_options_pb_1.void$ },
    { name: "switch_command", options: {}, I: exports.SwitchCommandRequest, O: api_options_pb_1.void$ },
    { name: "camera_image", options: {}, I: exports.CameraImageRequest, O: api_options_pb_1.void$ },
    { name: "climate_command", options: {}, I: exports.ClimateCommandRequest, O: api_options_pb_1.void$ },
    { name: "number_command", options: {}, I: exports.NumberCommandRequest, O: api_options_pb_1.void$ },
    { name: "select_command", options: {}, I: exports.SelectCommandRequest, O: api_options_pb_1.void$ },
    { name: "siren_command", options: {}, I: exports.SirenCommandRequest, O: api_options_pb_1.void$ },
    { name: "button_command", options: {}, I: exports.ButtonCommandRequest, O: api_options_pb_1.void$ },
    { name: "lock_command", options: {}, I: exports.LockCommandRequest, O: api_options_pb_1.void$ },
    { name: "media_player_command", options: {}, I: exports.MediaPlayerCommandRequest, O: api_options_pb_1.void$ },
    { name: "subscribe_bluetooth_le_advertisements", options: {}, I: exports.SubscribeBluetoothLEAdvertisementsRequest, O: api_options_pb_1.void$ },
    { name: "bluetooth_device_request", options: {}, I: exports.BluetoothDeviceRequest, O: api_options_pb_1.void$ },
    { name: "bluetooth_gatt_get_services", options: {}, I: exports.BluetoothGATTGetServicesRequest, O: api_options_pb_1.void$ },
    { name: "bluetooth_gatt_read", options: {}, I: exports.BluetoothGATTReadRequest, O: api_options_pb_1.void$ },
    { name: "bluetooth_gatt_write", options: {}, I: exports.BluetoothGATTWriteRequest, O: api_options_pb_1.void$ },
    { name: "bluetooth_gatt_read_descriptor", options: {}, I: exports.BluetoothGATTReadDescriptorRequest, O: api_options_pb_1.void$ },
    { name: "bluetooth_gatt_write_descriptor", options: {}, I: exports.BluetoothGATTWriteDescriptorRequest, O: api_options_pb_1.void$ },
    { name: "bluetooth_gatt_notify", options: {}, I: exports.BluetoothGATTNotifyRequest, O: api_options_pb_1.void$ },
    { name: "unsubscribe_bluetooth_le_advertisements", options: {}, I: exports.UnsubscribeBluetoothLEAdvertisementsRequest, O: api_options_pb_1.void$ },
    { name: "subscribe_voice_assistant", options: {}, I: exports.SubscribeVoiceAssistantRequest, O: api_options_pb_1.void$ },
    { name: "alarm_control_panel_command", options: {}, I: exports.AlarmControlPanelCommandRequest, O: api_options_pb_1.void$ }
]);
//# sourceMappingURL=api_pb.js.map