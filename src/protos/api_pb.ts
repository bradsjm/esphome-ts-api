/* eslint-disable */
// @generated by protobuf-ts 2.9.0 with parameter eslint_disable,add_pb_suffix,output_legacy_commonjs
// @generated from protobuf file "api.proto" (syntax proto3)
// tslint:disable
import { void$ } from "./api_options_pb";
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
// ==================== BASE PACKETS ====================

// The Home Assistant protocol is structured as a simple
// TCP socket with short binary messages encoded in the protocol buffers format
// First, a message in this protocol has a specific format:
//  * A zero byte.
//  * VarInt denoting the size of the message object. (type is not part of this)
//  * VarInt denoting the type of message.
//  * The message object encoded as a ProtoBuf message

// The connection is established in 4 steps:
//  * First, the client connects to the server and sends a "Hello Request" identifying itself
//  * The server responds with a "Hello Response" and selects the protocol version
//  * After receiving this message, the client attempts to authenticate itself using
//    the password and a "Connect Request"
//  * The server responds with a "Connect Response" and notifies of invalid password.
// If anything in this initial process fails, the connection must immediately closed
// by both sides and _no_ disconnection message is to be sent.

/**
 * Message sent at the beginning of each connection
 * Can only be sent by the client and only at the beginning of the connection
 *
 * @generated from protobuf message HelloRequest
 */
export interface HelloRequest {
    /**
     * Description of client (like User Agent)
     * For example "Home Assistant"
     * Not strictly necessary to send but nice for debugging
     * purposes.
     *
     * @generated from protobuf field: string client_info = 1;
     */
    clientInfo: string;
    /**
     * @generated from protobuf field: uint32 api_version_major = 2;
     */
    apiVersionMajor: number;
    /**
     * @generated from protobuf field: uint32 api_version_minor = 3;
     */
    apiVersionMinor: number;
}
/**
 * Confirmation of successful connection request.
 * Can only be sent by the server and only at the beginning of the connection
 *
 * @generated from protobuf message HelloResponse
 */
export interface HelloResponse {
    /**
     * The version of the API to use. The _client_ (for example Home Assistant) needs to check
     * for compatibility and if necessary adopt to an older API.
     * Major is for breaking changes in the base protocol - a mismatch will lead to immediate disconnect_client_
     * Minor is for breaking changes in individual messages - a mismatch will lead to a warning message
     *
     * @generated from protobuf field: uint32 api_version_major = 1;
     */
    apiVersionMajor: number;
    /**
     * @generated from protobuf field: uint32 api_version_minor = 2;
     */
    apiVersionMinor: number;
    /**
     * A string identifying the server (ESP); like client info this may be empty
     * and only exists for debugging/logging purposes.
     * For example "ESPHome v1.10.0 on ESP8266"
     *
     * @generated from protobuf field: string server_info = 3;
     */
    serverInfo: string;
    /**
     * The name of the server (App.get_name())
     *
     * @generated from protobuf field: string name = 4;
     */
    name: string;
}
/**
 * Message sent at the beginning of each connection to authenticate the client
 * Can only be sent by the client and only at the beginning of the connection
 *
 * @generated from protobuf message ConnectRequest
 */
export interface ConnectRequest {
    /**
     * The password to log in with
     *
     * @generated from protobuf field: string password = 1;
     */
    password: string;
}
/**
 * Confirmation of successful connection. After this the connection is available for all traffic.
 * Can only be sent by the server and only at the beginning of the connection
 *
 * @generated from protobuf message ConnectResponse
 */
export interface ConnectResponse {
    /**
     * @generated from protobuf field: bool invalid_password = 1;
     */
    invalidPassword: boolean;
}
/**
 * Request to close the connection.
 * Can be sent by both the client and server
 *
 * @generated from protobuf message DisconnectRequest
 */
export interface DisconnectRequest {
}
/**
 * @generated from protobuf message DisconnectResponse
 */
export interface DisconnectResponse {
}
/**
 * @generated from protobuf message PingRequest
 */
export interface PingRequest {
}
/**
 * @generated from protobuf message PingResponse
 */
export interface PingResponse {
}
/**
 * @generated from protobuf message DeviceInfoRequest
 */
export interface DeviceInfoRequest {
}
/**
 * @generated from protobuf message DeviceInfoResponse
 */
export interface DeviceInfoResponse {
    /**
     * @generated from protobuf field: bool uses_password = 1;
     */
    usesPassword: boolean;
    /**
     * The name of the node, given by "App.set_name()"
     *
     * @generated from protobuf field: string name = 2;
     */
    name: string;
    /**
     * The mac address of the device. For example "AC:BC:32:89:0E:A9"
     *
     * @generated from protobuf field: string mac_address = 3;
     */
    macAddress: string;
    /**
     * A string describing the ESPHome version. For example "1.10.0"
     *
     * @generated from protobuf field: string esphome_version = 4;
     */
    esphomeVersion: string;
    /**
     * A string describing the date of compilation, this is generated by the compiler
     * and therefore may not be in the same format all the time.
     * If the user isn't using ESPHome, this will also not be set.
     *
     * @generated from protobuf field: string compilation_time = 5;
     */
    compilationTime: string;
    /**
     * The model of the board. For example NodeMCU
     *
     * @generated from protobuf field: string model = 6;
     */
    model: string;
    /**
     * @generated from protobuf field: bool has_deep_sleep = 7;
     */
    hasDeepSleep: boolean;
    /**
     * The esphome project details if set
     *
     * @generated from protobuf field: string project_name = 8;
     */
    projectName: string;
    /**
     * @generated from protobuf field: string project_version = 9;
     */
    projectVersion: string;
    /**
     * @generated from protobuf field: uint32 webserver_port = 10;
     */
    webserverPort: number;
    /**
     * @generated from protobuf field: uint32 legacy_bluetooth_proxy_version = 11;
     */
    legacyBluetoothProxyVersion: number;
    /**
     * @generated from protobuf field: uint32 bluetooth_proxy_feature_flags = 15;
     */
    bluetoothProxyFeatureFlags: number;
    /**
     * @generated from protobuf field: string manufacturer = 12;
     */
    manufacturer: string;
    /**
     * @generated from protobuf field: string friendly_name = 13;
     */
    friendlyName: string;
    /**
     * @generated from protobuf field: uint32 voice_assistant_version = 14;
     */
    voiceAssistantVersion: number;
}
/**
 * @generated from protobuf message ListEntitiesRequest
 */
export interface ListEntitiesRequest {
}
/**
 * @generated from protobuf message ListEntitiesDoneResponse
 */
export interface ListEntitiesDoneResponse {
}
/**
 * @generated from protobuf message SubscribeStatesRequest
 */
export interface SubscribeStatesRequest {
}
/**
 * ==================== BINARY SENSOR ====================
 *
 * @generated from protobuf message ListEntitiesBinarySensorResponse
 */
export interface ListEntitiesBinarySensorResponse {
    /**
     * @generated from protobuf field: string object_id = 1;
     */
    objectId: string;
    /**
     * @generated from protobuf field: fixed32 key = 2;
     */
    key: number;
    /**
     * @generated from protobuf field: string name = 3;
     */
    name: string;
    /**
     * @generated from protobuf field: string unique_id = 4;
     */
    uniqueId: string;
    /**
     * @generated from protobuf field: string device_class = 5;
     */
    deviceClass: string;
    /**
     * @generated from protobuf field: bool is_status_binary_sensor = 6;
     */
    isStatusBinarySensor: boolean;
    /**
     * @generated from protobuf field: bool disabled_by_default = 7;
     */
    disabledByDefault: boolean;
    /**
     * @generated from protobuf field: string icon = 8;
     */
    icon: string;
    /**
     * @generated from protobuf field: EntityCategory entity_category = 9;
     */
    entityCategory: EntityCategory;
}
/**
 * @generated from protobuf message BinarySensorStateResponse
 */
export interface BinarySensorStateResponse {
    /**
     * @generated from protobuf field: fixed32 key = 1;
     */
    key: number;
    /**
     * @generated from protobuf field: bool state = 2;
     */
    state: boolean;
    /**
     * If the binary sensor does not have a valid state yet.
     * Equivalent to `!obj->has_state()` - inverse logic to make state packets smaller
     *
     * @generated from protobuf field: bool missing_state = 3;
     */
    missingState: boolean;
}
/**
 * ==================== COVER ====================
 *
 * @generated from protobuf message ListEntitiesCoverResponse
 */
export interface ListEntitiesCoverResponse {
    /**
     * @generated from protobuf field: string object_id = 1;
     */
    objectId: string;
    /**
     * @generated from protobuf field: fixed32 key = 2;
     */
    key: number;
    /**
     * @generated from protobuf field: string name = 3;
     */
    name: string;
    /**
     * @generated from protobuf field: string unique_id = 4;
     */
    uniqueId: string;
    /**
     * @generated from protobuf field: bool assumed_state = 5;
     */
    assumedState: boolean;
    /**
     * @generated from protobuf field: bool supports_position = 6;
     */
    supportsPosition: boolean;
    /**
     * @generated from protobuf field: bool supports_tilt = 7;
     */
    supportsTilt: boolean;
    /**
     * @generated from protobuf field: string device_class = 8;
     */
    deviceClass: string;
    /**
     * @generated from protobuf field: bool disabled_by_default = 9;
     */
    disabledByDefault: boolean;
    /**
     * @generated from protobuf field: string icon = 10;
     */
    icon: string;
    /**
     * @generated from protobuf field: EntityCategory entity_category = 11;
     */
    entityCategory: EntityCategory;
    /**
     * @generated from protobuf field: bool supports_stop = 12;
     */
    supportsStop: boolean;
}
/**
 * @generated from protobuf message CoverStateResponse
 */
export interface CoverStateResponse {
    /**
     * @generated from protobuf field: fixed32 key = 1;
     */
    key: number;
    /**
     * legacy: state has been removed in 1.13
     * clients/servers must still send/accept it until the next protocol change
     *
     * @generated from protobuf field: LegacyCoverState legacy_state = 2;
     */
    legacyState: LegacyCoverState;
    /**
     * @generated from protobuf field: float position = 3;
     */
    position: number;
    /**
     * @generated from protobuf field: float tilt = 4;
     */
    tilt: number;
    /**
     * @generated from protobuf field: CoverOperation current_operation = 5;
     */
    currentOperation: CoverOperation;
}
/**
 * @generated from protobuf message CoverCommandRequest
 */
export interface CoverCommandRequest {
    /**
     * @generated from protobuf field: fixed32 key = 1;
     */
    key: number;
    /**
     * legacy: command has been removed in 1.13
     * clients/servers must still send/accept it until the next protocol change
     *
     * @generated from protobuf field: bool has_legacy_command = 2;
     */
    hasLegacyCommand: boolean;
    /**
     * @generated from protobuf field: LegacyCoverCommand legacy_command = 3;
     */
    legacyCommand: LegacyCoverCommand;
    /**
     * @generated from protobuf field: bool has_position = 4;
     */
    hasPosition: boolean;
    /**
     * @generated from protobuf field: float position = 5;
     */
    position: number;
    /**
     * @generated from protobuf field: bool has_tilt = 6;
     */
    hasTilt: boolean;
    /**
     * @generated from protobuf field: float tilt = 7;
     */
    tilt: number;
    /**
     * @generated from protobuf field: bool stop = 8;
     */
    stop: boolean;
}
/**
 * ==================== FAN ====================
 *
 * @generated from protobuf message ListEntitiesFanResponse
 */
export interface ListEntitiesFanResponse {
    /**
     * @generated from protobuf field: string object_id = 1;
     */
    objectId: string;
    /**
     * @generated from protobuf field: fixed32 key = 2;
     */
    key: number;
    /**
     * @generated from protobuf field: string name = 3;
     */
    name: string;
    /**
     * @generated from protobuf field: string unique_id = 4;
     */
    uniqueId: string;
    /**
     * @generated from protobuf field: bool supports_oscillation = 5;
     */
    supportsOscillation: boolean;
    /**
     * @generated from protobuf field: bool supports_speed = 6;
     */
    supportsSpeed: boolean;
    /**
     * @generated from protobuf field: bool supports_direction = 7;
     */
    supportsDirection: boolean;
    /**
     * @generated from protobuf field: int32 supported_speed_levels = 8;
     */
    supportedSpeedLevels: number;
    /**
     * @generated from protobuf field: bool disabled_by_default = 9;
     */
    disabledByDefault: boolean;
    /**
     * @generated from protobuf field: string icon = 10;
     */
    icon: string;
    /**
     * @generated from protobuf field: EntityCategory entity_category = 11;
     */
    entityCategory: EntityCategory;
}
/**
 * @generated from protobuf message FanStateResponse
 */
export interface FanStateResponse {
    /**
     * @generated from protobuf field: fixed32 key = 1;
     */
    key: number;
    /**
     * @generated from protobuf field: bool state = 2;
     */
    state: boolean;
    /**
     * @generated from protobuf field: bool oscillating = 3;
     */
    oscillating: boolean;
    /**
     * @deprecated
     * @generated from protobuf field: FanSpeed speed = 4 [deprecated = true];
     */
    speed: FanSpeed;
    /**
     * @generated from protobuf field: FanDirection direction = 5;
     */
    direction: FanDirection;
    /**
     * @generated from protobuf field: int32 speed_level = 6;
     */
    speedLevel: number;
}
/**
 * @generated from protobuf message FanCommandRequest
 */
export interface FanCommandRequest {
    /**
     * @generated from protobuf field: fixed32 key = 1;
     */
    key: number;
    /**
     * @generated from protobuf field: bool has_state = 2;
     */
    hasState: boolean;
    /**
     * @generated from protobuf field: bool state = 3;
     */
    state: boolean;
    /**
     * @deprecated
     * @generated from protobuf field: bool has_speed = 4 [deprecated = true];
     */
    hasSpeed: boolean;
    /**
     * @deprecated
     * @generated from protobuf field: FanSpeed speed = 5 [deprecated = true];
     */
    speed: FanSpeed;
    /**
     * @generated from protobuf field: bool has_oscillating = 6;
     */
    hasOscillating: boolean;
    /**
     * @generated from protobuf field: bool oscillating = 7;
     */
    oscillating: boolean;
    /**
     * @generated from protobuf field: bool has_direction = 8;
     */
    hasDirection: boolean;
    /**
     * @generated from protobuf field: FanDirection direction = 9;
     */
    direction: FanDirection;
    /**
     * @generated from protobuf field: bool has_speed_level = 10;
     */
    hasSpeedLevel: boolean;
    /**
     * @generated from protobuf field: int32 speed_level = 11;
     */
    speedLevel: number;
}
/**
 * ==================== LIGHT ====================
 *
 * @generated from protobuf message ListEntitiesLightResponse
 */
export interface ListEntitiesLightResponse {
    /**
     * @generated from protobuf field: string object_id = 1;
     */
    objectId: string;
    /**
     * @generated from protobuf field: fixed32 key = 2;
     */
    key: number;
    /**
     * @generated from protobuf field: string name = 3;
     */
    name: string;
    /**
     * @generated from protobuf field: string unique_id = 4;
     */
    uniqueId: string;
    /**
     * @generated from protobuf field: repeated int32 supported_color_modes = 12;
     */
    supportedColorModes: number[];
    /**
     * next four supports_* are for legacy clients, newer clients should use color modes
     *
     * @deprecated
     * @generated from protobuf field: bool legacy_supports_brightness = 5 [deprecated = true];
     */
    legacySupportsBrightness: boolean;
    /**
     * @deprecated
     * @generated from protobuf field: bool legacy_supports_rgb = 6 [deprecated = true];
     */
    legacySupportsRgb: boolean;
    /**
     * @deprecated
     * @generated from protobuf field: bool legacy_supports_white_value = 7 [deprecated = true];
     */
    legacySupportsWhiteValue: boolean;
    /**
     * @deprecated
     * @generated from protobuf field: bool legacy_supports_color_temperature = 8 [deprecated = true];
     */
    legacySupportsColorTemperature: boolean;
    /**
     * @generated from protobuf field: float min_mireds = 9;
     */
    minMireds: number;
    /**
     * @generated from protobuf field: float max_mireds = 10;
     */
    maxMireds: number;
    /**
     * @generated from protobuf field: repeated string effects = 11;
     */
    effects: string[];
    /**
     * @generated from protobuf field: bool disabled_by_default = 13;
     */
    disabledByDefault: boolean;
    /**
     * @generated from protobuf field: string icon = 14;
     */
    icon: string;
    /**
     * @generated from protobuf field: EntityCategory entity_category = 15;
     */
    entityCategory: EntityCategory;
}
/**
 * @generated from protobuf message LightStateResponse
 */
export interface LightStateResponse {
    /**
     * @generated from protobuf field: fixed32 key = 1;
     */
    key: number;
    /**
     * @generated from protobuf field: bool state = 2;
     */
    state: boolean;
    /**
     * @generated from protobuf field: float brightness = 3;
     */
    brightness: number;
    /**
     * @generated from protobuf field: int32 color_mode = 11;
     */
    colorMode: number;
    /**
     * @generated from protobuf field: float color_brightness = 10;
     */
    colorBrightness: number;
    /**
     * @generated from protobuf field: float red = 4;
     */
    red: number;
    /**
     * @generated from protobuf field: float green = 5;
     */
    green: number;
    /**
     * @generated from protobuf field: float blue = 6;
     */
    blue: number;
    /**
     * @generated from protobuf field: float white = 7;
     */
    white: number;
    /**
     * @generated from protobuf field: float color_temperature = 8;
     */
    colorTemperature: number;
    /**
     * @generated from protobuf field: float cold_white = 12;
     */
    coldWhite: number;
    /**
     * @generated from protobuf field: float warm_white = 13;
     */
    warmWhite: number;
    /**
     * @generated from protobuf field: string effect = 9;
     */
    effect: string;
}
/**
 * @generated from protobuf message LightCommandRequest
 */
export interface LightCommandRequest {
    /**
     * @generated from protobuf field: fixed32 key = 1;
     */
    key: number;
    /**
     * @generated from protobuf field: bool has_state = 2;
     */
    hasState: boolean;
    /**
     * @generated from protobuf field: bool state = 3;
     */
    state: boolean;
    /**
     * @generated from protobuf field: bool has_brightness = 4;
     */
    hasBrightness: boolean;
    /**
     * @generated from protobuf field: float brightness = 5;
     */
    brightness: number;
    /**
     * @generated from protobuf field: bool has_color_mode = 22;
     */
    hasColorMode: boolean;
    /**
     * @generated from protobuf field: int32 color_mode = 23;
     */
    colorMode: number;
    /**
     * @generated from protobuf field: bool has_color_brightness = 20;
     */
    hasColorBrightness: boolean;
    /**
     * @generated from protobuf field: float color_brightness = 21;
     */
    colorBrightness: number;
    /**
     * @generated from protobuf field: bool has_rgb = 6;
     */
    hasRgb: boolean;
    /**
     * @generated from protobuf field: float red = 7;
     */
    red: number;
    /**
     * @generated from protobuf field: float green = 8;
     */
    green: number;
    /**
     * @generated from protobuf field: float blue = 9;
     */
    blue: number;
    /**
     * @generated from protobuf field: bool has_white = 10;
     */
    hasWhite: boolean;
    /**
     * @generated from protobuf field: float white = 11;
     */
    white: number;
    /**
     * @generated from protobuf field: bool has_color_temperature = 12;
     */
    hasColorTemperature: boolean;
    /**
     * @generated from protobuf field: float color_temperature = 13;
     */
    colorTemperature: number;
    /**
     * @generated from protobuf field: bool has_cold_white = 24;
     */
    hasColdWhite: boolean;
    /**
     * @generated from protobuf field: float cold_white = 25;
     */
    coldWhite: number;
    /**
     * @generated from protobuf field: bool has_warm_white = 26;
     */
    hasWarmWhite: boolean;
    /**
     * @generated from protobuf field: float warm_white = 27;
     */
    warmWhite: number;
    /**
     * @generated from protobuf field: bool has_transition_length = 14;
     */
    hasTransitionLength: boolean;
    /**
     * @generated from protobuf field: uint32 transition_length = 15;
     */
    transitionLength: number;
    /**
     * @generated from protobuf field: bool has_flash_length = 16;
     */
    hasFlashLength: boolean;
    /**
     * @generated from protobuf field: uint32 flash_length = 17;
     */
    flashLength: number;
    /**
     * @generated from protobuf field: bool has_effect = 18;
     */
    hasEffect: boolean;
    /**
     * @generated from protobuf field: string effect = 19;
     */
    effect: string;
}
/**
 * @generated from protobuf message ListEntitiesSensorResponse
 */
export interface ListEntitiesSensorResponse {
    /**
     * @generated from protobuf field: string object_id = 1;
     */
    objectId: string;
    /**
     * @generated from protobuf field: fixed32 key = 2;
     */
    key: number;
    /**
     * @generated from protobuf field: string name = 3;
     */
    name: string;
    /**
     * @generated from protobuf field: string unique_id = 4;
     */
    uniqueId: string;
    /**
     * @generated from protobuf field: string icon = 5;
     */
    icon: string;
    /**
     * @generated from protobuf field: string unit_of_measurement = 6;
     */
    unitOfMeasurement: string;
    /**
     * @generated from protobuf field: int32 accuracy_decimals = 7;
     */
    accuracyDecimals: number;
    /**
     * @generated from protobuf field: bool force_update = 8;
     */
    forceUpdate: boolean;
    /**
     * @generated from protobuf field: string device_class = 9;
     */
    deviceClass: string;
    /**
     * @generated from protobuf field: SensorStateClass state_class = 10;
     */
    stateClass: SensorStateClass;
    /**
     * @generated from protobuf field: SensorLastResetType last_reset_type = 11;
     */
    lastResetType: SensorLastResetType;
    /**
     * @generated from protobuf field: bool disabled_by_default = 12;
     */
    disabledByDefault: boolean;
    /**
     * @generated from protobuf field: EntityCategory entity_category = 13;
     */
    entityCategory: EntityCategory;
}
/**
 * @generated from protobuf message SensorStateResponse
 */
export interface SensorStateResponse {
    /**
     * @generated from protobuf field: fixed32 key = 1;
     */
    key: number;
    /**
     * @generated from protobuf field: float state = 2;
     */
    state: number;
    /**
     * If the sensor does not have a valid state yet.
     * Equivalent to `!obj->has_state()` - inverse logic to make state packets smaller
     *
     * @generated from protobuf field: bool missing_state = 3;
     */
    missingState: boolean;
}
/**
 * ==================== SWITCH ====================
 *
 * @generated from protobuf message ListEntitiesSwitchResponse
 */
export interface ListEntitiesSwitchResponse {
    /**
     * @generated from protobuf field: string object_id = 1;
     */
    objectId: string;
    /**
     * @generated from protobuf field: fixed32 key = 2;
     */
    key: number;
    /**
     * @generated from protobuf field: string name = 3;
     */
    name: string;
    /**
     * @generated from protobuf field: string unique_id = 4;
     */
    uniqueId: string;
    /**
     * @generated from protobuf field: string icon = 5;
     */
    icon: string;
    /**
     * @generated from protobuf field: bool assumed_state = 6;
     */
    assumedState: boolean;
    /**
     * @generated from protobuf field: bool disabled_by_default = 7;
     */
    disabledByDefault: boolean;
    /**
     * @generated from protobuf field: EntityCategory entity_category = 8;
     */
    entityCategory: EntityCategory;
    /**
     * @generated from protobuf field: string device_class = 9;
     */
    deviceClass: string;
}
/**
 * @generated from protobuf message SwitchStateResponse
 */
export interface SwitchStateResponse {
    /**
     * @generated from protobuf field: fixed32 key = 1;
     */
    key: number;
    /**
     * @generated from protobuf field: bool state = 2;
     */
    state: boolean;
}
/**
 * @generated from protobuf message SwitchCommandRequest
 */
export interface SwitchCommandRequest {
    /**
     * @generated from protobuf field: fixed32 key = 1;
     */
    key: number;
    /**
     * @generated from protobuf field: bool state = 2;
     */
    state: boolean;
}
/**
 * ==================== TEXT SENSOR ====================
 *
 * @generated from protobuf message ListEntitiesTextSensorResponse
 */
export interface ListEntitiesTextSensorResponse {
    /**
     * @generated from protobuf field: string object_id = 1;
     */
    objectId: string;
    /**
     * @generated from protobuf field: fixed32 key = 2;
     */
    key: number;
    /**
     * @generated from protobuf field: string name = 3;
     */
    name: string;
    /**
     * @generated from protobuf field: string unique_id = 4;
     */
    uniqueId: string;
    /**
     * @generated from protobuf field: string icon = 5;
     */
    icon: string;
    /**
     * @generated from protobuf field: bool disabled_by_default = 6;
     */
    disabledByDefault: boolean;
    /**
     * @generated from protobuf field: EntityCategory entity_category = 7;
     */
    entityCategory: EntityCategory;
}
/**
 * @generated from protobuf message TextSensorStateResponse
 */
export interface TextSensorStateResponse {
    /**
     * @generated from protobuf field: fixed32 key = 1;
     */
    key: number;
    /**
     * @generated from protobuf field: string state = 2;
     */
    state: string;
    /**
     * If the text sensor does not have a valid state yet.
     * Equivalent to `!obj->has_state()` - inverse logic to make state packets smaller
     *
     * @generated from protobuf field: bool missing_state = 3;
     */
    missingState: boolean;
}
/**
 * @generated from protobuf message SubscribeLogsRequest
 */
export interface SubscribeLogsRequest {
    /**
     * @generated from protobuf field: LogLevel level = 1;
     */
    level: LogLevel;
    /**
     * @generated from protobuf field: bool dump_config = 2;
     */
    dumpConfig: boolean;
}
/**
 * @generated from protobuf message SubscribeLogsResponse
 */
export interface SubscribeLogsResponse {
    /**
     * @generated from protobuf field: LogLevel level = 1;
     */
    level: LogLevel;
    /**
     * @generated from protobuf field: bytes message = 3;
     */
    message: Uint8Array;
    /**
     * @generated from protobuf field: bool send_failed = 4;
     */
    sendFailed: boolean;
}
/**
 * ==================== HOMEASSISTANT.SERVICE ====================
 *
 * @generated from protobuf message SubscribeHomeassistantServicesRequest
 */
export interface SubscribeHomeassistantServicesRequest {
}
/**
 * @generated from protobuf message HomeassistantServiceMap
 */
export interface HomeassistantServiceMap {
    /**
     * @generated from protobuf field: string key = 1;
     */
    key: string;
    /**
     * @generated from protobuf field: string value = 2;
     */
    value: string;
}
/**
 * @generated from protobuf message HomeassistantServiceResponse
 */
export interface HomeassistantServiceResponse {
    /**
     * @generated from protobuf field: string service = 1;
     */
    service: string;
    /**
     * @generated from protobuf field: repeated HomeassistantServiceMap data = 2;
     */
    data: HomeassistantServiceMap[];
    /**
     * @generated from protobuf field: repeated HomeassistantServiceMap data_template = 3;
     */
    dataTemplate: HomeassistantServiceMap[];
    /**
     * @generated from protobuf field: repeated HomeassistantServiceMap variables = 4;
     */
    variables: HomeassistantServiceMap[];
    /**
     * @generated from protobuf field: bool is_event = 5;
     */
    isEvent: boolean;
}
/**
 * ==================== IMPORT HOME ASSISTANT STATES ====================
 * 1. Client sends SubscribeHomeAssistantStatesRequest
 * 2. Server responds with zero or more SubscribeHomeAssistantStateResponse (async)
 * 3. Client sends HomeAssistantStateResponse for state changes.
 *
 * @generated from protobuf message SubscribeHomeAssistantStatesRequest
 */
export interface SubscribeHomeAssistantStatesRequest {
}
/**
 * @generated from protobuf message SubscribeHomeAssistantStateResponse
 */
export interface SubscribeHomeAssistantStateResponse {
    /**
     * @generated from protobuf field: string entity_id = 1;
     */
    entityId: string;
    /**
     * @generated from protobuf field: string attribute = 2;
     */
    attribute: string;
}
/**
 * @generated from protobuf message HomeAssistantStateResponse
 */
export interface HomeAssistantStateResponse {
    /**
     * @generated from protobuf field: string entity_id = 1;
     */
    entityId: string;
    /**
     * @generated from protobuf field: string state = 2;
     */
    state: string;
    /**
     * @generated from protobuf field: string attribute = 3;
     */
    attribute: string;
}
/**
 * ==================== IMPORT TIME ====================
 *
 * @generated from protobuf message GetTimeRequest
 */
export interface GetTimeRequest {
}
/**
 * @generated from protobuf message GetTimeResponse
 */
export interface GetTimeResponse {
    /**
     * @generated from protobuf field: fixed32 epoch_seconds = 1;
     */
    epochSeconds: number;
}
/**
 * @generated from protobuf message ListEntitiesServicesArgument
 */
export interface ListEntitiesServicesArgument {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: ServiceArgType type = 2;
     */
    type: ServiceArgType;
}
/**
 * @generated from protobuf message ListEntitiesServicesResponse
 */
export interface ListEntitiesServicesResponse {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: fixed32 key = 2;
     */
    key: number;
    /**
     * @generated from protobuf field: repeated ListEntitiesServicesArgument args = 3;
     */
    args: ListEntitiesServicesArgument[];
}
/**
 * @generated from protobuf message ExecuteServiceArgument
 */
export interface ExecuteServiceArgument {
    /**
     * @generated from protobuf field: bool bool_ = 1;
     */
    bool: boolean;
    /**
     * @generated from protobuf field: int32 legacy_int = 2;
     */
    legacyInt: number;
    /**
     * @generated from protobuf field: float float_ = 3;
     */
    float: number;
    /**
     * @generated from protobuf field: string string_ = 4;
     */
    string: string;
    /**
     * ESPHome 1.14 (api v1.3) make int a signed value
     *
     * @generated from protobuf field: sint32 int_ = 5;
     */
    int: number;
    /**
     * @generated from protobuf field: repeated bool bool_array = 6 [packed = false];
     */
    boolArray: boolean[];
    /**
     * @generated from protobuf field: repeated sint32 int_array = 7 [packed = false];
     */
    intArray: number[];
    /**
     * @generated from protobuf field: repeated float float_array = 8 [packed = false];
     */
    floatArray: number[];
    /**
     * @generated from protobuf field: repeated string string_array = 9;
     */
    stringArray: string[];
}
/**
 * @generated from protobuf message ExecuteServiceRequest
 */
export interface ExecuteServiceRequest {
    /**
     * @generated from protobuf field: fixed32 key = 1;
     */
    key: number;
    /**
     * @generated from protobuf field: repeated ExecuteServiceArgument args = 2;
     */
    args: ExecuteServiceArgument[];
}
/**
 * ==================== CAMERA ====================
 *
 * @generated from protobuf message ListEntitiesCameraResponse
 */
export interface ListEntitiesCameraResponse {
    /**
     * @generated from protobuf field: string object_id = 1;
     */
    objectId: string;
    /**
     * @generated from protobuf field: fixed32 key = 2;
     */
    key: number;
    /**
     * @generated from protobuf field: string name = 3;
     */
    name: string;
    /**
     * @generated from protobuf field: string unique_id = 4;
     */
    uniqueId: string;
    /**
     * @generated from protobuf field: bool disabled_by_default = 5;
     */
    disabledByDefault: boolean;
    /**
     * @generated from protobuf field: string icon = 6;
     */
    icon: string;
    /**
     * @generated from protobuf field: EntityCategory entity_category = 7;
     */
    entityCategory: EntityCategory;
}
/**
 * @generated from protobuf message CameraImageResponse
 */
export interface CameraImageResponse {
    /**
     * @generated from protobuf field: fixed32 key = 1;
     */
    key: number;
    /**
     * @generated from protobuf field: bytes data = 2;
     */
    data: Uint8Array;
    /**
     * @generated from protobuf field: bool done = 3;
     */
    done: boolean;
}
/**
 * @generated from protobuf message CameraImageRequest
 */
export interface CameraImageRequest {
    /**
     * @generated from protobuf field: bool single = 1;
     */
    single: boolean;
    /**
     * @generated from protobuf field: bool stream = 2;
     */
    stream: boolean;
}
/**
 * @generated from protobuf message ListEntitiesClimateResponse
 */
export interface ListEntitiesClimateResponse {
    /**
     * @generated from protobuf field: string object_id = 1;
     */
    objectId: string;
    /**
     * @generated from protobuf field: fixed32 key = 2;
     */
    key: number;
    /**
     * @generated from protobuf field: string name = 3;
     */
    name: string;
    /**
     * @generated from protobuf field: string unique_id = 4;
     */
    uniqueId: string;
    /**
     * @generated from protobuf field: bool supports_current_temperature = 5;
     */
    supportsCurrentTemperature: boolean;
    /**
     * @generated from protobuf field: bool supports_two_point_target_temperature = 6;
     */
    supportsTwoPointTargetTemperature: boolean;
    /**
     * @generated from protobuf field: repeated ClimateMode supported_modes = 7;
     */
    supportedModes: ClimateMode[];
    /**
     * @generated from protobuf field: float visual_min_temperature = 8;
     */
    visualMinTemperature: number;
    /**
     * @generated from protobuf field: float visual_max_temperature = 9;
     */
    visualMaxTemperature: number;
    /**
     * @generated from protobuf field: float visual_target_temperature_step = 10;
     */
    visualTargetTemperatureStep: number;
    /**
     * for older peer versions - in new system this
     * is if CLIMATE_PRESET_AWAY exists is supported_presets
     *
     * @generated from protobuf field: bool legacy_supports_away = 11;
     */
    legacySupportsAway: boolean;
    /**
     * @generated from protobuf field: bool supports_action = 12;
     */
    supportsAction: boolean;
    /**
     * @generated from protobuf field: repeated ClimateFanMode supported_fan_modes = 13;
     */
    supportedFanModes: ClimateFanMode[];
    /**
     * @generated from protobuf field: repeated ClimateSwingMode supported_swing_modes = 14;
     */
    supportedSwingModes: ClimateSwingMode[];
    /**
     * @generated from protobuf field: repeated string supported_custom_fan_modes = 15;
     */
    supportedCustomFanModes: string[];
    /**
     * @generated from protobuf field: repeated ClimatePreset supported_presets = 16;
     */
    supportedPresets: ClimatePreset[];
    /**
     * @generated from protobuf field: repeated string supported_custom_presets = 17;
     */
    supportedCustomPresets: string[];
    /**
     * @generated from protobuf field: bool disabled_by_default = 18;
     */
    disabledByDefault: boolean;
    /**
     * @generated from protobuf field: string icon = 19;
     */
    icon: string;
    /**
     * @generated from protobuf field: EntityCategory entity_category = 20;
     */
    entityCategory: EntityCategory;
    /**
     * @generated from protobuf field: float visual_current_temperature_step = 21;
     */
    visualCurrentTemperatureStep: number;
}
/**
 * @generated from protobuf message ClimateStateResponse
 */
export interface ClimateStateResponse {
    /**
     * @generated from protobuf field: fixed32 key = 1;
     */
    key: number;
    /**
     * @generated from protobuf field: ClimateMode mode = 2;
     */
    mode: ClimateMode;
    /**
     * @generated from protobuf field: float current_temperature = 3;
     */
    currentTemperature: number;
    /**
     * @generated from protobuf field: float target_temperature = 4;
     */
    targetTemperature: number;
    /**
     * @generated from protobuf field: float target_temperature_low = 5;
     */
    targetTemperatureLow: number;
    /**
     * @generated from protobuf field: float target_temperature_high = 6;
     */
    targetTemperatureHigh: number;
    /**
     * For older peers, equal to preset == CLIMATE_PRESET_AWAY
     *
     * @generated from protobuf field: bool legacy_away = 7;
     */
    legacyAway: boolean;
    /**
     * @generated from protobuf field: ClimateAction action = 8;
     */
    action: ClimateAction;
    /**
     * @generated from protobuf field: ClimateFanMode fan_mode = 9;
     */
    fanMode: ClimateFanMode;
    /**
     * @generated from protobuf field: ClimateSwingMode swing_mode = 10;
     */
    swingMode: ClimateSwingMode;
    /**
     * @generated from protobuf field: string custom_fan_mode = 11;
     */
    customFanMode: string;
    /**
     * @generated from protobuf field: ClimatePreset preset = 12;
     */
    preset: ClimatePreset;
    /**
     * @generated from protobuf field: string custom_preset = 13;
     */
    customPreset: string;
}
/**
 * @generated from protobuf message ClimateCommandRequest
 */
export interface ClimateCommandRequest {
    /**
     * @generated from protobuf field: fixed32 key = 1;
     */
    key: number;
    /**
     * @generated from protobuf field: bool has_mode = 2;
     */
    hasMode: boolean;
    /**
     * @generated from protobuf field: ClimateMode mode = 3;
     */
    mode: ClimateMode;
    /**
     * @generated from protobuf field: bool has_target_temperature = 4;
     */
    hasTargetTemperature: boolean;
    /**
     * @generated from protobuf field: float target_temperature = 5;
     */
    targetTemperature: number;
    /**
     * @generated from protobuf field: bool has_target_temperature_low = 6;
     */
    hasTargetTemperatureLow: boolean;
    /**
     * @generated from protobuf field: float target_temperature_low = 7;
     */
    targetTemperatureLow: number;
    /**
     * @generated from protobuf field: bool has_target_temperature_high = 8;
     */
    hasTargetTemperatureHigh: boolean;
    /**
     * @generated from protobuf field: float target_temperature_high = 9;
     */
    targetTemperatureHigh: number;
    /**
     * legacy, for older peers, newer ones should use CLIMATE_PRESET_AWAY in preset
     *
     * @generated from protobuf field: bool has_legacy_away = 10;
     */
    hasLegacyAway: boolean;
    /**
     * @generated from protobuf field: bool legacy_away = 11;
     */
    legacyAway: boolean;
    /**
     * @generated from protobuf field: bool has_fan_mode = 12;
     */
    hasFanMode: boolean;
    /**
     * @generated from protobuf field: ClimateFanMode fan_mode = 13;
     */
    fanMode: ClimateFanMode;
    /**
     * @generated from protobuf field: bool has_swing_mode = 14;
     */
    hasSwingMode: boolean;
    /**
     * @generated from protobuf field: ClimateSwingMode swing_mode = 15;
     */
    swingMode: ClimateSwingMode;
    /**
     * @generated from protobuf field: bool has_custom_fan_mode = 16;
     */
    hasCustomFanMode: boolean;
    /**
     * @generated from protobuf field: string custom_fan_mode = 17;
     */
    customFanMode: string;
    /**
     * @generated from protobuf field: bool has_preset = 18;
     */
    hasPreset: boolean;
    /**
     * @generated from protobuf field: ClimatePreset preset = 19;
     */
    preset: ClimatePreset;
    /**
     * @generated from protobuf field: bool has_custom_preset = 20;
     */
    hasCustomPreset: boolean;
    /**
     * @generated from protobuf field: string custom_preset = 21;
     */
    customPreset: string;
}
/**
 * @generated from protobuf message ListEntitiesNumberResponse
 */
export interface ListEntitiesNumberResponse {
    /**
     * @generated from protobuf field: string object_id = 1;
     */
    objectId: string;
    /**
     * @generated from protobuf field: fixed32 key = 2;
     */
    key: number;
    /**
     * @generated from protobuf field: string name = 3;
     */
    name: string;
    /**
     * @generated from protobuf field: string unique_id = 4;
     */
    uniqueId: string;
    /**
     * @generated from protobuf field: string icon = 5;
     */
    icon: string;
    /**
     * @generated from protobuf field: float min_value = 6;
     */
    minValue: number;
    /**
     * @generated from protobuf field: float max_value = 7;
     */
    maxValue: number;
    /**
     * @generated from protobuf field: float step = 8;
     */
    step: number;
    /**
     * @generated from protobuf field: bool disabled_by_default = 9;
     */
    disabledByDefault: boolean;
    /**
     * @generated from protobuf field: EntityCategory entity_category = 10;
     */
    entityCategory: EntityCategory;
    /**
     * @generated from protobuf field: string unit_of_measurement = 11;
     */
    unitOfMeasurement: string;
    /**
     * @generated from protobuf field: NumberMode mode = 12;
     */
    mode: NumberMode;
    /**
     * @generated from protobuf field: string device_class = 13;
     */
    deviceClass: string;
}
/**
 * @generated from protobuf message NumberStateResponse
 */
export interface NumberStateResponse {
    /**
     * @generated from protobuf field: fixed32 key = 1;
     */
    key: number;
    /**
     * @generated from protobuf field: float state = 2;
     */
    state: number;
    /**
     * If the number does not have a valid state yet.
     * Equivalent to `!obj->has_state()` - inverse logic to make state packets smaller
     *
     * @generated from protobuf field: bool missing_state = 3;
     */
    missingState: boolean;
}
/**
 * @generated from protobuf message NumberCommandRequest
 */
export interface NumberCommandRequest {
    /**
     * @generated from protobuf field: fixed32 key = 1;
     */
    key: number;
    /**
     * @generated from protobuf field: float state = 2;
     */
    state: number;
}
/**
 * ==================== SELECT ====================
 *
 * @generated from protobuf message ListEntitiesSelectResponse
 */
export interface ListEntitiesSelectResponse {
    /**
     * @generated from protobuf field: string object_id = 1;
     */
    objectId: string;
    /**
     * @generated from protobuf field: fixed32 key = 2;
     */
    key: number;
    /**
     * @generated from protobuf field: string name = 3;
     */
    name: string;
    /**
     * @generated from protobuf field: string unique_id = 4;
     */
    uniqueId: string;
    /**
     * @generated from protobuf field: string icon = 5;
     */
    icon: string;
    /**
     * @generated from protobuf field: repeated string options = 6;
     */
    options: string[];
    /**
     * @generated from protobuf field: bool disabled_by_default = 7;
     */
    disabledByDefault: boolean;
    /**
     * @generated from protobuf field: EntityCategory entity_category = 8;
     */
    entityCategory: EntityCategory;
}
/**
 * @generated from protobuf message SelectStateResponse
 */
export interface SelectStateResponse {
    /**
     * @generated from protobuf field: fixed32 key = 1;
     */
    key: number;
    /**
     * @generated from protobuf field: string state = 2;
     */
    state: string;
    /**
     * If the select does not have a valid state yet.
     * Equivalent to `!obj->has_state()` - inverse logic to make state packets smaller
     *
     * @generated from protobuf field: bool missing_state = 3;
     */
    missingState: boolean;
}
/**
 * @generated from protobuf message SelectCommandRequest
 */
export interface SelectCommandRequest {
    /**
     * @generated from protobuf field: fixed32 key = 1;
     */
    key: number;
    /**
     * @generated from protobuf field: string state = 2;
     */
    state: string;
}
/**
 * ==================== SIREN ====================
 *
 * @generated from protobuf message ListEntitiesSirenResponse
 */
export interface ListEntitiesSirenResponse {
    /**
     * @generated from protobuf field: string object_id = 1;
     */
    objectId: string;
    /**
     * @generated from protobuf field: fixed32 key = 2;
     */
    key: number;
    /**
     * @generated from protobuf field: string name = 3;
     */
    name: string;
    /**
     * @generated from protobuf field: string unique_id = 4;
     */
    uniqueId: string;
    /**
     * @generated from protobuf field: string icon = 5;
     */
    icon: string;
    /**
     * @generated from protobuf field: bool disabled_by_default = 6;
     */
    disabledByDefault: boolean;
    /**
     * @generated from protobuf field: repeated string tones = 7;
     */
    tones: string[];
    /**
     * @generated from protobuf field: bool supports_duration = 8;
     */
    supportsDuration: boolean;
    /**
     * @generated from protobuf field: bool supports_volume = 9;
     */
    supportsVolume: boolean;
    /**
     * @generated from protobuf field: EntityCategory entity_category = 10;
     */
    entityCategory: EntityCategory;
}
/**
 * @generated from protobuf message SirenStateResponse
 */
export interface SirenStateResponse {
    /**
     * @generated from protobuf field: fixed32 key = 1;
     */
    key: number;
    /**
     * @generated from protobuf field: bool state = 2;
     */
    state: boolean;
}
/**
 * @generated from protobuf message SirenCommandRequest
 */
export interface SirenCommandRequest {
    /**
     * @generated from protobuf field: fixed32 key = 1;
     */
    key: number;
    /**
     * @generated from protobuf field: bool has_state = 2;
     */
    hasState: boolean;
    /**
     * @generated from protobuf field: bool state = 3;
     */
    state: boolean;
    /**
     * @generated from protobuf field: bool has_tone = 4;
     */
    hasTone: boolean;
    /**
     * @generated from protobuf field: string tone = 5;
     */
    tone: string;
    /**
     * @generated from protobuf field: bool has_duration = 6;
     */
    hasDuration: boolean;
    /**
     * @generated from protobuf field: uint32 duration = 7;
     */
    duration: number;
    /**
     * @generated from protobuf field: bool has_volume = 8;
     */
    hasVolume: boolean;
    /**
     * @generated from protobuf field: float volume = 9;
     */
    volume: number;
}
/**
 * @generated from protobuf message ListEntitiesLockResponse
 */
export interface ListEntitiesLockResponse {
    /**
     * @generated from protobuf field: string object_id = 1;
     */
    objectId: string;
    /**
     * @generated from protobuf field: fixed32 key = 2;
     */
    key: number;
    /**
     * @generated from protobuf field: string name = 3;
     */
    name: string;
    /**
     * @generated from protobuf field: string unique_id = 4;
     */
    uniqueId: string;
    /**
     * @generated from protobuf field: string icon = 5;
     */
    icon: string;
    /**
     * @generated from protobuf field: bool disabled_by_default = 6;
     */
    disabledByDefault: boolean;
    /**
     * @generated from protobuf field: EntityCategory entity_category = 7;
     */
    entityCategory: EntityCategory;
    /**
     * @generated from protobuf field: bool assumed_state = 8;
     */
    assumedState: boolean;
    /**
     * @generated from protobuf field: bool supports_open = 9;
     */
    supportsOpen: boolean;
    /**
     * @generated from protobuf field: bool requires_code = 10;
     */
    requiresCode: boolean;
    /**
     * @generated from protobuf field: string code_format = 11;
     */
    codeFormat: string;
}
/**
 * @generated from protobuf message LockStateResponse
 */
export interface LockStateResponse {
    /**
     * @generated from protobuf field: fixed32 key = 1;
     */
    key: number;
    /**
     * @generated from protobuf field: LockState state = 2;
     */
    state: LockState;
}
/**
 * @generated from protobuf message LockCommandRequest
 */
export interface LockCommandRequest {
    /**
     * @generated from protobuf field: fixed32 key = 1;
     */
    key: number;
    /**
     * @generated from protobuf field: LockCommand command = 2;
     */
    command: LockCommand;
    /**
     * @generated from protobuf field: bool has_code = 3;
     */
    hasCode: boolean;
    /**
     * @generated from protobuf field: string code = 4;
     */
    code: string;
}
/**
 * ==================== BUTTON ====================
 *
 * @generated from protobuf message ListEntitiesButtonResponse
 */
export interface ListEntitiesButtonResponse {
    /**
     * @generated from protobuf field: string object_id = 1;
     */
    objectId: string;
    /**
     * @generated from protobuf field: fixed32 key = 2;
     */
    key: number;
    /**
     * @generated from protobuf field: string name = 3;
     */
    name: string;
    /**
     * @generated from protobuf field: string unique_id = 4;
     */
    uniqueId: string;
    /**
     * @generated from protobuf field: string icon = 5;
     */
    icon: string;
    /**
     * @generated from protobuf field: bool disabled_by_default = 6;
     */
    disabledByDefault: boolean;
    /**
     * @generated from protobuf field: EntityCategory entity_category = 7;
     */
    entityCategory: EntityCategory;
    /**
     * @generated from protobuf field: string device_class = 8;
     */
    deviceClass: string;
}
/**
 * @generated from protobuf message ButtonCommandRequest
 */
export interface ButtonCommandRequest {
    /**
     * @generated from protobuf field: fixed32 key = 1;
     */
    key: number;
}
/**
 * @generated from protobuf message ListEntitiesMediaPlayerResponse
 */
export interface ListEntitiesMediaPlayerResponse {
    /**
     * @generated from protobuf field: string object_id = 1;
     */
    objectId: string;
    /**
     * @generated from protobuf field: fixed32 key = 2;
     */
    key: number;
    /**
     * @generated from protobuf field: string name = 3;
     */
    name: string;
    /**
     * @generated from protobuf field: string unique_id = 4;
     */
    uniqueId: string;
    /**
     * @generated from protobuf field: string icon = 5;
     */
    icon: string;
    /**
     * @generated from protobuf field: bool disabled_by_default = 6;
     */
    disabledByDefault: boolean;
    /**
     * @generated from protobuf field: EntityCategory entity_category = 7;
     */
    entityCategory: EntityCategory;
    /**
     * @generated from protobuf field: bool supports_pause = 8;
     */
    supportsPause: boolean;
}
/**
 * @generated from protobuf message MediaPlayerStateResponse
 */
export interface MediaPlayerStateResponse {
    /**
     * @generated from protobuf field: fixed32 key = 1;
     */
    key: number;
    /**
     * @generated from protobuf field: MediaPlayerState state = 2;
     */
    state: MediaPlayerState;
    /**
     * @generated from protobuf field: float volume = 3;
     */
    volume: number;
    /**
     * @generated from protobuf field: bool muted = 4;
     */
    muted: boolean;
}
/**
 * @generated from protobuf message MediaPlayerCommandRequest
 */
export interface MediaPlayerCommandRequest {
    /**
     * @generated from protobuf field: fixed32 key = 1;
     */
    key: number;
    /**
     * @generated from protobuf field: bool has_command = 2;
     */
    hasCommand: boolean;
    /**
     * @generated from protobuf field: MediaPlayerCommand command = 3;
     */
    command: MediaPlayerCommand;
    /**
     * @generated from protobuf field: bool has_volume = 4;
     */
    hasVolume: boolean;
    /**
     * @generated from protobuf field: float volume = 5;
     */
    volume: number;
    /**
     * @generated from protobuf field: bool has_media_url = 6;
     */
    hasMediaUrl: boolean;
    /**
     * @generated from protobuf field: string media_url = 7;
     */
    mediaUrl: string;
}
/**
 * ==================== BLUETOOTH ====================
 *
 * @generated from protobuf message SubscribeBluetoothLEAdvertisementsRequest
 */
export interface SubscribeBluetoothLEAdvertisementsRequest {
    /**
     * @generated from protobuf field: int32 flags = 1;
     */
    flags: number;
}
/**
 * @generated from protobuf message BluetoothServiceData
 */
export interface BluetoothServiceData {
    /**
     * @generated from protobuf field: string uuid = 1;
     */
    uuid: string;
    /**
     * @generated from protobuf field: repeated uint32 legacy_data = 2 [packed = true];
     */
    legacyData: number[]; // Removed in api version 1.7
    /**
     * @generated from protobuf field: bytes data = 3;
     */
    data: Uint8Array; // Added in api version 1.7
}
/**
 * @generated from protobuf message BluetoothLEAdvertisementResponse
 */
export interface BluetoothLEAdvertisementResponse {
    /**
     * @generated from protobuf field: uint64 address = 1;
     */
    address: bigint;
    /**
     * @generated from protobuf field: bytes name = 2;
     */
    name: Uint8Array;
    /**
     * @generated from protobuf field: sint32 rssi = 3;
     */
    rssi: number;
    /**
     * @generated from protobuf field: repeated string service_uuids = 4;
     */
    serviceUuids: string[];
    /**
     * @generated from protobuf field: repeated BluetoothServiceData service_data = 5;
     */
    serviceData: BluetoothServiceData[];
    /**
     * @generated from protobuf field: repeated BluetoothServiceData manufacturer_data = 6;
     */
    manufacturerData: BluetoothServiceData[];
    /**
     * @generated from protobuf field: uint32 address_type = 7;
     */
    addressType: number;
}
/**
 * @generated from protobuf message BluetoothLERawAdvertisement
 */
export interface BluetoothLERawAdvertisement {
    /**
     * @generated from protobuf field: uint64 address = 1;
     */
    address: bigint;
    /**
     * @generated from protobuf field: sint32 rssi = 2;
     */
    rssi: number;
    /**
     * @generated from protobuf field: uint32 address_type = 3;
     */
    addressType: number;
    /**
     * @generated from protobuf field: bytes data = 4;
     */
    data: Uint8Array;
}
/**
 * @generated from protobuf message BluetoothLERawAdvertisementsResponse
 */
export interface BluetoothLERawAdvertisementsResponse {
    /**
     * @generated from protobuf field: repeated BluetoothLERawAdvertisement advertisements = 1;
     */
    advertisements: BluetoothLERawAdvertisement[];
}
/**
 * @generated from protobuf message BluetoothDeviceRequest
 */
export interface BluetoothDeviceRequest {
    /**
     * @generated from protobuf field: uint64 address = 1;
     */
    address: bigint;
    /**
     * @generated from protobuf field: BluetoothDeviceRequestType request_type = 2;
     */
    requestType: BluetoothDeviceRequestType;
    /**
     * @generated from protobuf field: bool has_address_type = 3;
     */
    hasAddressType: boolean;
    /**
     * @generated from protobuf field: uint32 address_type = 4;
     */
    addressType: number;
}
/**
 * @generated from protobuf message BluetoothDeviceConnectionResponse
 */
export interface BluetoothDeviceConnectionResponse {
    /**
     * @generated from protobuf field: uint64 address = 1;
     */
    address: bigint;
    /**
     * @generated from protobuf field: bool connected = 2;
     */
    connected: boolean;
    /**
     * @generated from protobuf field: uint32 mtu = 3;
     */
    mtu: number;
    /**
     * @generated from protobuf field: int32 error = 4;
     */
    error: number;
}
/**
 * @generated from protobuf message BluetoothGATTGetServicesRequest
 */
export interface BluetoothGATTGetServicesRequest {
    /**
     * @generated from protobuf field: uint64 address = 1;
     */
    address: bigint;
}
/**
 * @generated from protobuf message BluetoothGATTDescriptor
 */
export interface BluetoothGATTDescriptor {
    /**
     * @generated from protobuf field: repeated uint64 uuid = 1;
     */
    uuid: bigint[];
    /**
     * @generated from protobuf field: uint32 handle = 2;
     */
    handle: number;
}
/**
 * @generated from protobuf message BluetoothGATTCharacteristic
 */
export interface BluetoothGATTCharacteristic {
    /**
     * @generated from protobuf field: repeated uint64 uuid = 1;
     */
    uuid: bigint[];
    /**
     * @generated from protobuf field: uint32 handle = 2;
     */
    handle: number;
    /**
     * @generated from protobuf field: uint32 properties = 3;
     */
    properties: number;
    /**
     * @generated from protobuf field: repeated BluetoothGATTDescriptor descriptors = 4;
     */
    descriptors: BluetoothGATTDescriptor[];
}
/**
 * @generated from protobuf message BluetoothGATTService
 */
export interface BluetoothGATTService {
    /**
     * @generated from protobuf field: repeated uint64 uuid = 1;
     */
    uuid: bigint[];
    /**
     * @generated from protobuf field: uint32 handle = 2;
     */
    handle: number;
    /**
     * @generated from protobuf field: repeated BluetoothGATTCharacteristic characteristics = 3;
     */
    characteristics: BluetoothGATTCharacteristic[];
}
/**
 * @generated from protobuf message BluetoothGATTGetServicesResponse
 */
export interface BluetoothGATTGetServicesResponse {
    /**
     * @generated from protobuf field: uint64 address = 1;
     */
    address: bigint;
    /**
     * @generated from protobuf field: repeated BluetoothGATTService services = 2;
     */
    services: BluetoothGATTService[];
}
/**
 * @generated from protobuf message BluetoothGATTGetServicesDoneResponse
 */
export interface BluetoothGATTGetServicesDoneResponse {
    /**
     * @generated from protobuf field: uint64 address = 1;
     */
    address: bigint;
}
/**
 * @generated from protobuf message BluetoothGATTReadRequest
 */
export interface BluetoothGATTReadRequest {
    /**
     * @generated from protobuf field: uint64 address = 1;
     */
    address: bigint;
    /**
     * @generated from protobuf field: uint32 handle = 2;
     */
    handle: number;
}
/**
 * @generated from protobuf message BluetoothGATTReadResponse
 */
export interface BluetoothGATTReadResponse {
    /**
     * @generated from protobuf field: uint64 address = 1;
     */
    address: bigint;
    /**
     * @generated from protobuf field: uint32 handle = 2;
     */
    handle: number;
    /**
     * @generated from protobuf field: bytes data = 3;
     */
    data: Uint8Array;
}
/**
 * @generated from protobuf message BluetoothGATTWriteRequest
 */
export interface BluetoothGATTWriteRequest {
    /**
     * @generated from protobuf field: uint64 address = 1;
     */
    address: bigint;
    /**
     * @generated from protobuf field: uint32 handle = 2;
     */
    handle: number;
    /**
     * @generated from protobuf field: bool response = 3;
     */
    response: boolean;
    /**
     * @generated from protobuf field: bytes data = 4;
     */
    data: Uint8Array;
}
/**
 * @generated from protobuf message BluetoothGATTReadDescriptorRequest
 */
export interface BluetoothGATTReadDescriptorRequest {
    /**
     * @generated from protobuf field: uint64 address = 1;
     */
    address: bigint;
    /**
     * @generated from protobuf field: uint32 handle = 2;
     */
    handle: number;
}
/**
 * @generated from protobuf message BluetoothGATTWriteDescriptorRequest
 */
export interface BluetoothGATTWriteDescriptorRequest {
    /**
     * @generated from protobuf field: uint64 address = 1;
     */
    address: bigint;
    /**
     * @generated from protobuf field: uint32 handle = 2;
     */
    handle: number;
    /**
     * @generated from protobuf field: bytes data = 3;
     */
    data: Uint8Array;
}
/**
 * @generated from protobuf message BluetoothGATTNotifyRequest
 */
export interface BluetoothGATTNotifyRequest {
    /**
     * @generated from protobuf field: uint64 address = 1;
     */
    address: bigint;
    /**
     * @generated from protobuf field: uint32 handle = 2;
     */
    handle: number;
    /**
     * @generated from protobuf field: bool enable = 3;
     */
    enable: boolean;
}
/**
 * @generated from protobuf message BluetoothGATTNotifyDataResponse
 */
export interface BluetoothGATTNotifyDataResponse {
    /**
     * @generated from protobuf field: uint64 address = 1;
     */
    address: bigint;
    /**
     * @generated from protobuf field: uint32 handle = 2;
     */
    handle: number;
    /**
     * @generated from protobuf field: bytes data = 3;
     */
    data: Uint8Array;
}
/**
 * @generated from protobuf message SubscribeBluetoothConnectionsFreeRequest
 */
export interface SubscribeBluetoothConnectionsFreeRequest {
}
/**
 * @generated from protobuf message BluetoothConnectionsFreeResponse
 */
export interface BluetoothConnectionsFreeResponse {
    /**
     * @generated from protobuf field: uint32 free = 1;
     */
    free: number;
    /**
     * @generated from protobuf field: uint32 limit = 2;
     */
    limit: number;
}
/**
 * @generated from protobuf message BluetoothGATTErrorResponse
 */
export interface BluetoothGATTErrorResponse {
    /**
     * @generated from protobuf field: uint64 address = 1;
     */
    address: bigint;
    /**
     * @generated from protobuf field: uint32 handle = 2;
     */
    handle: number;
    /**
     * @generated from protobuf field: int32 error = 3;
     */
    error: number;
}
/**
 * @generated from protobuf message BluetoothGATTWriteResponse
 */
export interface BluetoothGATTWriteResponse {
    /**
     * @generated from protobuf field: uint64 address = 1;
     */
    address: bigint;
    /**
     * @generated from protobuf field: uint32 handle = 2;
     */
    handle: number;
}
/**
 * @generated from protobuf message BluetoothGATTNotifyResponse
 */
export interface BluetoothGATTNotifyResponse {
    /**
     * @generated from protobuf field: uint64 address = 1;
     */
    address: bigint;
    /**
     * @generated from protobuf field: uint32 handle = 2;
     */
    handle: number;
}
/**
 * @generated from protobuf message BluetoothDevicePairingResponse
 */
export interface BluetoothDevicePairingResponse {
    /**
     * @generated from protobuf field: uint64 address = 1;
     */
    address: bigint;
    /**
     * @generated from protobuf field: bool paired = 2;
     */
    paired: boolean;
    /**
     * @generated from protobuf field: int32 error = 3;
     */
    error: number;
}
/**
 * @generated from protobuf message BluetoothDeviceUnpairingResponse
 */
export interface BluetoothDeviceUnpairingResponse {
    /**
     * @generated from protobuf field: uint64 address = 1;
     */
    address: bigint;
    /**
     * @generated from protobuf field: bool success = 2;
     */
    success: boolean;
    /**
     * @generated from protobuf field: int32 error = 3;
     */
    error: number;
}
/**
 * @generated from protobuf message UnsubscribeBluetoothLEAdvertisementsRequest
 */
export interface UnsubscribeBluetoothLEAdvertisementsRequest {
}
/**
 * @generated from protobuf message BluetoothDeviceClearCacheResponse
 */
export interface BluetoothDeviceClearCacheResponse {
    /**
     * @generated from protobuf field: uint64 address = 1;
     */
    address: bigint;
    /**
     * @generated from protobuf field: bool success = 2;
     */
    success: boolean;
    /**
     * @generated from protobuf field: int32 error = 3;
     */
    error: number;
}
/**
 * ==================== VOICE ASSISTANT ====================
 *
 * @generated from protobuf message SubscribeVoiceAssistantRequest
 */
export interface SubscribeVoiceAssistantRequest {
    /**
     * @generated from protobuf field: bool subscribe = 1;
     */
    subscribe: boolean;
}
/**
 * @generated from protobuf message VoiceAssistantRequest
 */
export interface VoiceAssistantRequest {
    /**
     * @generated from protobuf field: bool start = 1;
     */
    start: boolean;
    /**
     * @generated from protobuf field: string conversation_id = 2;
     */
    conversationId: string;
    /**
     * @generated from protobuf field: bool use_vad = 3;
     */
    useVad: boolean;
}
/**
 * @generated from protobuf message VoiceAssistantResponse
 */
export interface VoiceAssistantResponse {
    /**
     * @generated from protobuf field: uint32 port = 1;
     */
    port: number;
    /**
     * @generated from protobuf field: bool error = 2;
     */
    error: boolean;
}
/**
 * @generated from protobuf message VoiceAssistantEventData
 */
export interface VoiceAssistantEventData {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: string value = 2;
     */
    value: string;
}
/**
 * @generated from protobuf message VoiceAssistantEventResponse
 */
export interface VoiceAssistantEventResponse {
    /**
     * @generated from protobuf field: VoiceAssistantEvent event_type = 1;
     */
    eventType: VoiceAssistantEvent;
    /**
     * @generated from protobuf field: repeated VoiceAssistantEventData data = 2;
     */
    data: VoiceAssistantEventData[];
}
/**
 * @generated from protobuf message ListEntitiesAlarmControlPanelResponse
 */
export interface ListEntitiesAlarmControlPanelResponse {
    /**
     * @generated from protobuf field: string object_id = 1;
     */
    objectId: string;
    /**
     * @generated from protobuf field: fixed32 key = 2;
     */
    key: number;
    /**
     * @generated from protobuf field: string name = 3;
     */
    name: string;
    /**
     * @generated from protobuf field: string unique_id = 4;
     */
    uniqueId: string;
    /**
     * @generated from protobuf field: string icon = 5;
     */
    icon: string;
    /**
     * @generated from protobuf field: bool disabled_by_default = 6;
     */
    disabledByDefault: boolean;
    /**
     * @generated from protobuf field: EntityCategory entity_category = 7;
     */
    entityCategory: EntityCategory;
    /**
     * @generated from protobuf field: uint32 supported_features = 8;
     */
    supportedFeatures: number;
    /**
     * @generated from protobuf field: bool requires_code = 9;
     */
    requiresCode: boolean;
    /**
     * @generated from protobuf field: bool requires_code_to_arm = 10;
     */
    requiresCodeToArm: boolean;
}
/**
 * @generated from protobuf message AlarmControlPanelStateResponse
 */
export interface AlarmControlPanelStateResponse {
    /**
     * @generated from protobuf field: fixed32 key = 1;
     */
    key: number;
    /**
     * @generated from protobuf field: AlarmControlPanelState state = 2;
     */
    state: AlarmControlPanelState;
}
/**
 * @generated from protobuf message AlarmControlPanelCommandRequest
 */
export interface AlarmControlPanelCommandRequest {
    /**
     * @generated from protobuf field: fixed32 key = 1;
     */
    key: number;
    /**
     * @generated from protobuf field: AlarmControlPanelStateCommand command = 2;
     */
    command: AlarmControlPanelStateCommand;
    /**
     * @generated from protobuf field: string code = 3;
     */
    code: string;
}
// ==================== COMMON =====================

/**
 * @generated from protobuf enum EntityCategory
 */
export enum EntityCategory {
    /**
     * @generated from protobuf enum value: ENTITY_CATEGORY_NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: ENTITY_CATEGORY_CONFIG = 1;
     */
    CONFIG = 1,
    /**
     * @generated from protobuf enum value: ENTITY_CATEGORY_DIAGNOSTIC = 2;
     */
    DIAGNOSTIC = 2
}
/**
 * @generated from protobuf enum LegacyCoverState
 */
export enum LegacyCoverState {
    /**
     * @generated from protobuf enum value: LEGACY_COVER_STATE_OPEN = 0;
     */
    OPEN = 0,
    /**
     * @generated from protobuf enum value: LEGACY_COVER_STATE_CLOSED = 1;
     */
    CLOSED = 1
}
/**
 * @generated from protobuf enum CoverOperation
 */
export enum CoverOperation {
    /**
     * @generated from protobuf enum value: COVER_OPERATION_IDLE = 0;
     */
    IDLE = 0,
    /**
     * @generated from protobuf enum value: COVER_OPERATION_IS_OPENING = 1;
     */
    IS_OPENING = 1,
    /**
     * @generated from protobuf enum value: COVER_OPERATION_IS_CLOSING = 2;
     */
    IS_CLOSING = 2
}
/**
 * @generated from protobuf enum LegacyCoverCommand
 */
export enum LegacyCoverCommand {
    /**
     * @generated from protobuf enum value: LEGACY_COVER_COMMAND_OPEN = 0;
     */
    OPEN = 0,
    /**
     * @generated from protobuf enum value: LEGACY_COVER_COMMAND_CLOSE = 1;
     */
    CLOSE = 1,
    /**
     * @generated from protobuf enum value: LEGACY_COVER_COMMAND_STOP = 2;
     */
    STOP = 2
}
/**
 * @generated from protobuf enum FanSpeed
 */
export enum FanSpeed {
    /**
     * @generated from protobuf enum value: FAN_SPEED_LOW = 0;
     */
    LOW = 0,
    /**
     * @generated from protobuf enum value: FAN_SPEED_MEDIUM = 1;
     */
    MEDIUM = 1,
    /**
     * @generated from protobuf enum value: FAN_SPEED_HIGH = 2;
     */
    HIGH = 2
}
/**
 * @generated from protobuf enum FanDirection
 */
export enum FanDirection {
    /**
     * @generated from protobuf enum value: FAN_DIRECTION_FORWARD = 0;
     */
    FORWARD = 0,
    /**
     * @generated from protobuf enum value: FAN_DIRECTION_REVERSE = 1;
     */
    REVERSE = 1
}
/**
 * ==================== SENSOR ====================
 *
 * @generated from protobuf enum SensorStateClass
 */
export enum SensorStateClass {
    /**
     * @generated from protobuf enum value: STATE_CLASS_NONE = 0;
     */
    STATE_CLASS_NONE = 0,
    /**
     * @generated from protobuf enum value: STATE_CLASS_MEASUREMENT = 1;
     */
    STATE_CLASS_MEASUREMENT = 1,
    /**
     * @generated from protobuf enum value: STATE_CLASS_TOTAL_INCREASING = 2;
     */
    STATE_CLASS_TOTAL_INCREASING = 2,
    /**
     * @generated from protobuf enum value: STATE_CLASS_TOTAL = 3;
     */
    STATE_CLASS_TOTAL = 3
}
/**
 * @generated from protobuf enum SensorLastResetType
 */
export enum SensorLastResetType {
    /**
     * @generated from protobuf enum value: LAST_RESET_NONE = 0;
     */
    LAST_RESET_NONE = 0,
    /**
     * @generated from protobuf enum value: LAST_RESET_NEVER = 1;
     */
    LAST_RESET_NEVER = 1,
    /**
     * @generated from protobuf enum value: LAST_RESET_AUTO = 2;
     */
    LAST_RESET_AUTO = 2
}
/**
 * ==================== SUBSCRIBE LOGS ====================
 *
 * @generated from protobuf enum LogLevel
 */
export enum LogLevel {
    /**
     * @generated from protobuf enum value: LOG_LEVEL_NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: LOG_LEVEL_ERROR = 1;
     */
    ERROR = 1,
    /**
     * @generated from protobuf enum value: LOG_LEVEL_WARN = 2;
     */
    WARN = 2,
    /**
     * @generated from protobuf enum value: LOG_LEVEL_INFO = 3;
     */
    INFO = 3,
    /**
     * @generated from protobuf enum value: LOG_LEVEL_CONFIG = 4;
     */
    CONFIG = 4,
    /**
     * @generated from protobuf enum value: LOG_LEVEL_DEBUG = 5;
     */
    DEBUG = 5,
    /**
     * @generated from protobuf enum value: LOG_LEVEL_VERBOSE = 6;
     */
    VERBOSE = 6,
    /**
     * @generated from protobuf enum value: LOG_LEVEL_VERY_VERBOSE = 7;
     */
    VERY_VERBOSE = 7
}
/**
 * ==================== USER-DEFINES SERVICES ====================
 *
 * @generated from protobuf enum ServiceArgType
 */
export enum ServiceArgType {
    /**
     * @generated from protobuf enum value: SERVICE_ARG_TYPE_BOOL = 0;
     */
    BOOL = 0,
    /**
     * @generated from protobuf enum value: SERVICE_ARG_TYPE_INT = 1;
     */
    INT = 1,
    /**
     * @generated from protobuf enum value: SERVICE_ARG_TYPE_FLOAT = 2;
     */
    FLOAT = 2,
    /**
     * @generated from protobuf enum value: SERVICE_ARG_TYPE_STRING = 3;
     */
    STRING = 3,
    /**
     * @generated from protobuf enum value: SERVICE_ARG_TYPE_BOOL_ARRAY = 4;
     */
    BOOL_ARRAY = 4,
    /**
     * @generated from protobuf enum value: SERVICE_ARG_TYPE_INT_ARRAY = 5;
     */
    INT_ARRAY = 5,
    /**
     * @generated from protobuf enum value: SERVICE_ARG_TYPE_FLOAT_ARRAY = 6;
     */
    FLOAT_ARRAY = 6,
    /**
     * @generated from protobuf enum value: SERVICE_ARG_TYPE_STRING_ARRAY = 7;
     */
    STRING_ARRAY = 7
}
/**
 * ==================== CLIMATE ====================
 *
 * @generated from protobuf enum ClimateMode
 */
export enum ClimateMode {
    /**
     * @generated from protobuf enum value: CLIMATE_MODE_OFF = 0;
     */
    OFF = 0,
    /**
     * @generated from protobuf enum value: CLIMATE_MODE_HEAT_COOL = 1;
     */
    HEAT_COOL = 1,
    /**
     * @generated from protobuf enum value: CLIMATE_MODE_COOL = 2;
     */
    COOL = 2,
    /**
     * @generated from protobuf enum value: CLIMATE_MODE_HEAT = 3;
     */
    HEAT = 3,
    /**
     * @generated from protobuf enum value: CLIMATE_MODE_FAN_ONLY = 4;
     */
    FAN_ONLY = 4,
    /**
     * @generated from protobuf enum value: CLIMATE_MODE_DRY = 5;
     */
    DRY = 5,
    /**
     * @generated from protobuf enum value: CLIMATE_MODE_AUTO = 6;
     */
    AUTO = 6
}
/**
 * @generated from protobuf enum ClimateFanMode
 */
export enum ClimateFanMode {
    /**
     * @generated from protobuf enum value: CLIMATE_FAN_ON = 0;
     */
    CLIMATE_FAN_ON = 0,
    /**
     * @generated from protobuf enum value: CLIMATE_FAN_OFF = 1;
     */
    CLIMATE_FAN_OFF = 1,
    /**
     * @generated from protobuf enum value: CLIMATE_FAN_AUTO = 2;
     */
    CLIMATE_FAN_AUTO = 2,
    /**
     * @generated from protobuf enum value: CLIMATE_FAN_LOW = 3;
     */
    CLIMATE_FAN_LOW = 3,
    /**
     * @generated from protobuf enum value: CLIMATE_FAN_MEDIUM = 4;
     */
    CLIMATE_FAN_MEDIUM = 4,
    /**
     * @generated from protobuf enum value: CLIMATE_FAN_HIGH = 5;
     */
    CLIMATE_FAN_HIGH = 5,
    /**
     * @generated from protobuf enum value: CLIMATE_FAN_MIDDLE = 6;
     */
    CLIMATE_FAN_MIDDLE = 6,
    /**
     * @generated from protobuf enum value: CLIMATE_FAN_FOCUS = 7;
     */
    CLIMATE_FAN_FOCUS = 7,
    /**
     * @generated from protobuf enum value: CLIMATE_FAN_DIFFUSE = 8;
     */
    CLIMATE_FAN_DIFFUSE = 8,
    /**
     * @generated from protobuf enum value: CLIMATE_FAN_QUIET = 9;
     */
    CLIMATE_FAN_QUIET = 9
}
/**
 * @generated from protobuf enum ClimateSwingMode
 */
export enum ClimateSwingMode {
    /**
     * @generated from protobuf enum value: CLIMATE_SWING_OFF = 0;
     */
    CLIMATE_SWING_OFF = 0,
    /**
     * @generated from protobuf enum value: CLIMATE_SWING_BOTH = 1;
     */
    CLIMATE_SWING_BOTH = 1,
    /**
     * @generated from protobuf enum value: CLIMATE_SWING_VERTICAL = 2;
     */
    CLIMATE_SWING_VERTICAL = 2,
    /**
     * @generated from protobuf enum value: CLIMATE_SWING_HORIZONTAL = 3;
     */
    CLIMATE_SWING_HORIZONTAL = 3
}
/**
 * @generated from protobuf enum ClimateAction
 */
export enum ClimateAction {
    /**
     * @generated from protobuf enum value: CLIMATE_ACTION_OFF = 0;
     */
    OFF = 0,
    /**
     * values same as mode for readability
     *
     * @generated from protobuf enum value: CLIMATE_ACTION_COOLING = 2;
     */
    COOLING = 2,
    /**
     * @generated from protobuf enum value: CLIMATE_ACTION_HEATING = 3;
     */
    HEATING = 3,
    /**
     * @generated from protobuf enum value: CLIMATE_ACTION_IDLE = 4;
     */
    IDLE = 4,
    /**
     * @generated from protobuf enum value: CLIMATE_ACTION_DRYING = 5;
     */
    DRYING = 5,
    /**
     * @generated from protobuf enum value: CLIMATE_ACTION_FAN = 6;
     */
    FAN = 6
}
/**
 * @generated from protobuf enum ClimatePreset
 */
export enum ClimatePreset {
    /**
     * @generated from protobuf enum value: CLIMATE_PRESET_NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: CLIMATE_PRESET_HOME = 1;
     */
    HOME = 1,
    /**
     * @generated from protobuf enum value: CLIMATE_PRESET_AWAY = 2;
     */
    AWAY = 2,
    /**
     * @generated from protobuf enum value: CLIMATE_PRESET_BOOST = 3;
     */
    BOOST = 3,
    /**
     * @generated from protobuf enum value: CLIMATE_PRESET_COMFORT = 4;
     */
    COMFORT = 4,
    /**
     * @generated from protobuf enum value: CLIMATE_PRESET_ECO = 5;
     */
    ECO = 5,
    /**
     * @generated from protobuf enum value: CLIMATE_PRESET_SLEEP = 6;
     */
    SLEEP = 6,
    /**
     * @generated from protobuf enum value: CLIMATE_PRESET_ACTIVITY = 7;
     */
    ACTIVITY = 7
}
/**
 * ==================== NUMBER ====================
 *
 * @generated from protobuf enum NumberMode
 */
export enum NumberMode {
    /**
     * @generated from protobuf enum value: NUMBER_MODE_AUTO = 0;
     */
    AUTO = 0,
    /**
     * @generated from protobuf enum value: NUMBER_MODE_BOX = 1;
     */
    BOX = 1,
    /**
     * @generated from protobuf enum value: NUMBER_MODE_SLIDER = 2;
     */
    SLIDER = 2
}
/**
 * ==================== LOCK ====================
 *
 * @generated from protobuf enum LockState
 */
export enum LockState {
    /**
     * @generated from protobuf enum value: LOCK_STATE_NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: LOCK_STATE_LOCKED = 1;
     */
    LOCKED = 1,
    /**
     * @generated from protobuf enum value: LOCK_STATE_UNLOCKED = 2;
     */
    UNLOCKED = 2,
    /**
     * @generated from protobuf enum value: LOCK_STATE_JAMMED = 3;
     */
    JAMMED = 3,
    /**
     * @generated from protobuf enum value: LOCK_STATE_LOCKING = 4;
     */
    LOCKING = 4,
    /**
     * @generated from protobuf enum value: LOCK_STATE_UNLOCKING = 5;
     */
    UNLOCKING = 5
}
/**
 * @generated from protobuf enum LockCommand
 */
export enum LockCommand {
    /**
     * @generated from protobuf enum value: LOCK_UNLOCK = 0;
     */
    LOCK_UNLOCK = 0,
    /**
     * @generated from protobuf enum value: LOCK_LOCK = 1;
     */
    LOCK_LOCK = 1,
    /**
     * @generated from protobuf enum value: LOCK_OPEN = 2;
     */
    LOCK_OPEN = 2
}
/**
 * ==================== MEDIA PLAYER ====================
 *
 * @generated from protobuf enum MediaPlayerState
 */
export enum MediaPlayerState {
    /**
     * @generated from protobuf enum value: MEDIA_PLAYER_STATE_NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: MEDIA_PLAYER_STATE_IDLE = 1;
     */
    IDLE = 1,
    /**
     * @generated from protobuf enum value: MEDIA_PLAYER_STATE_PLAYING = 2;
     */
    PLAYING = 2,
    /**
     * @generated from protobuf enum value: MEDIA_PLAYER_STATE_PAUSED = 3;
     */
    PAUSED = 3
}
/**
 * @generated from protobuf enum MediaPlayerCommand
 */
export enum MediaPlayerCommand {
    /**
     * @generated from protobuf enum value: MEDIA_PLAYER_COMMAND_PLAY = 0;
     */
    PLAY = 0,
    /**
     * @generated from protobuf enum value: MEDIA_PLAYER_COMMAND_PAUSE = 1;
     */
    PAUSE = 1,
    /**
     * @generated from protobuf enum value: MEDIA_PLAYER_COMMAND_STOP = 2;
     */
    STOP = 2,
    /**
     * @generated from protobuf enum value: MEDIA_PLAYER_COMMAND_MUTE = 3;
     */
    MUTE = 3,
    /**
     * @generated from protobuf enum value: MEDIA_PLAYER_COMMAND_UNMUTE = 4;
     */
    UNMUTE = 4
}
/**
 * @generated from protobuf enum BluetoothDeviceRequestType
 */
export enum BluetoothDeviceRequestType {
    /**
     * @generated from protobuf enum value: BLUETOOTH_DEVICE_REQUEST_TYPE_CONNECT = 0;
     */
    CONNECT = 0,
    /**
     * @generated from protobuf enum value: BLUETOOTH_DEVICE_REQUEST_TYPE_DISCONNECT = 1;
     */
    DISCONNECT = 1,
    /**
     * @generated from protobuf enum value: BLUETOOTH_DEVICE_REQUEST_TYPE_PAIR = 2;
     */
    PAIR = 2,
    /**
     * @generated from protobuf enum value: BLUETOOTH_DEVICE_REQUEST_TYPE_UNPAIR = 3;
     */
    UNPAIR = 3,
    /**
     * @generated from protobuf enum value: BLUETOOTH_DEVICE_REQUEST_TYPE_CONNECT_V3_WITH_CACHE = 4;
     */
    CONNECT_V3_WITH_CACHE = 4,
    /**
     * @generated from protobuf enum value: BLUETOOTH_DEVICE_REQUEST_TYPE_CONNECT_V3_WITHOUT_CACHE = 5;
     */
    CONNECT_V3_WITHOUT_CACHE = 5,
    /**
     * @generated from protobuf enum value: BLUETOOTH_DEVICE_REQUEST_TYPE_CLEAR_CACHE = 6;
     */
    CLEAR_CACHE = 6
}
/**
 * @generated from protobuf enum VoiceAssistantEvent
 */
export enum VoiceAssistantEvent {
    /**
     * @generated from protobuf enum value: VOICE_ASSISTANT_ERROR = 0;
     */
    VOICE_ASSISTANT_ERROR = 0,
    /**
     * @generated from protobuf enum value: VOICE_ASSISTANT_RUN_START = 1;
     */
    VOICE_ASSISTANT_RUN_START = 1,
    /**
     * @generated from protobuf enum value: VOICE_ASSISTANT_RUN_END = 2;
     */
    VOICE_ASSISTANT_RUN_END = 2,
    /**
     * @generated from protobuf enum value: VOICE_ASSISTANT_STT_START = 3;
     */
    VOICE_ASSISTANT_STT_START = 3,
    /**
     * @generated from protobuf enum value: VOICE_ASSISTANT_STT_END = 4;
     */
    VOICE_ASSISTANT_STT_END = 4,
    /**
     * @generated from protobuf enum value: VOICE_ASSISTANT_INTENT_START = 5;
     */
    VOICE_ASSISTANT_INTENT_START = 5,
    /**
     * @generated from protobuf enum value: VOICE_ASSISTANT_INTENT_END = 6;
     */
    VOICE_ASSISTANT_INTENT_END = 6,
    /**
     * @generated from protobuf enum value: VOICE_ASSISTANT_TTS_START = 7;
     */
    VOICE_ASSISTANT_TTS_START = 7,
    /**
     * @generated from protobuf enum value: VOICE_ASSISTANT_TTS_END = 8;
     */
    VOICE_ASSISTANT_TTS_END = 8
}
/**
 * ==================== ALARM CONTROL PANEL ====================
 *
 * @generated from protobuf enum AlarmControlPanelState
 */
export enum AlarmControlPanelState {
    /**
     * @generated from protobuf enum value: ALARM_STATE_DISARMED = 0;
     */
    ALARM_STATE_DISARMED = 0,
    /**
     * @generated from protobuf enum value: ALARM_STATE_ARMED_HOME = 1;
     */
    ALARM_STATE_ARMED_HOME = 1,
    /**
     * @generated from protobuf enum value: ALARM_STATE_ARMED_AWAY = 2;
     */
    ALARM_STATE_ARMED_AWAY = 2,
    /**
     * @generated from protobuf enum value: ALARM_STATE_ARMED_NIGHT = 3;
     */
    ALARM_STATE_ARMED_NIGHT = 3,
    /**
     * @generated from protobuf enum value: ALARM_STATE_ARMED_VACATION = 4;
     */
    ALARM_STATE_ARMED_VACATION = 4,
    /**
     * @generated from protobuf enum value: ALARM_STATE_ARMED_CUSTOM_BYPASS = 5;
     */
    ALARM_STATE_ARMED_CUSTOM_BYPASS = 5,
    /**
     * @generated from protobuf enum value: ALARM_STATE_PENDING = 6;
     */
    ALARM_STATE_PENDING = 6,
    /**
     * @generated from protobuf enum value: ALARM_STATE_ARMING = 7;
     */
    ALARM_STATE_ARMING = 7,
    /**
     * @generated from protobuf enum value: ALARM_STATE_DISARMING = 8;
     */
    ALARM_STATE_DISARMING = 8,
    /**
     * @generated from protobuf enum value: ALARM_STATE_TRIGGERED = 9;
     */
    ALARM_STATE_TRIGGERED = 9
}
/**
 * @generated from protobuf enum AlarmControlPanelStateCommand
 */
export enum AlarmControlPanelStateCommand {
    /**
     * @generated from protobuf enum value: ALARM_CONTROL_PANEL_DISARM = 0;
     */
    ALARM_CONTROL_PANEL_DISARM = 0,
    /**
     * @generated from protobuf enum value: ALARM_CONTROL_PANEL_ARM_AWAY = 1;
     */
    ALARM_CONTROL_PANEL_ARM_AWAY = 1,
    /**
     * @generated from protobuf enum value: ALARM_CONTROL_PANEL_ARM_HOME = 2;
     */
    ALARM_CONTROL_PANEL_ARM_HOME = 2,
    /**
     * @generated from protobuf enum value: ALARM_CONTROL_PANEL_ARM_NIGHT = 3;
     */
    ALARM_CONTROL_PANEL_ARM_NIGHT = 3,
    /**
     * @generated from protobuf enum value: ALARM_CONTROL_PANEL_ARM_VACATION = 4;
     */
    ALARM_CONTROL_PANEL_ARM_VACATION = 4,
    /**
     * @generated from protobuf enum value: ALARM_CONTROL_PANEL_ARM_CUSTOM_BYPASS = 5;
     */
    ALARM_CONTROL_PANEL_ARM_CUSTOM_BYPASS = 5,
    /**
     * @generated from protobuf enum value: ALARM_CONTROL_PANEL_TRIGGER = 6;
     */
    ALARM_CONTROL_PANEL_TRIGGER = 6
}
// @generated message type with reflection information, may provide speed optimized methods
class HelloRequest$Type extends MessageType<HelloRequest> {
    constructor() {
        super("HelloRequest", [
            { no: 1, name: "client_info", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "api_version_major", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "api_version_minor", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ], { id: 1, source: "SOURCE_CLIENT", no_delay: true });
    }
    create(value?: PartialMessage<HelloRequest>): HelloRequest {
        const message = { clientInfo: "", apiVersionMajor: 0, apiVersionMinor: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HelloRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HelloRequest): HelloRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string client_info */ 1:
                    message.clientInfo = reader.string();
                    break;
                case /* uint32 api_version_major */ 2:
                    message.apiVersionMajor = reader.uint32();
                    break;
                case /* uint32 api_version_minor */ 3:
                    message.apiVersionMinor = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HelloRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string client_info = 1; */
        if (message.clientInfo !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.clientInfo);
        /* uint32 api_version_major = 2; */
        if (message.apiVersionMajor !== 0)
            writer.tag(2, WireType.Varint).uint32(message.apiVersionMajor);
        /* uint32 api_version_minor = 3; */
        if (message.apiVersionMinor !== 0)
            writer.tag(3, WireType.Varint).uint32(message.apiVersionMinor);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message HelloRequest
 */
export const HelloRequest = new HelloRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HelloResponse$Type extends MessageType<HelloResponse> {
    constructor() {
        super("HelloResponse", [
            { no: 1, name: "api_version_major", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "api_version_minor", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "server_info", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { id: 2, source: "SOURCE_SERVER", no_delay: true });
    }
    create(value?: PartialMessage<HelloResponse>): HelloResponse {
        const message = { apiVersionMajor: 0, apiVersionMinor: 0, serverInfo: "", name: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HelloResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HelloResponse): HelloResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 api_version_major */ 1:
                    message.apiVersionMajor = reader.uint32();
                    break;
                case /* uint32 api_version_minor */ 2:
                    message.apiVersionMinor = reader.uint32();
                    break;
                case /* string server_info */ 3:
                    message.serverInfo = reader.string();
                    break;
                case /* string name */ 4:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HelloResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 api_version_major = 1; */
        if (message.apiVersionMajor !== 0)
            writer.tag(1, WireType.Varint).uint32(message.apiVersionMajor);
        /* uint32 api_version_minor = 2; */
        if (message.apiVersionMinor !== 0)
            writer.tag(2, WireType.Varint).uint32(message.apiVersionMinor);
        /* string server_info = 3; */
        if (message.serverInfo !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.serverInfo);
        /* string name = 4; */
        if (message.name !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message HelloResponse
 */
export const HelloResponse = new HelloResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ConnectRequest$Type extends MessageType<ConnectRequest> {
    constructor() {
        super("ConnectRequest", [
            { no: 1, name: "password", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { id: 3, source: "SOURCE_CLIENT", no_delay: true });
    }
    create(value?: PartialMessage<ConnectRequest>): ConnectRequest {
        const message = { password: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ConnectRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ConnectRequest): ConnectRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string password */ 1:
                    message.password = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ConnectRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string password = 1; */
        if (message.password !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.password);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ConnectRequest
 */
export const ConnectRequest = new ConnectRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ConnectResponse$Type extends MessageType<ConnectResponse> {
    constructor() {
        super("ConnectResponse", [
            { no: 1, name: "invalid_password", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ], { id: 4, source: "SOURCE_SERVER", no_delay: true });
    }
    create(value?: PartialMessage<ConnectResponse>): ConnectResponse {
        const message = { invalidPassword: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ConnectResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ConnectResponse): ConnectResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool invalid_password */ 1:
                    message.invalidPassword = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ConnectResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool invalid_password = 1; */
        if (message.invalidPassword !== false)
            writer.tag(1, WireType.Varint).bool(message.invalidPassword);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ConnectResponse
 */
export const ConnectResponse = new ConnectResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DisconnectRequest$Type extends MessageType<DisconnectRequest> {
    constructor() {
        super("DisconnectRequest", [], { id: 5, source: "SOURCE_BOTH", no_delay: true });
    }
    create(value?: PartialMessage<DisconnectRequest>): DisconnectRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DisconnectRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DisconnectRequest): DisconnectRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: DisconnectRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DisconnectRequest
 */
export const DisconnectRequest = new DisconnectRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DisconnectResponse$Type extends MessageType<DisconnectResponse> {
    constructor() {
        super("DisconnectResponse", [], { id: 6, source: "SOURCE_BOTH", no_delay: true });
    }
    create(value?: PartialMessage<DisconnectResponse>): DisconnectResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DisconnectResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DisconnectResponse): DisconnectResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: DisconnectResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DisconnectResponse
 */
export const DisconnectResponse = new DisconnectResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PingRequest$Type extends MessageType<PingRequest> {
    constructor() {
        super("PingRequest", [], { id: 7, source: "SOURCE_BOTH" });
    }
    create(value?: PartialMessage<PingRequest>): PingRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PingRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PingRequest): PingRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: PingRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message PingRequest
 */
export const PingRequest = new PingRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PingResponse$Type extends MessageType<PingResponse> {
    constructor() {
        super("PingResponse", [], { id: 8, source: "SOURCE_BOTH" });
    }
    create(value?: PartialMessage<PingResponse>): PingResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PingResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PingResponse): PingResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: PingResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message PingResponse
 */
export const PingResponse = new PingResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeviceInfoRequest$Type extends MessageType<DeviceInfoRequest> {
    constructor() {
        super("DeviceInfoRequest", [], { id: 9, source: "SOURCE_CLIENT" });
    }
    create(value?: PartialMessage<DeviceInfoRequest>): DeviceInfoRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DeviceInfoRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeviceInfoRequest): DeviceInfoRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: DeviceInfoRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DeviceInfoRequest
 */
export const DeviceInfoRequest = new DeviceInfoRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeviceInfoResponse$Type extends MessageType<DeviceInfoResponse> {
    constructor() {
        super("DeviceInfoResponse", [
            { no: 1, name: "uses_password", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "mac_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "esphome_version", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "compilation_time", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "model", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "has_deep_sleep", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "project_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "project_version", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "webserver_port", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 11, name: "legacy_bluetooth_proxy_version", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 15, name: "bluetooth_proxy_feature_flags", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 12, name: "manufacturer", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 13, name: "friendly_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 14, name: "voice_assistant_version", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ], { id: 10, source: "SOURCE_SERVER" });
    }
    create(value?: PartialMessage<DeviceInfoResponse>): DeviceInfoResponse {
        const message = { usesPassword: false, name: "", macAddress: "", esphomeVersion: "", compilationTime: "", model: "", hasDeepSleep: false, projectName: "", projectVersion: "", webserverPort: 0, legacyBluetoothProxyVersion: 0, bluetoothProxyFeatureFlags: 0, manufacturer: "", friendlyName: "", voiceAssistantVersion: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DeviceInfoResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeviceInfoResponse): DeviceInfoResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool uses_password */ 1:
                    message.usesPassword = reader.bool();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* string mac_address */ 3:
                    message.macAddress = reader.string();
                    break;
                case /* string esphome_version */ 4:
                    message.esphomeVersion = reader.string();
                    break;
                case /* string compilation_time */ 5:
                    message.compilationTime = reader.string();
                    break;
                case /* string model */ 6:
                    message.model = reader.string();
                    break;
                case /* bool has_deep_sleep */ 7:
                    message.hasDeepSleep = reader.bool();
                    break;
                case /* string project_name */ 8:
                    message.projectName = reader.string();
                    break;
                case /* string project_version */ 9:
                    message.projectVersion = reader.string();
                    break;
                case /* uint32 webserver_port */ 10:
                    message.webserverPort = reader.uint32();
                    break;
                case /* uint32 legacy_bluetooth_proxy_version */ 11:
                    message.legacyBluetoothProxyVersion = reader.uint32();
                    break;
                case /* uint32 bluetooth_proxy_feature_flags */ 15:
                    message.bluetoothProxyFeatureFlags = reader.uint32();
                    break;
                case /* string manufacturer */ 12:
                    message.manufacturer = reader.string();
                    break;
                case /* string friendly_name */ 13:
                    message.friendlyName = reader.string();
                    break;
                case /* uint32 voice_assistant_version */ 14:
                    message.voiceAssistantVersion = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeviceInfoResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool uses_password = 1; */
        if (message.usesPassword !== false)
            writer.tag(1, WireType.Varint).bool(message.usesPassword);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* string mac_address = 3; */
        if (message.macAddress !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.macAddress);
        /* string esphome_version = 4; */
        if (message.esphomeVersion !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.esphomeVersion);
        /* string compilation_time = 5; */
        if (message.compilationTime !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.compilationTime);
        /* string model = 6; */
        if (message.model !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.model);
        /* bool has_deep_sleep = 7; */
        if (message.hasDeepSleep !== false)
            writer.tag(7, WireType.Varint).bool(message.hasDeepSleep);
        /* string project_name = 8; */
        if (message.projectName !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.projectName);
        /* string project_version = 9; */
        if (message.projectVersion !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.projectVersion);
        /* uint32 webserver_port = 10; */
        if (message.webserverPort !== 0)
            writer.tag(10, WireType.Varint).uint32(message.webserverPort);
        /* uint32 legacy_bluetooth_proxy_version = 11; */
        if (message.legacyBluetoothProxyVersion !== 0)
            writer.tag(11, WireType.Varint).uint32(message.legacyBluetoothProxyVersion);
        /* uint32 bluetooth_proxy_feature_flags = 15; */
        if (message.bluetoothProxyFeatureFlags !== 0)
            writer.tag(15, WireType.Varint).uint32(message.bluetoothProxyFeatureFlags);
        /* string manufacturer = 12; */
        if (message.manufacturer !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.manufacturer);
        /* string friendly_name = 13; */
        if (message.friendlyName !== "")
            writer.tag(13, WireType.LengthDelimited).string(message.friendlyName);
        /* uint32 voice_assistant_version = 14; */
        if (message.voiceAssistantVersion !== 0)
            writer.tag(14, WireType.Varint).uint32(message.voiceAssistantVersion);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DeviceInfoResponse
 */
export const DeviceInfoResponse = new DeviceInfoResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListEntitiesRequest$Type extends MessageType<ListEntitiesRequest> {
    constructor() {
        super("ListEntitiesRequest", [], { id: 11, source: "SOURCE_CLIENT" });
    }
    create(value?: PartialMessage<ListEntitiesRequest>): ListEntitiesRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListEntitiesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListEntitiesRequest): ListEntitiesRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: ListEntitiesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ListEntitiesRequest
 */
export const ListEntitiesRequest = new ListEntitiesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListEntitiesDoneResponse$Type extends MessageType<ListEntitiesDoneResponse> {
    constructor() {
        super("ListEntitiesDoneResponse", [], { id: 19, source: "SOURCE_SERVER", no_delay: true });
    }
    create(value?: PartialMessage<ListEntitiesDoneResponse>): ListEntitiesDoneResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListEntitiesDoneResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListEntitiesDoneResponse): ListEntitiesDoneResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: ListEntitiesDoneResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ListEntitiesDoneResponse
 */
export const ListEntitiesDoneResponse = new ListEntitiesDoneResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeStatesRequest$Type extends MessageType<SubscribeStatesRequest> {
    constructor() {
        super("SubscribeStatesRequest", [], { id: 20, source: "SOURCE_CLIENT" });
    }
    create(value?: PartialMessage<SubscribeStatesRequest>): SubscribeStatesRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SubscribeStatesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeStatesRequest): SubscribeStatesRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: SubscribeStatesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SubscribeStatesRequest
 */
export const SubscribeStatesRequest = new SubscribeStatesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListEntitiesBinarySensorResponse$Type extends MessageType<ListEntitiesBinarySensorResponse> {
    constructor() {
        super("ListEntitiesBinarySensorResponse", [
            { no: 1, name: "object_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "key", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ },
            { no: 3, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "unique_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "device_class", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "is_status_binary_sensor", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "disabled_by_default", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "icon", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "entity_category", kind: "enum", T: () => ["EntityCategory", EntityCategory, "ENTITY_CATEGORY_"] }
        ], { id: 12, source: "SOURCE_SERVER", ifdef: "USE_BINARY_SENSOR" });
    }
    create(value?: PartialMessage<ListEntitiesBinarySensorResponse>): ListEntitiesBinarySensorResponse {
        const message = { objectId: "", key: 0, name: "", uniqueId: "", deviceClass: "", isStatusBinarySensor: false, disabledByDefault: false, icon: "", entityCategory: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListEntitiesBinarySensorResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListEntitiesBinarySensorResponse): ListEntitiesBinarySensorResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string object_id */ 1:
                    message.objectId = reader.string();
                    break;
                case /* fixed32 key */ 2:
                    message.key = reader.fixed32();
                    break;
                case /* string name */ 3:
                    message.name = reader.string();
                    break;
                case /* string unique_id */ 4:
                    message.uniqueId = reader.string();
                    break;
                case /* string device_class */ 5:
                    message.deviceClass = reader.string();
                    break;
                case /* bool is_status_binary_sensor */ 6:
                    message.isStatusBinarySensor = reader.bool();
                    break;
                case /* bool disabled_by_default */ 7:
                    message.disabledByDefault = reader.bool();
                    break;
                case /* string icon */ 8:
                    message.icon = reader.string();
                    break;
                case /* EntityCategory entity_category */ 9:
                    message.entityCategory = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListEntitiesBinarySensorResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string object_id = 1; */
        if (message.objectId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.objectId);
        /* fixed32 key = 2; */
        if (message.key !== 0)
            writer.tag(2, WireType.Bit32).fixed32(message.key);
        /* string name = 3; */
        if (message.name !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.name);
        /* string unique_id = 4; */
        if (message.uniqueId !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.uniqueId);
        /* string device_class = 5; */
        if (message.deviceClass !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.deviceClass);
        /* bool is_status_binary_sensor = 6; */
        if (message.isStatusBinarySensor !== false)
            writer.tag(6, WireType.Varint).bool(message.isStatusBinarySensor);
        /* bool disabled_by_default = 7; */
        if (message.disabledByDefault !== false)
            writer.tag(7, WireType.Varint).bool(message.disabledByDefault);
        /* string icon = 8; */
        if (message.icon !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.icon);
        /* EntityCategory entity_category = 9; */
        if (message.entityCategory !== 0)
            writer.tag(9, WireType.Varint).int32(message.entityCategory);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ListEntitiesBinarySensorResponse
 */
export const ListEntitiesBinarySensorResponse = new ListEntitiesBinarySensorResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BinarySensorStateResponse$Type extends MessageType<BinarySensorStateResponse> {
    constructor() {
        super("BinarySensorStateResponse", [
            { no: 1, name: "key", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ },
            { no: 2, name: "state", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "missing_state", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ], { id: 21, source: "SOURCE_SERVER", ifdef: "USE_BINARY_SENSOR", no_delay: true });
    }
    create(value?: PartialMessage<BinarySensorStateResponse>): BinarySensorStateResponse {
        const message = { key: 0, state: false, missingState: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BinarySensorStateResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BinarySensorStateResponse): BinarySensorStateResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* fixed32 key */ 1:
                    message.key = reader.fixed32();
                    break;
                case /* bool state */ 2:
                    message.state = reader.bool();
                    break;
                case /* bool missing_state */ 3:
                    message.missingState = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BinarySensorStateResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* fixed32 key = 1; */
        if (message.key !== 0)
            writer.tag(1, WireType.Bit32).fixed32(message.key);
        /* bool state = 2; */
        if (message.state !== false)
            writer.tag(2, WireType.Varint).bool(message.state);
        /* bool missing_state = 3; */
        if (message.missingState !== false)
            writer.tag(3, WireType.Varint).bool(message.missingState);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message BinarySensorStateResponse
 */
export const BinarySensorStateResponse = new BinarySensorStateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListEntitiesCoverResponse$Type extends MessageType<ListEntitiesCoverResponse> {
    constructor() {
        super("ListEntitiesCoverResponse", [
            { no: 1, name: "object_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "key", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ },
            { no: 3, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "unique_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "assumed_state", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "supports_position", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "supports_tilt", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "device_class", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "disabled_by_default", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 10, name: "icon", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "entity_category", kind: "enum", T: () => ["EntityCategory", EntityCategory, "ENTITY_CATEGORY_"] },
            { no: 12, name: "supports_stop", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ], { id: 13, source: "SOURCE_SERVER", ifdef: "USE_COVER" });
    }
    create(value?: PartialMessage<ListEntitiesCoverResponse>): ListEntitiesCoverResponse {
        const message = { objectId: "", key: 0, name: "", uniqueId: "", assumedState: false, supportsPosition: false, supportsTilt: false, deviceClass: "", disabledByDefault: false, icon: "", entityCategory: 0, supportsStop: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListEntitiesCoverResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListEntitiesCoverResponse): ListEntitiesCoverResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string object_id */ 1:
                    message.objectId = reader.string();
                    break;
                case /* fixed32 key */ 2:
                    message.key = reader.fixed32();
                    break;
                case /* string name */ 3:
                    message.name = reader.string();
                    break;
                case /* string unique_id */ 4:
                    message.uniqueId = reader.string();
                    break;
                case /* bool assumed_state */ 5:
                    message.assumedState = reader.bool();
                    break;
                case /* bool supports_position */ 6:
                    message.supportsPosition = reader.bool();
                    break;
                case /* bool supports_tilt */ 7:
                    message.supportsTilt = reader.bool();
                    break;
                case /* string device_class */ 8:
                    message.deviceClass = reader.string();
                    break;
                case /* bool disabled_by_default */ 9:
                    message.disabledByDefault = reader.bool();
                    break;
                case /* string icon */ 10:
                    message.icon = reader.string();
                    break;
                case /* EntityCategory entity_category */ 11:
                    message.entityCategory = reader.int32();
                    break;
                case /* bool supports_stop */ 12:
                    message.supportsStop = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListEntitiesCoverResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string object_id = 1; */
        if (message.objectId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.objectId);
        /* fixed32 key = 2; */
        if (message.key !== 0)
            writer.tag(2, WireType.Bit32).fixed32(message.key);
        /* string name = 3; */
        if (message.name !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.name);
        /* string unique_id = 4; */
        if (message.uniqueId !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.uniqueId);
        /* bool assumed_state = 5; */
        if (message.assumedState !== false)
            writer.tag(5, WireType.Varint).bool(message.assumedState);
        /* bool supports_position = 6; */
        if (message.supportsPosition !== false)
            writer.tag(6, WireType.Varint).bool(message.supportsPosition);
        /* bool supports_tilt = 7; */
        if (message.supportsTilt !== false)
            writer.tag(7, WireType.Varint).bool(message.supportsTilt);
        /* string device_class = 8; */
        if (message.deviceClass !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.deviceClass);
        /* bool disabled_by_default = 9; */
        if (message.disabledByDefault !== false)
            writer.tag(9, WireType.Varint).bool(message.disabledByDefault);
        /* string icon = 10; */
        if (message.icon !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.icon);
        /* EntityCategory entity_category = 11; */
        if (message.entityCategory !== 0)
            writer.tag(11, WireType.Varint).int32(message.entityCategory);
        /* bool supports_stop = 12; */
        if (message.supportsStop !== false)
            writer.tag(12, WireType.Varint).bool(message.supportsStop);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ListEntitiesCoverResponse
 */
export const ListEntitiesCoverResponse = new ListEntitiesCoverResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CoverStateResponse$Type extends MessageType<CoverStateResponse> {
    constructor() {
        super("CoverStateResponse", [
            { no: 1, name: "key", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ },
            { no: 2, name: "legacy_state", kind: "enum", T: () => ["LegacyCoverState", LegacyCoverState, "LEGACY_COVER_STATE_"] },
            { no: 3, name: "position", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "tilt", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 5, name: "current_operation", kind: "enum", T: () => ["CoverOperation", CoverOperation, "COVER_OPERATION_"] }
        ], { id: 22, source: "SOURCE_SERVER", ifdef: "USE_COVER", no_delay: true });
    }
    create(value?: PartialMessage<CoverStateResponse>): CoverStateResponse {
        const message = { key: 0, legacyState: 0, position: 0, tilt: 0, currentOperation: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CoverStateResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CoverStateResponse): CoverStateResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* fixed32 key */ 1:
                    message.key = reader.fixed32();
                    break;
                case /* LegacyCoverState legacy_state */ 2:
                    message.legacyState = reader.int32();
                    break;
                case /* float position */ 3:
                    message.position = reader.float();
                    break;
                case /* float tilt */ 4:
                    message.tilt = reader.float();
                    break;
                case /* CoverOperation current_operation */ 5:
                    message.currentOperation = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CoverStateResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* fixed32 key = 1; */
        if (message.key !== 0)
            writer.tag(1, WireType.Bit32).fixed32(message.key);
        /* LegacyCoverState legacy_state = 2; */
        if (message.legacyState !== 0)
            writer.tag(2, WireType.Varint).int32(message.legacyState);
        /* float position = 3; */
        if (message.position !== 0)
            writer.tag(3, WireType.Bit32).float(message.position);
        /* float tilt = 4; */
        if (message.tilt !== 0)
            writer.tag(4, WireType.Bit32).float(message.tilt);
        /* CoverOperation current_operation = 5; */
        if (message.currentOperation !== 0)
            writer.tag(5, WireType.Varint).int32(message.currentOperation);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CoverStateResponse
 */
export const CoverStateResponse = new CoverStateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CoverCommandRequest$Type extends MessageType<CoverCommandRequest> {
    constructor() {
        super("CoverCommandRequest", [
            { no: 1, name: "key", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ },
            { no: 2, name: "has_legacy_command", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "legacy_command", kind: "enum", T: () => ["LegacyCoverCommand", LegacyCoverCommand, "LEGACY_COVER_COMMAND_"] },
            { no: 4, name: "has_position", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "position", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 6, name: "has_tilt", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "tilt", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 8, name: "stop", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ], { id: 30, source: "SOURCE_CLIENT", ifdef: "USE_COVER", no_delay: true });
    }
    create(value?: PartialMessage<CoverCommandRequest>): CoverCommandRequest {
        const message = { key: 0, hasLegacyCommand: false, legacyCommand: 0, hasPosition: false, position: 0, hasTilt: false, tilt: 0, stop: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CoverCommandRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CoverCommandRequest): CoverCommandRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* fixed32 key */ 1:
                    message.key = reader.fixed32();
                    break;
                case /* bool has_legacy_command */ 2:
                    message.hasLegacyCommand = reader.bool();
                    break;
                case /* LegacyCoverCommand legacy_command */ 3:
                    message.legacyCommand = reader.int32();
                    break;
                case /* bool has_position */ 4:
                    message.hasPosition = reader.bool();
                    break;
                case /* float position */ 5:
                    message.position = reader.float();
                    break;
                case /* bool has_tilt */ 6:
                    message.hasTilt = reader.bool();
                    break;
                case /* float tilt */ 7:
                    message.tilt = reader.float();
                    break;
                case /* bool stop */ 8:
                    message.stop = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CoverCommandRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* fixed32 key = 1; */
        if (message.key !== 0)
            writer.tag(1, WireType.Bit32).fixed32(message.key);
        /* bool has_legacy_command = 2; */
        if (message.hasLegacyCommand !== false)
            writer.tag(2, WireType.Varint).bool(message.hasLegacyCommand);
        /* LegacyCoverCommand legacy_command = 3; */
        if (message.legacyCommand !== 0)
            writer.tag(3, WireType.Varint).int32(message.legacyCommand);
        /* bool has_position = 4; */
        if (message.hasPosition !== false)
            writer.tag(4, WireType.Varint).bool(message.hasPosition);
        /* float position = 5; */
        if (message.position !== 0)
            writer.tag(5, WireType.Bit32).float(message.position);
        /* bool has_tilt = 6; */
        if (message.hasTilt !== false)
            writer.tag(6, WireType.Varint).bool(message.hasTilt);
        /* float tilt = 7; */
        if (message.tilt !== 0)
            writer.tag(7, WireType.Bit32).float(message.tilt);
        /* bool stop = 8; */
        if (message.stop !== false)
            writer.tag(8, WireType.Varint).bool(message.stop);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CoverCommandRequest
 */
export const CoverCommandRequest = new CoverCommandRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListEntitiesFanResponse$Type extends MessageType<ListEntitiesFanResponse> {
    constructor() {
        super("ListEntitiesFanResponse", [
            { no: 1, name: "object_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "key", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ },
            { no: 3, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "unique_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "supports_oscillation", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "supports_speed", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "supports_direction", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "supported_speed_levels", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 9, name: "disabled_by_default", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 10, name: "icon", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "entity_category", kind: "enum", T: () => ["EntityCategory", EntityCategory, "ENTITY_CATEGORY_"] }
        ], { id: 14, source: "SOURCE_SERVER", ifdef: "USE_FAN" });
    }
    create(value?: PartialMessage<ListEntitiesFanResponse>): ListEntitiesFanResponse {
        const message = { objectId: "", key: 0, name: "", uniqueId: "", supportsOscillation: false, supportsSpeed: false, supportsDirection: false, supportedSpeedLevels: 0, disabledByDefault: false, icon: "", entityCategory: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListEntitiesFanResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListEntitiesFanResponse): ListEntitiesFanResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string object_id */ 1:
                    message.objectId = reader.string();
                    break;
                case /* fixed32 key */ 2:
                    message.key = reader.fixed32();
                    break;
                case /* string name */ 3:
                    message.name = reader.string();
                    break;
                case /* string unique_id */ 4:
                    message.uniqueId = reader.string();
                    break;
                case /* bool supports_oscillation */ 5:
                    message.supportsOscillation = reader.bool();
                    break;
                case /* bool supports_speed */ 6:
                    message.supportsSpeed = reader.bool();
                    break;
                case /* bool supports_direction */ 7:
                    message.supportsDirection = reader.bool();
                    break;
                case /* int32 supported_speed_levels */ 8:
                    message.supportedSpeedLevels = reader.int32();
                    break;
                case /* bool disabled_by_default */ 9:
                    message.disabledByDefault = reader.bool();
                    break;
                case /* string icon */ 10:
                    message.icon = reader.string();
                    break;
                case /* EntityCategory entity_category */ 11:
                    message.entityCategory = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListEntitiesFanResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string object_id = 1; */
        if (message.objectId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.objectId);
        /* fixed32 key = 2; */
        if (message.key !== 0)
            writer.tag(2, WireType.Bit32).fixed32(message.key);
        /* string name = 3; */
        if (message.name !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.name);
        /* string unique_id = 4; */
        if (message.uniqueId !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.uniqueId);
        /* bool supports_oscillation = 5; */
        if (message.supportsOscillation !== false)
            writer.tag(5, WireType.Varint).bool(message.supportsOscillation);
        /* bool supports_speed = 6; */
        if (message.supportsSpeed !== false)
            writer.tag(6, WireType.Varint).bool(message.supportsSpeed);
        /* bool supports_direction = 7; */
        if (message.supportsDirection !== false)
            writer.tag(7, WireType.Varint).bool(message.supportsDirection);
        /* int32 supported_speed_levels = 8; */
        if (message.supportedSpeedLevels !== 0)
            writer.tag(8, WireType.Varint).int32(message.supportedSpeedLevels);
        /* bool disabled_by_default = 9; */
        if (message.disabledByDefault !== false)
            writer.tag(9, WireType.Varint).bool(message.disabledByDefault);
        /* string icon = 10; */
        if (message.icon !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.icon);
        /* EntityCategory entity_category = 11; */
        if (message.entityCategory !== 0)
            writer.tag(11, WireType.Varint).int32(message.entityCategory);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ListEntitiesFanResponse
 */
export const ListEntitiesFanResponse = new ListEntitiesFanResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FanStateResponse$Type extends MessageType<FanStateResponse> {
    constructor() {
        super("FanStateResponse", [
            { no: 1, name: "key", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ },
            { no: 2, name: "state", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "oscillating", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "speed", kind: "enum", T: () => ["FanSpeed", FanSpeed, "FAN_SPEED_"] },
            { no: 5, name: "direction", kind: "enum", T: () => ["FanDirection", FanDirection, "FAN_DIRECTION_"] },
            { no: 6, name: "speed_level", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ], { id: 23, source: "SOURCE_SERVER", ifdef: "USE_FAN", no_delay: true });
    }
    create(value?: PartialMessage<FanStateResponse>): FanStateResponse {
        const message = { key: 0, state: false, oscillating: false, speed: 0, direction: 0, speedLevel: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FanStateResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FanStateResponse): FanStateResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* fixed32 key */ 1:
                    message.key = reader.fixed32();
                    break;
                case /* bool state */ 2:
                    message.state = reader.bool();
                    break;
                case /* bool oscillating */ 3:
                    message.oscillating = reader.bool();
                    break;
                case /* FanSpeed speed = 4 [deprecated = true];*/ 4:
                    message.speed = reader.int32();
                    break;
                case /* FanDirection direction */ 5:
                    message.direction = reader.int32();
                    break;
                case /* int32 speed_level */ 6:
                    message.speedLevel = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FanStateResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* fixed32 key = 1; */
        if (message.key !== 0)
            writer.tag(1, WireType.Bit32).fixed32(message.key);
        /* bool state = 2; */
        if (message.state !== false)
            writer.tag(2, WireType.Varint).bool(message.state);
        /* bool oscillating = 3; */
        if (message.oscillating !== false)
            writer.tag(3, WireType.Varint).bool(message.oscillating);
        /* FanSpeed speed = 4 [deprecated = true]; */
        if (message.speed !== 0)
            writer.tag(4, WireType.Varint).int32(message.speed);
        /* FanDirection direction = 5; */
        if (message.direction !== 0)
            writer.tag(5, WireType.Varint).int32(message.direction);
        /* int32 speed_level = 6; */
        if (message.speedLevel !== 0)
            writer.tag(6, WireType.Varint).int32(message.speedLevel);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message FanStateResponse
 */
export const FanStateResponse = new FanStateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FanCommandRequest$Type extends MessageType<FanCommandRequest> {
    constructor() {
        super("FanCommandRequest", [
            { no: 1, name: "key", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ },
            { no: 2, name: "has_state", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "state", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "has_speed", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "speed", kind: "enum", T: () => ["FanSpeed", FanSpeed, "FAN_SPEED_"] },
            { no: 6, name: "has_oscillating", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "oscillating", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "has_direction", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "direction", kind: "enum", T: () => ["FanDirection", FanDirection, "FAN_DIRECTION_"] },
            { no: 10, name: "has_speed_level", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 11, name: "speed_level", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ], { id: 31, source: "SOURCE_CLIENT", ifdef: "USE_FAN", no_delay: true });
    }
    create(value?: PartialMessage<FanCommandRequest>): FanCommandRequest {
        const message = { key: 0, hasState: false, state: false, hasSpeed: false, speed: 0, hasOscillating: false, oscillating: false, hasDirection: false, direction: 0, hasSpeedLevel: false, speedLevel: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FanCommandRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FanCommandRequest): FanCommandRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* fixed32 key */ 1:
                    message.key = reader.fixed32();
                    break;
                case /* bool has_state */ 2:
                    message.hasState = reader.bool();
                    break;
                case /* bool state */ 3:
                    message.state = reader.bool();
                    break;
                case /* bool has_speed = 4 [deprecated = true];*/ 4:
                    message.hasSpeed = reader.bool();
                    break;
                case /* FanSpeed speed = 5 [deprecated = true];*/ 5:
                    message.speed = reader.int32();
                    break;
                case /* bool has_oscillating */ 6:
                    message.hasOscillating = reader.bool();
                    break;
                case /* bool oscillating */ 7:
                    message.oscillating = reader.bool();
                    break;
                case /* bool has_direction */ 8:
                    message.hasDirection = reader.bool();
                    break;
                case /* FanDirection direction */ 9:
                    message.direction = reader.int32();
                    break;
                case /* bool has_speed_level */ 10:
                    message.hasSpeedLevel = reader.bool();
                    break;
                case /* int32 speed_level */ 11:
                    message.speedLevel = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FanCommandRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* fixed32 key = 1; */
        if (message.key !== 0)
            writer.tag(1, WireType.Bit32).fixed32(message.key);
        /* bool has_state = 2; */
        if (message.hasState !== false)
            writer.tag(2, WireType.Varint).bool(message.hasState);
        /* bool state = 3; */
        if (message.state !== false)
            writer.tag(3, WireType.Varint).bool(message.state);
        /* bool has_speed = 4 [deprecated = true]; */
        if (message.hasSpeed !== false)
            writer.tag(4, WireType.Varint).bool(message.hasSpeed);
        /* FanSpeed speed = 5 [deprecated = true]; */
        if (message.speed !== 0)
            writer.tag(5, WireType.Varint).int32(message.speed);
        /* bool has_oscillating = 6; */
        if (message.hasOscillating !== false)
            writer.tag(6, WireType.Varint).bool(message.hasOscillating);
        /* bool oscillating = 7; */
        if (message.oscillating !== false)
            writer.tag(7, WireType.Varint).bool(message.oscillating);
        /* bool has_direction = 8; */
        if (message.hasDirection !== false)
            writer.tag(8, WireType.Varint).bool(message.hasDirection);
        /* FanDirection direction = 9; */
        if (message.direction !== 0)
            writer.tag(9, WireType.Varint).int32(message.direction);
        /* bool has_speed_level = 10; */
        if (message.hasSpeedLevel !== false)
            writer.tag(10, WireType.Varint).bool(message.hasSpeedLevel);
        /* int32 speed_level = 11; */
        if (message.speedLevel !== 0)
            writer.tag(11, WireType.Varint).int32(message.speedLevel);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message FanCommandRequest
 */
export const FanCommandRequest = new FanCommandRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListEntitiesLightResponse$Type extends MessageType<ListEntitiesLightResponse> {
    constructor() {
        super("ListEntitiesLightResponse", [
            { no: 1, name: "object_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "key", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ },
            { no: 3, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "unique_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "supported_color_modes", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "legacy_supports_brightness", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "legacy_supports_rgb", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "legacy_supports_white_value", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "legacy_supports_color_temperature", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "min_mireds", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 10, name: "max_mireds", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 11, name: "effects", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 13, name: "disabled_by_default", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 14, name: "icon", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 15, name: "entity_category", kind: "enum", T: () => ["EntityCategory", EntityCategory, "ENTITY_CATEGORY_"] }
        ], { id: 15, source: "SOURCE_SERVER", ifdef: "USE_LIGHT" });
    }
    create(value?: PartialMessage<ListEntitiesLightResponse>): ListEntitiesLightResponse {
        const message = { objectId: "", key: 0, name: "", uniqueId: "", supportedColorModes: [], legacySupportsBrightness: false, legacySupportsRgb: false, legacySupportsWhiteValue: false, legacySupportsColorTemperature: false, minMireds: 0, maxMireds: 0, effects: [], disabledByDefault: false, icon: "", entityCategory: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListEntitiesLightResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListEntitiesLightResponse): ListEntitiesLightResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string object_id */ 1:
                    message.objectId = reader.string();
                    break;
                case /* fixed32 key */ 2:
                    message.key = reader.fixed32();
                    break;
                case /* string name */ 3:
                    message.name = reader.string();
                    break;
                case /* string unique_id */ 4:
                    message.uniqueId = reader.string();
                    break;
                case /* repeated int32 supported_color_modes */ 12:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.supportedColorModes.push(reader.int32());
                    else
                        message.supportedColorModes.push(reader.int32());
                    break;
                case /* bool legacy_supports_brightness = 5 [deprecated = true];*/ 5:
                    message.legacySupportsBrightness = reader.bool();
                    break;
                case /* bool legacy_supports_rgb = 6 [deprecated = true];*/ 6:
                    message.legacySupportsRgb = reader.bool();
                    break;
                case /* bool legacy_supports_white_value = 7 [deprecated = true];*/ 7:
                    message.legacySupportsWhiteValue = reader.bool();
                    break;
                case /* bool legacy_supports_color_temperature = 8 [deprecated = true];*/ 8:
                    message.legacySupportsColorTemperature = reader.bool();
                    break;
                case /* float min_mireds */ 9:
                    message.minMireds = reader.float();
                    break;
                case /* float max_mireds */ 10:
                    message.maxMireds = reader.float();
                    break;
                case /* repeated string effects */ 11:
                    message.effects.push(reader.string());
                    break;
                case /* bool disabled_by_default */ 13:
                    message.disabledByDefault = reader.bool();
                    break;
                case /* string icon */ 14:
                    message.icon = reader.string();
                    break;
                case /* EntityCategory entity_category */ 15:
                    message.entityCategory = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListEntitiesLightResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string object_id = 1; */
        if (message.objectId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.objectId);
        /* fixed32 key = 2; */
        if (message.key !== 0)
            writer.tag(2, WireType.Bit32).fixed32(message.key);
        /* string name = 3; */
        if (message.name !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.name);
        /* string unique_id = 4; */
        if (message.uniqueId !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.uniqueId);
        /* repeated int32 supported_color_modes = 12; */
        if (message.supportedColorModes.length) {
            writer.tag(12, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.supportedColorModes.length; i++)
                writer.int32(message.supportedColorModes[i]);
            writer.join();
        }
        /* bool legacy_supports_brightness = 5 [deprecated = true]; */
        if (message.legacySupportsBrightness !== false)
            writer.tag(5, WireType.Varint).bool(message.legacySupportsBrightness);
        /* bool legacy_supports_rgb = 6 [deprecated = true]; */
        if (message.legacySupportsRgb !== false)
            writer.tag(6, WireType.Varint).bool(message.legacySupportsRgb);
        /* bool legacy_supports_white_value = 7 [deprecated = true]; */
        if (message.legacySupportsWhiteValue !== false)
            writer.tag(7, WireType.Varint).bool(message.legacySupportsWhiteValue);
        /* bool legacy_supports_color_temperature = 8 [deprecated = true]; */
        if (message.legacySupportsColorTemperature !== false)
            writer.tag(8, WireType.Varint).bool(message.legacySupportsColorTemperature);
        /* float min_mireds = 9; */
        if (message.minMireds !== 0)
            writer.tag(9, WireType.Bit32).float(message.minMireds);
        /* float max_mireds = 10; */
        if (message.maxMireds !== 0)
            writer.tag(10, WireType.Bit32).float(message.maxMireds);
        /* repeated string effects = 11; */
        for (let i = 0; i < message.effects.length; i++)
            writer.tag(11, WireType.LengthDelimited).string(message.effects[i]);
        /* bool disabled_by_default = 13; */
        if (message.disabledByDefault !== false)
            writer.tag(13, WireType.Varint).bool(message.disabledByDefault);
        /* string icon = 14; */
        if (message.icon !== "")
            writer.tag(14, WireType.LengthDelimited).string(message.icon);
        /* EntityCategory entity_category = 15; */
        if (message.entityCategory !== 0)
            writer.tag(15, WireType.Varint).int32(message.entityCategory);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ListEntitiesLightResponse
 */
export const ListEntitiesLightResponse = new ListEntitiesLightResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LightStateResponse$Type extends MessageType<LightStateResponse> {
    constructor() {
        super("LightStateResponse", [
            { no: 1, name: "key", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ },
            { no: 2, name: "state", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "brightness", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 11, name: "color_mode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 10, name: "color_brightness", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "red", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 5, name: "green", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 6, name: "blue", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 7, name: "white", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 8, name: "color_temperature", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 12, name: "cold_white", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 13, name: "warm_white", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 9, name: "effect", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { id: 24, source: "SOURCE_SERVER", ifdef: "USE_LIGHT", no_delay: true });
    }
    create(value?: PartialMessage<LightStateResponse>): LightStateResponse {
        const message = { key: 0, state: false, brightness: 0, colorMode: 0, colorBrightness: 0, red: 0, green: 0, blue: 0, white: 0, colorTemperature: 0, coldWhite: 0, warmWhite: 0, effect: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<LightStateResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LightStateResponse): LightStateResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* fixed32 key */ 1:
                    message.key = reader.fixed32();
                    break;
                case /* bool state */ 2:
                    message.state = reader.bool();
                    break;
                case /* float brightness */ 3:
                    message.brightness = reader.float();
                    break;
                case /* int32 color_mode */ 11:
                    message.colorMode = reader.int32();
                    break;
                case /* float color_brightness */ 10:
                    message.colorBrightness = reader.float();
                    break;
                case /* float red */ 4:
                    message.red = reader.float();
                    break;
                case /* float green */ 5:
                    message.green = reader.float();
                    break;
                case /* float blue */ 6:
                    message.blue = reader.float();
                    break;
                case /* float white */ 7:
                    message.white = reader.float();
                    break;
                case /* float color_temperature */ 8:
                    message.colorTemperature = reader.float();
                    break;
                case /* float cold_white */ 12:
                    message.coldWhite = reader.float();
                    break;
                case /* float warm_white */ 13:
                    message.warmWhite = reader.float();
                    break;
                case /* string effect */ 9:
                    message.effect = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LightStateResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* fixed32 key = 1; */
        if (message.key !== 0)
            writer.tag(1, WireType.Bit32).fixed32(message.key);
        /* bool state = 2; */
        if (message.state !== false)
            writer.tag(2, WireType.Varint).bool(message.state);
        /* float brightness = 3; */
        if (message.brightness !== 0)
            writer.tag(3, WireType.Bit32).float(message.brightness);
        /* int32 color_mode = 11; */
        if (message.colorMode !== 0)
            writer.tag(11, WireType.Varint).int32(message.colorMode);
        /* float color_brightness = 10; */
        if (message.colorBrightness !== 0)
            writer.tag(10, WireType.Bit32).float(message.colorBrightness);
        /* float red = 4; */
        if (message.red !== 0)
            writer.tag(4, WireType.Bit32).float(message.red);
        /* float green = 5; */
        if (message.green !== 0)
            writer.tag(5, WireType.Bit32).float(message.green);
        /* float blue = 6; */
        if (message.blue !== 0)
            writer.tag(6, WireType.Bit32).float(message.blue);
        /* float white = 7; */
        if (message.white !== 0)
            writer.tag(7, WireType.Bit32).float(message.white);
        /* float color_temperature = 8; */
        if (message.colorTemperature !== 0)
            writer.tag(8, WireType.Bit32).float(message.colorTemperature);
        /* float cold_white = 12; */
        if (message.coldWhite !== 0)
            writer.tag(12, WireType.Bit32).float(message.coldWhite);
        /* float warm_white = 13; */
        if (message.warmWhite !== 0)
            writer.tag(13, WireType.Bit32).float(message.warmWhite);
        /* string effect = 9; */
        if (message.effect !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.effect);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message LightStateResponse
 */
export const LightStateResponse = new LightStateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LightCommandRequest$Type extends MessageType<LightCommandRequest> {
    constructor() {
        super("LightCommandRequest", [
            { no: 1, name: "key", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ },
            { no: 2, name: "has_state", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "state", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "has_brightness", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "brightness", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 22, name: "has_color_mode", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 23, name: "color_mode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 20, name: "has_color_brightness", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 21, name: "color_brightness", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 6, name: "has_rgb", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "red", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 8, name: "green", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 9, name: "blue", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 10, name: "has_white", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 11, name: "white", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 12, name: "has_color_temperature", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 13, name: "color_temperature", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 24, name: "has_cold_white", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 25, name: "cold_white", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 26, name: "has_warm_white", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 27, name: "warm_white", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 14, name: "has_transition_length", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 15, name: "transition_length", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 16, name: "has_flash_length", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 17, name: "flash_length", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 18, name: "has_effect", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 19, name: "effect", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { id: 32, source: "SOURCE_CLIENT", ifdef: "USE_LIGHT", no_delay: true });
    }
    create(value?: PartialMessage<LightCommandRequest>): LightCommandRequest {
        const message = { key: 0, hasState: false, state: false, hasBrightness: false, brightness: 0, hasColorMode: false, colorMode: 0, hasColorBrightness: false, colorBrightness: 0, hasRgb: false, red: 0, green: 0, blue: 0, hasWhite: false, white: 0, hasColorTemperature: false, colorTemperature: 0, hasColdWhite: false, coldWhite: 0, hasWarmWhite: false, warmWhite: 0, hasTransitionLength: false, transitionLength: 0, hasFlashLength: false, flashLength: 0, hasEffect: false, effect: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<LightCommandRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LightCommandRequest): LightCommandRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* fixed32 key */ 1:
                    message.key = reader.fixed32();
                    break;
                case /* bool has_state */ 2:
                    message.hasState = reader.bool();
                    break;
                case /* bool state */ 3:
                    message.state = reader.bool();
                    break;
                case /* bool has_brightness */ 4:
                    message.hasBrightness = reader.bool();
                    break;
                case /* float brightness */ 5:
                    message.brightness = reader.float();
                    break;
                case /* bool has_color_mode */ 22:
                    message.hasColorMode = reader.bool();
                    break;
                case /* int32 color_mode */ 23:
                    message.colorMode = reader.int32();
                    break;
                case /* bool has_color_brightness */ 20:
                    message.hasColorBrightness = reader.bool();
                    break;
                case /* float color_brightness */ 21:
                    message.colorBrightness = reader.float();
                    break;
                case /* bool has_rgb */ 6:
                    message.hasRgb = reader.bool();
                    break;
                case /* float red */ 7:
                    message.red = reader.float();
                    break;
                case /* float green */ 8:
                    message.green = reader.float();
                    break;
                case /* float blue */ 9:
                    message.blue = reader.float();
                    break;
                case /* bool has_white */ 10:
                    message.hasWhite = reader.bool();
                    break;
                case /* float white */ 11:
                    message.white = reader.float();
                    break;
                case /* bool has_color_temperature */ 12:
                    message.hasColorTemperature = reader.bool();
                    break;
                case /* float color_temperature */ 13:
                    message.colorTemperature = reader.float();
                    break;
                case /* bool has_cold_white */ 24:
                    message.hasColdWhite = reader.bool();
                    break;
                case /* float cold_white */ 25:
                    message.coldWhite = reader.float();
                    break;
                case /* bool has_warm_white */ 26:
                    message.hasWarmWhite = reader.bool();
                    break;
                case /* float warm_white */ 27:
                    message.warmWhite = reader.float();
                    break;
                case /* bool has_transition_length */ 14:
                    message.hasTransitionLength = reader.bool();
                    break;
                case /* uint32 transition_length */ 15:
                    message.transitionLength = reader.uint32();
                    break;
                case /* bool has_flash_length */ 16:
                    message.hasFlashLength = reader.bool();
                    break;
                case /* uint32 flash_length */ 17:
                    message.flashLength = reader.uint32();
                    break;
                case /* bool has_effect */ 18:
                    message.hasEffect = reader.bool();
                    break;
                case /* string effect */ 19:
                    message.effect = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LightCommandRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* fixed32 key = 1; */
        if (message.key !== 0)
            writer.tag(1, WireType.Bit32).fixed32(message.key);
        /* bool has_state = 2; */
        if (message.hasState !== false)
            writer.tag(2, WireType.Varint).bool(message.hasState);
        /* bool state = 3; */
        if (message.state !== false)
            writer.tag(3, WireType.Varint).bool(message.state);
        /* bool has_brightness = 4; */
        if (message.hasBrightness !== false)
            writer.tag(4, WireType.Varint).bool(message.hasBrightness);
        /* float brightness = 5; */
        if (message.brightness !== 0)
            writer.tag(5, WireType.Bit32).float(message.brightness);
        /* bool has_color_mode = 22; */
        if (message.hasColorMode !== false)
            writer.tag(22, WireType.Varint).bool(message.hasColorMode);
        /* int32 color_mode = 23; */
        if (message.colorMode !== 0)
            writer.tag(23, WireType.Varint).int32(message.colorMode);
        /* bool has_color_brightness = 20; */
        if (message.hasColorBrightness !== false)
            writer.tag(20, WireType.Varint).bool(message.hasColorBrightness);
        /* float color_brightness = 21; */
        if (message.colorBrightness !== 0)
            writer.tag(21, WireType.Bit32).float(message.colorBrightness);
        /* bool has_rgb = 6; */
        if (message.hasRgb !== false)
            writer.tag(6, WireType.Varint).bool(message.hasRgb);
        /* float red = 7; */
        if (message.red !== 0)
            writer.tag(7, WireType.Bit32).float(message.red);
        /* float green = 8; */
        if (message.green !== 0)
            writer.tag(8, WireType.Bit32).float(message.green);
        /* float blue = 9; */
        if (message.blue !== 0)
            writer.tag(9, WireType.Bit32).float(message.blue);
        /* bool has_white = 10; */
        if (message.hasWhite !== false)
            writer.tag(10, WireType.Varint).bool(message.hasWhite);
        /* float white = 11; */
        if (message.white !== 0)
            writer.tag(11, WireType.Bit32).float(message.white);
        /* bool has_color_temperature = 12; */
        if (message.hasColorTemperature !== false)
            writer.tag(12, WireType.Varint).bool(message.hasColorTemperature);
        /* float color_temperature = 13; */
        if (message.colorTemperature !== 0)
            writer.tag(13, WireType.Bit32).float(message.colorTemperature);
        /* bool has_cold_white = 24; */
        if (message.hasColdWhite !== false)
            writer.tag(24, WireType.Varint).bool(message.hasColdWhite);
        /* float cold_white = 25; */
        if (message.coldWhite !== 0)
            writer.tag(25, WireType.Bit32).float(message.coldWhite);
        /* bool has_warm_white = 26; */
        if (message.hasWarmWhite !== false)
            writer.tag(26, WireType.Varint).bool(message.hasWarmWhite);
        /* float warm_white = 27; */
        if (message.warmWhite !== 0)
            writer.tag(27, WireType.Bit32).float(message.warmWhite);
        /* bool has_transition_length = 14; */
        if (message.hasTransitionLength !== false)
            writer.tag(14, WireType.Varint).bool(message.hasTransitionLength);
        /* uint32 transition_length = 15; */
        if (message.transitionLength !== 0)
            writer.tag(15, WireType.Varint).uint32(message.transitionLength);
        /* bool has_flash_length = 16; */
        if (message.hasFlashLength !== false)
            writer.tag(16, WireType.Varint).bool(message.hasFlashLength);
        /* uint32 flash_length = 17; */
        if (message.flashLength !== 0)
            writer.tag(17, WireType.Varint).uint32(message.flashLength);
        /* bool has_effect = 18; */
        if (message.hasEffect !== false)
            writer.tag(18, WireType.Varint).bool(message.hasEffect);
        /* string effect = 19; */
        if (message.effect !== "")
            writer.tag(19, WireType.LengthDelimited).string(message.effect);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message LightCommandRequest
 */
export const LightCommandRequest = new LightCommandRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListEntitiesSensorResponse$Type extends MessageType<ListEntitiesSensorResponse> {
    constructor() {
        super("ListEntitiesSensorResponse", [
            { no: 1, name: "object_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "key", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ },
            { no: 3, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "unique_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "icon", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "unit_of_measurement", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "accuracy_decimals", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "force_update", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "device_class", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "state_class", kind: "enum", T: () => ["SensorStateClass", SensorStateClass] },
            { no: 11, name: "last_reset_type", kind: "enum", T: () => ["SensorLastResetType", SensorLastResetType] },
            { no: 12, name: "disabled_by_default", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 13, name: "entity_category", kind: "enum", T: () => ["EntityCategory", EntityCategory, "ENTITY_CATEGORY_"] }
        ], { id: 16, source: "SOURCE_SERVER", ifdef: "USE_SENSOR" });
    }
    create(value?: PartialMessage<ListEntitiesSensorResponse>): ListEntitiesSensorResponse {
        const message = { objectId: "", key: 0, name: "", uniqueId: "", icon: "", unitOfMeasurement: "", accuracyDecimals: 0, forceUpdate: false, deviceClass: "", stateClass: 0, lastResetType: 0, disabledByDefault: false, entityCategory: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListEntitiesSensorResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListEntitiesSensorResponse): ListEntitiesSensorResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string object_id */ 1:
                    message.objectId = reader.string();
                    break;
                case /* fixed32 key */ 2:
                    message.key = reader.fixed32();
                    break;
                case /* string name */ 3:
                    message.name = reader.string();
                    break;
                case /* string unique_id */ 4:
                    message.uniqueId = reader.string();
                    break;
                case /* string icon */ 5:
                    message.icon = reader.string();
                    break;
                case /* string unit_of_measurement */ 6:
                    message.unitOfMeasurement = reader.string();
                    break;
                case /* int32 accuracy_decimals */ 7:
                    message.accuracyDecimals = reader.int32();
                    break;
                case /* bool force_update */ 8:
                    message.forceUpdate = reader.bool();
                    break;
                case /* string device_class */ 9:
                    message.deviceClass = reader.string();
                    break;
                case /* SensorStateClass state_class */ 10:
                    message.stateClass = reader.int32();
                    break;
                case /* SensorLastResetType last_reset_type */ 11:
                    message.lastResetType = reader.int32();
                    break;
                case /* bool disabled_by_default */ 12:
                    message.disabledByDefault = reader.bool();
                    break;
                case /* EntityCategory entity_category */ 13:
                    message.entityCategory = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListEntitiesSensorResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string object_id = 1; */
        if (message.objectId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.objectId);
        /* fixed32 key = 2; */
        if (message.key !== 0)
            writer.tag(2, WireType.Bit32).fixed32(message.key);
        /* string name = 3; */
        if (message.name !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.name);
        /* string unique_id = 4; */
        if (message.uniqueId !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.uniqueId);
        /* string icon = 5; */
        if (message.icon !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.icon);
        /* string unit_of_measurement = 6; */
        if (message.unitOfMeasurement !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.unitOfMeasurement);
        /* int32 accuracy_decimals = 7; */
        if (message.accuracyDecimals !== 0)
            writer.tag(7, WireType.Varint).int32(message.accuracyDecimals);
        /* bool force_update = 8; */
        if (message.forceUpdate !== false)
            writer.tag(8, WireType.Varint).bool(message.forceUpdate);
        /* string device_class = 9; */
        if (message.deviceClass !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.deviceClass);
        /* SensorStateClass state_class = 10; */
        if (message.stateClass !== 0)
            writer.tag(10, WireType.Varint).int32(message.stateClass);
        /* SensorLastResetType last_reset_type = 11; */
        if (message.lastResetType !== 0)
            writer.tag(11, WireType.Varint).int32(message.lastResetType);
        /* bool disabled_by_default = 12; */
        if (message.disabledByDefault !== false)
            writer.tag(12, WireType.Varint).bool(message.disabledByDefault);
        /* EntityCategory entity_category = 13; */
        if (message.entityCategory !== 0)
            writer.tag(13, WireType.Varint).int32(message.entityCategory);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ListEntitiesSensorResponse
 */
export const ListEntitiesSensorResponse = new ListEntitiesSensorResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SensorStateResponse$Type extends MessageType<SensorStateResponse> {
    constructor() {
        super("SensorStateResponse", [
            { no: 1, name: "key", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ },
            { no: 2, name: "state", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "missing_state", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ], { id: 25, source: "SOURCE_SERVER", ifdef: "USE_SENSOR", no_delay: true });
    }
    create(value?: PartialMessage<SensorStateResponse>): SensorStateResponse {
        const message = { key: 0, state: 0, missingState: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SensorStateResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SensorStateResponse): SensorStateResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* fixed32 key */ 1:
                    message.key = reader.fixed32();
                    break;
                case /* float state */ 2:
                    message.state = reader.float();
                    break;
                case /* bool missing_state */ 3:
                    message.missingState = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SensorStateResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* fixed32 key = 1; */
        if (message.key !== 0)
            writer.tag(1, WireType.Bit32).fixed32(message.key);
        /* float state = 2; */
        if (message.state !== 0)
            writer.tag(2, WireType.Bit32).float(message.state);
        /* bool missing_state = 3; */
        if (message.missingState !== false)
            writer.tag(3, WireType.Varint).bool(message.missingState);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SensorStateResponse
 */
export const SensorStateResponse = new SensorStateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListEntitiesSwitchResponse$Type extends MessageType<ListEntitiesSwitchResponse> {
    constructor() {
        super("ListEntitiesSwitchResponse", [
            { no: 1, name: "object_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "key", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ },
            { no: 3, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "unique_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "icon", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "assumed_state", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "disabled_by_default", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "entity_category", kind: "enum", T: () => ["EntityCategory", EntityCategory, "ENTITY_CATEGORY_"] },
            { no: 9, name: "device_class", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { id: 17, source: "SOURCE_SERVER", ifdef: "USE_SWITCH" });
    }
    create(value?: PartialMessage<ListEntitiesSwitchResponse>): ListEntitiesSwitchResponse {
        const message = { objectId: "", key: 0, name: "", uniqueId: "", icon: "", assumedState: false, disabledByDefault: false, entityCategory: 0, deviceClass: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListEntitiesSwitchResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListEntitiesSwitchResponse): ListEntitiesSwitchResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string object_id */ 1:
                    message.objectId = reader.string();
                    break;
                case /* fixed32 key */ 2:
                    message.key = reader.fixed32();
                    break;
                case /* string name */ 3:
                    message.name = reader.string();
                    break;
                case /* string unique_id */ 4:
                    message.uniqueId = reader.string();
                    break;
                case /* string icon */ 5:
                    message.icon = reader.string();
                    break;
                case /* bool assumed_state */ 6:
                    message.assumedState = reader.bool();
                    break;
                case /* bool disabled_by_default */ 7:
                    message.disabledByDefault = reader.bool();
                    break;
                case /* EntityCategory entity_category */ 8:
                    message.entityCategory = reader.int32();
                    break;
                case /* string device_class */ 9:
                    message.deviceClass = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListEntitiesSwitchResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string object_id = 1; */
        if (message.objectId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.objectId);
        /* fixed32 key = 2; */
        if (message.key !== 0)
            writer.tag(2, WireType.Bit32).fixed32(message.key);
        /* string name = 3; */
        if (message.name !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.name);
        /* string unique_id = 4; */
        if (message.uniqueId !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.uniqueId);
        /* string icon = 5; */
        if (message.icon !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.icon);
        /* bool assumed_state = 6; */
        if (message.assumedState !== false)
            writer.tag(6, WireType.Varint).bool(message.assumedState);
        /* bool disabled_by_default = 7; */
        if (message.disabledByDefault !== false)
            writer.tag(7, WireType.Varint).bool(message.disabledByDefault);
        /* EntityCategory entity_category = 8; */
        if (message.entityCategory !== 0)
            writer.tag(8, WireType.Varint).int32(message.entityCategory);
        /* string device_class = 9; */
        if (message.deviceClass !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.deviceClass);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ListEntitiesSwitchResponse
 */
export const ListEntitiesSwitchResponse = new ListEntitiesSwitchResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SwitchStateResponse$Type extends MessageType<SwitchStateResponse> {
    constructor() {
        super("SwitchStateResponse", [
            { no: 1, name: "key", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ },
            { no: 2, name: "state", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ], { id: 26, source: "SOURCE_SERVER", ifdef: "USE_SWITCH", no_delay: true });
    }
    create(value?: PartialMessage<SwitchStateResponse>): SwitchStateResponse {
        const message = { key: 0, state: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SwitchStateResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SwitchStateResponse): SwitchStateResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* fixed32 key */ 1:
                    message.key = reader.fixed32();
                    break;
                case /* bool state */ 2:
                    message.state = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SwitchStateResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* fixed32 key = 1; */
        if (message.key !== 0)
            writer.tag(1, WireType.Bit32).fixed32(message.key);
        /* bool state = 2; */
        if (message.state !== false)
            writer.tag(2, WireType.Varint).bool(message.state);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SwitchStateResponse
 */
export const SwitchStateResponse = new SwitchStateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SwitchCommandRequest$Type extends MessageType<SwitchCommandRequest> {
    constructor() {
        super("SwitchCommandRequest", [
            { no: 1, name: "key", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ },
            { no: 2, name: "state", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ], { id: 33, source: "SOURCE_CLIENT", ifdef: "USE_SWITCH", no_delay: true });
    }
    create(value?: PartialMessage<SwitchCommandRequest>): SwitchCommandRequest {
        const message = { key: 0, state: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SwitchCommandRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SwitchCommandRequest): SwitchCommandRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* fixed32 key */ 1:
                    message.key = reader.fixed32();
                    break;
                case /* bool state */ 2:
                    message.state = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SwitchCommandRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* fixed32 key = 1; */
        if (message.key !== 0)
            writer.tag(1, WireType.Bit32).fixed32(message.key);
        /* bool state = 2; */
        if (message.state !== false)
            writer.tag(2, WireType.Varint).bool(message.state);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SwitchCommandRequest
 */
export const SwitchCommandRequest = new SwitchCommandRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListEntitiesTextSensorResponse$Type extends MessageType<ListEntitiesTextSensorResponse> {
    constructor() {
        super("ListEntitiesTextSensorResponse", [
            { no: 1, name: "object_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "key", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ },
            { no: 3, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "unique_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "icon", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "disabled_by_default", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "entity_category", kind: "enum", T: () => ["EntityCategory", EntityCategory, "ENTITY_CATEGORY_"] }
        ], { id: 18, source: "SOURCE_SERVER", ifdef: "USE_TEXT_SENSOR" });
    }
    create(value?: PartialMessage<ListEntitiesTextSensorResponse>): ListEntitiesTextSensorResponse {
        const message = { objectId: "", key: 0, name: "", uniqueId: "", icon: "", disabledByDefault: false, entityCategory: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListEntitiesTextSensorResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListEntitiesTextSensorResponse): ListEntitiesTextSensorResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string object_id */ 1:
                    message.objectId = reader.string();
                    break;
                case /* fixed32 key */ 2:
                    message.key = reader.fixed32();
                    break;
                case /* string name */ 3:
                    message.name = reader.string();
                    break;
                case /* string unique_id */ 4:
                    message.uniqueId = reader.string();
                    break;
                case /* string icon */ 5:
                    message.icon = reader.string();
                    break;
                case /* bool disabled_by_default */ 6:
                    message.disabledByDefault = reader.bool();
                    break;
                case /* EntityCategory entity_category */ 7:
                    message.entityCategory = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListEntitiesTextSensorResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string object_id = 1; */
        if (message.objectId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.objectId);
        /* fixed32 key = 2; */
        if (message.key !== 0)
            writer.tag(2, WireType.Bit32).fixed32(message.key);
        /* string name = 3; */
        if (message.name !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.name);
        /* string unique_id = 4; */
        if (message.uniqueId !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.uniqueId);
        /* string icon = 5; */
        if (message.icon !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.icon);
        /* bool disabled_by_default = 6; */
        if (message.disabledByDefault !== false)
            writer.tag(6, WireType.Varint).bool(message.disabledByDefault);
        /* EntityCategory entity_category = 7; */
        if (message.entityCategory !== 0)
            writer.tag(7, WireType.Varint).int32(message.entityCategory);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ListEntitiesTextSensorResponse
 */
export const ListEntitiesTextSensorResponse = new ListEntitiesTextSensorResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TextSensorStateResponse$Type extends MessageType<TextSensorStateResponse> {
    constructor() {
        super("TextSensorStateResponse", [
            { no: 1, name: "key", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ },
            { no: 2, name: "state", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "missing_state", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ], { id: 27, source: "SOURCE_SERVER", ifdef: "USE_TEXT_SENSOR", no_delay: true });
    }
    create(value?: PartialMessage<TextSensorStateResponse>): TextSensorStateResponse {
        const message = { key: 0, state: "", missingState: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TextSensorStateResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TextSensorStateResponse): TextSensorStateResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* fixed32 key */ 1:
                    message.key = reader.fixed32();
                    break;
                case /* string state */ 2:
                    message.state = reader.string();
                    break;
                case /* bool missing_state */ 3:
                    message.missingState = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TextSensorStateResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* fixed32 key = 1; */
        if (message.key !== 0)
            writer.tag(1, WireType.Bit32).fixed32(message.key);
        /* string state = 2; */
        if (message.state !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.state);
        /* bool missing_state = 3; */
        if (message.missingState !== false)
            writer.tag(3, WireType.Varint).bool(message.missingState);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TextSensorStateResponse
 */
export const TextSensorStateResponse = new TextSensorStateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeLogsRequest$Type extends MessageType<SubscribeLogsRequest> {
    constructor() {
        super("SubscribeLogsRequest", [
            { no: 1, name: "level", kind: "enum", T: () => ["LogLevel", LogLevel, "LOG_LEVEL_"] },
            { no: 2, name: "dump_config", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ], { id: 28, source: "SOURCE_CLIENT" });
    }
    create(value?: PartialMessage<SubscribeLogsRequest>): SubscribeLogsRequest {
        const message = { level: 0, dumpConfig: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SubscribeLogsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeLogsRequest): SubscribeLogsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* LogLevel level */ 1:
                    message.level = reader.int32();
                    break;
                case /* bool dump_config */ 2:
                    message.dumpConfig = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubscribeLogsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* LogLevel level = 1; */
        if (message.level !== 0)
            writer.tag(1, WireType.Varint).int32(message.level);
        /* bool dump_config = 2; */
        if (message.dumpConfig !== false)
            writer.tag(2, WireType.Varint).bool(message.dumpConfig);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SubscribeLogsRequest
 */
export const SubscribeLogsRequest = new SubscribeLogsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeLogsResponse$Type extends MessageType<SubscribeLogsResponse> {
    constructor() {
        super("SubscribeLogsResponse", [
            { no: 1, name: "level", kind: "enum", T: () => ["LogLevel", LogLevel, "LOG_LEVEL_"] },
            { no: 3, name: "message", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 4, name: "send_failed", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ], { id: 29, source: "SOURCE_SERVER", log: false, no_delay: false });
    }
    create(value?: PartialMessage<SubscribeLogsResponse>): SubscribeLogsResponse {
        const message = { level: 0, message: new Uint8Array(0), sendFailed: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SubscribeLogsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeLogsResponse): SubscribeLogsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* LogLevel level */ 1:
                    message.level = reader.int32();
                    break;
                case /* bytes message */ 3:
                    message.message = reader.bytes();
                    break;
                case /* bool send_failed */ 4:
                    message.sendFailed = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubscribeLogsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* LogLevel level = 1; */
        if (message.level !== 0)
            writer.tag(1, WireType.Varint).int32(message.level);
        /* bytes message = 3; */
        if (message.message.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.message);
        /* bool send_failed = 4; */
        if (message.sendFailed !== false)
            writer.tag(4, WireType.Varint).bool(message.sendFailed);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SubscribeLogsResponse
 */
export const SubscribeLogsResponse = new SubscribeLogsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeHomeassistantServicesRequest$Type extends MessageType<SubscribeHomeassistantServicesRequest> {
    constructor() {
        super("SubscribeHomeassistantServicesRequest", [], { id: 34, source: "SOURCE_CLIENT" });
    }
    create(value?: PartialMessage<SubscribeHomeassistantServicesRequest>): SubscribeHomeassistantServicesRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SubscribeHomeassistantServicesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeHomeassistantServicesRequest): SubscribeHomeassistantServicesRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: SubscribeHomeassistantServicesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SubscribeHomeassistantServicesRequest
 */
export const SubscribeHomeassistantServicesRequest = new SubscribeHomeassistantServicesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HomeassistantServiceMap$Type extends MessageType<HomeassistantServiceMap> {
    constructor() {
        super("HomeassistantServiceMap", [
            { no: 1, name: "key", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "value", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<HomeassistantServiceMap>): HomeassistantServiceMap {
        const message = { key: "", value: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HomeassistantServiceMap>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HomeassistantServiceMap): HomeassistantServiceMap {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string key */ 1:
                    message.key = reader.string();
                    break;
                case /* string value */ 2:
                    message.value = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HomeassistantServiceMap, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string key = 1; */
        if (message.key !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.key);
        /* string value = 2; */
        if (message.value !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message HomeassistantServiceMap
 */
export const HomeassistantServiceMap = new HomeassistantServiceMap$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HomeassistantServiceResponse$Type extends MessageType<HomeassistantServiceResponse> {
    constructor() {
        super("HomeassistantServiceResponse", [
            { no: 1, name: "service", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "data", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => HomeassistantServiceMap },
            { no: 3, name: "data_template", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => HomeassistantServiceMap },
            { no: 4, name: "variables", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => HomeassistantServiceMap },
            { no: 5, name: "is_event", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ], { id: 35, source: "SOURCE_SERVER", no_delay: true });
    }
    create(value?: PartialMessage<HomeassistantServiceResponse>): HomeassistantServiceResponse {
        const message = { service: "", data: [], dataTemplate: [], variables: [], isEvent: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HomeassistantServiceResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HomeassistantServiceResponse): HomeassistantServiceResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string service */ 1:
                    message.service = reader.string();
                    break;
                case /* repeated HomeassistantServiceMap data */ 2:
                    message.data.push(HomeassistantServiceMap.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated HomeassistantServiceMap data_template */ 3:
                    message.dataTemplate.push(HomeassistantServiceMap.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated HomeassistantServiceMap variables */ 4:
                    message.variables.push(HomeassistantServiceMap.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* bool is_event */ 5:
                    message.isEvent = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HomeassistantServiceResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string service = 1; */
        if (message.service !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.service);
        /* repeated HomeassistantServiceMap data = 2; */
        for (let i = 0; i < message.data.length; i++)
            HomeassistantServiceMap.internalBinaryWrite(message.data[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated HomeassistantServiceMap data_template = 3; */
        for (let i = 0; i < message.dataTemplate.length; i++)
            HomeassistantServiceMap.internalBinaryWrite(message.dataTemplate[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated HomeassistantServiceMap variables = 4; */
        for (let i = 0; i < message.variables.length; i++)
            HomeassistantServiceMap.internalBinaryWrite(message.variables[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* bool is_event = 5; */
        if (message.isEvent !== false)
            writer.tag(5, WireType.Varint).bool(message.isEvent);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message HomeassistantServiceResponse
 */
export const HomeassistantServiceResponse = new HomeassistantServiceResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeHomeAssistantStatesRequest$Type extends MessageType<SubscribeHomeAssistantStatesRequest> {
    constructor() {
        super("SubscribeHomeAssistantStatesRequest", [], { id: 38, source: "SOURCE_CLIENT" });
    }
    create(value?: PartialMessage<SubscribeHomeAssistantStatesRequest>): SubscribeHomeAssistantStatesRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SubscribeHomeAssistantStatesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeHomeAssistantStatesRequest): SubscribeHomeAssistantStatesRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: SubscribeHomeAssistantStatesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SubscribeHomeAssistantStatesRequest
 */
export const SubscribeHomeAssistantStatesRequest = new SubscribeHomeAssistantStatesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeHomeAssistantStateResponse$Type extends MessageType<SubscribeHomeAssistantStateResponse> {
    constructor() {
        super("SubscribeHomeAssistantStateResponse", [
            { no: 1, name: "entity_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "attribute", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { id: 39, source: "SOURCE_SERVER" });
    }
    create(value?: PartialMessage<SubscribeHomeAssistantStateResponse>): SubscribeHomeAssistantStateResponse {
        const message = { entityId: "", attribute: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SubscribeHomeAssistantStateResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeHomeAssistantStateResponse): SubscribeHomeAssistantStateResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string entity_id */ 1:
                    message.entityId = reader.string();
                    break;
                case /* string attribute */ 2:
                    message.attribute = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubscribeHomeAssistantStateResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string entity_id = 1; */
        if (message.entityId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.entityId);
        /* string attribute = 2; */
        if (message.attribute !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.attribute);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SubscribeHomeAssistantStateResponse
 */
export const SubscribeHomeAssistantStateResponse = new SubscribeHomeAssistantStateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HomeAssistantStateResponse$Type extends MessageType<HomeAssistantStateResponse> {
    constructor() {
        super("HomeAssistantStateResponse", [
            { no: 1, name: "entity_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "state", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "attribute", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { id: 40, source: "SOURCE_CLIENT", no_delay: true });
    }
    create(value?: PartialMessage<HomeAssistantStateResponse>): HomeAssistantStateResponse {
        const message = { entityId: "", state: "", attribute: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HomeAssistantStateResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HomeAssistantStateResponse): HomeAssistantStateResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string entity_id */ 1:
                    message.entityId = reader.string();
                    break;
                case /* string state */ 2:
                    message.state = reader.string();
                    break;
                case /* string attribute */ 3:
                    message.attribute = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HomeAssistantStateResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string entity_id = 1; */
        if (message.entityId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.entityId);
        /* string state = 2; */
        if (message.state !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.state);
        /* string attribute = 3; */
        if (message.attribute !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.attribute);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message HomeAssistantStateResponse
 */
export const HomeAssistantStateResponse = new HomeAssistantStateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetTimeRequest$Type extends MessageType<GetTimeRequest> {
    constructor() {
        super("GetTimeRequest", [], { id: 36, source: "SOURCE_BOTH" });
    }
    create(value?: PartialMessage<GetTimeRequest>): GetTimeRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetTimeRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetTimeRequest): GetTimeRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: GetTimeRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetTimeRequest
 */
export const GetTimeRequest = new GetTimeRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetTimeResponse$Type extends MessageType<GetTimeResponse> {
    constructor() {
        super("GetTimeResponse", [
            { no: 1, name: "epoch_seconds", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ }
        ], { id: 37, source: "SOURCE_BOTH", no_delay: true });
    }
    create(value?: PartialMessage<GetTimeResponse>): GetTimeResponse {
        const message = { epochSeconds: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetTimeResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetTimeResponse): GetTimeResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* fixed32 epoch_seconds */ 1:
                    message.epochSeconds = reader.fixed32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetTimeResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* fixed32 epoch_seconds = 1; */
        if (message.epochSeconds !== 0)
            writer.tag(1, WireType.Bit32).fixed32(message.epochSeconds);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetTimeResponse
 */
export const GetTimeResponse = new GetTimeResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListEntitiesServicesArgument$Type extends MessageType<ListEntitiesServicesArgument> {
    constructor() {
        super("ListEntitiesServicesArgument", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "type", kind: "enum", T: () => ["ServiceArgType", ServiceArgType, "SERVICE_ARG_TYPE_"] }
        ]);
    }
    create(value?: PartialMessage<ListEntitiesServicesArgument>): ListEntitiesServicesArgument {
        const message = { name: "", type: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListEntitiesServicesArgument>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListEntitiesServicesArgument): ListEntitiesServicesArgument {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* ServiceArgType type */ 2:
                    message.type = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListEntitiesServicesArgument, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* ServiceArgType type = 2; */
        if (message.type !== 0)
            writer.tag(2, WireType.Varint).int32(message.type);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ListEntitiesServicesArgument
 */
export const ListEntitiesServicesArgument = new ListEntitiesServicesArgument$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListEntitiesServicesResponse$Type extends MessageType<ListEntitiesServicesResponse> {
    constructor() {
        super("ListEntitiesServicesResponse", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "key", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ },
            { no: 3, name: "args", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ListEntitiesServicesArgument }
        ], { id: 41, source: "SOURCE_SERVER" });
    }
    create(value?: PartialMessage<ListEntitiesServicesResponse>): ListEntitiesServicesResponse {
        const message = { name: "", key: 0, args: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListEntitiesServicesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListEntitiesServicesResponse): ListEntitiesServicesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* fixed32 key */ 2:
                    message.key = reader.fixed32();
                    break;
                case /* repeated ListEntitiesServicesArgument args */ 3:
                    message.args.push(ListEntitiesServicesArgument.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListEntitiesServicesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* fixed32 key = 2; */
        if (message.key !== 0)
            writer.tag(2, WireType.Bit32).fixed32(message.key);
        /* repeated ListEntitiesServicesArgument args = 3; */
        for (let i = 0; i < message.args.length; i++)
            ListEntitiesServicesArgument.internalBinaryWrite(message.args[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ListEntitiesServicesResponse
 */
export const ListEntitiesServicesResponse = new ListEntitiesServicesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExecuteServiceArgument$Type extends MessageType<ExecuteServiceArgument> {
    constructor() {
        super("ExecuteServiceArgument", [
            { no: 1, name: "bool_", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "legacy_int", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "float_", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "string_", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "int_", kind: "scalar", T: 17 /*ScalarType.SINT32*/ },
            { no: 6, name: "bool_array", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "int_array", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 17 /*ScalarType.SINT32*/ },
            { no: 8, name: "float_array", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 2 /*ScalarType.FLOAT*/ },
            { no: 9, name: "string_array", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ExecuteServiceArgument>): ExecuteServiceArgument {
        const message = { bool: false, legacyInt: 0, float: 0, string: "", int: 0, boolArray: [], intArray: [], floatArray: [], stringArray: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ExecuteServiceArgument>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExecuteServiceArgument): ExecuteServiceArgument {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool bool_ */ 1:
                    message.bool = reader.bool();
                    break;
                case /* int32 legacy_int */ 2:
                    message.legacyInt = reader.int32();
                    break;
                case /* float float_ */ 3:
                    message.float = reader.float();
                    break;
                case /* string string_ */ 4:
                    message.string = reader.string();
                    break;
                case /* sint32 int_ */ 5:
                    message.int = reader.sint32();
                    break;
                case /* repeated bool bool_array = 6 [packed = false];*/ 6:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.boolArray.push(reader.bool());
                    else
                        message.boolArray.push(reader.bool());
                    break;
                case /* repeated sint32 int_array = 7 [packed = false];*/ 7:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.intArray.push(reader.sint32());
                    else
                        message.intArray.push(reader.sint32());
                    break;
                case /* repeated float float_array = 8 [packed = false];*/ 8:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.floatArray.push(reader.float());
                    else
                        message.floatArray.push(reader.float());
                    break;
                case /* repeated string string_array */ 9:
                    message.stringArray.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExecuteServiceArgument, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool bool_ = 1; */
        if (message.bool !== false)
            writer.tag(1, WireType.Varint).bool(message.bool);
        /* int32 legacy_int = 2; */
        if (message.legacyInt !== 0)
            writer.tag(2, WireType.Varint).int32(message.legacyInt);
        /* float float_ = 3; */
        if (message.float !== 0)
            writer.tag(3, WireType.Bit32).float(message.float);
        /* string string_ = 4; */
        if (message.string !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.string);
        /* sint32 int_ = 5; */
        if (message.int !== 0)
            writer.tag(5, WireType.Varint).sint32(message.int);
        /* repeated bool bool_array = 6 [packed = false]; */
        for (let i = 0; i < message.boolArray.length; i++)
            writer.tag(6, WireType.Varint).bool(message.boolArray[i]);
        /* repeated sint32 int_array = 7 [packed = false]; */
        for (let i = 0; i < message.intArray.length; i++)
            writer.tag(7, WireType.Varint).sint32(message.intArray[i]);
        /* repeated float float_array = 8 [packed = false]; */
        for (let i = 0; i < message.floatArray.length; i++)
            writer.tag(8, WireType.Bit32).float(message.floatArray[i]);
        /* repeated string string_array = 9; */
        for (let i = 0; i < message.stringArray.length; i++)
            writer.tag(9, WireType.LengthDelimited).string(message.stringArray[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ExecuteServiceArgument
 */
export const ExecuteServiceArgument = new ExecuteServiceArgument$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExecuteServiceRequest$Type extends MessageType<ExecuteServiceRequest> {
    constructor() {
        super("ExecuteServiceRequest", [
            { no: 1, name: "key", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ },
            { no: 2, name: "args", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ExecuteServiceArgument }
        ], { id: 42, source: "SOURCE_CLIENT", no_delay: true });
    }
    create(value?: PartialMessage<ExecuteServiceRequest>): ExecuteServiceRequest {
        const message = { key: 0, args: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ExecuteServiceRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExecuteServiceRequest): ExecuteServiceRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* fixed32 key */ 1:
                    message.key = reader.fixed32();
                    break;
                case /* repeated ExecuteServiceArgument args */ 2:
                    message.args.push(ExecuteServiceArgument.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExecuteServiceRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* fixed32 key = 1; */
        if (message.key !== 0)
            writer.tag(1, WireType.Bit32).fixed32(message.key);
        /* repeated ExecuteServiceArgument args = 2; */
        for (let i = 0; i < message.args.length; i++)
            ExecuteServiceArgument.internalBinaryWrite(message.args[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ExecuteServiceRequest
 */
export const ExecuteServiceRequest = new ExecuteServiceRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListEntitiesCameraResponse$Type extends MessageType<ListEntitiesCameraResponse> {
    constructor() {
        super("ListEntitiesCameraResponse", [
            { no: 1, name: "object_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "key", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ },
            { no: 3, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "unique_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "disabled_by_default", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "icon", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "entity_category", kind: "enum", T: () => ["EntityCategory", EntityCategory, "ENTITY_CATEGORY_"] }
        ], { id: 43, source: "SOURCE_SERVER", ifdef: "USE_ESP32_CAMERA" });
    }
    create(value?: PartialMessage<ListEntitiesCameraResponse>): ListEntitiesCameraResponse {
        const message = { objectId: "", key: 0, name: "", uniqueId: "", disabledByDefault: false, icon: "", entityCategory: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListEntitiesCameraResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListEntitiesCameraResponse): ListEntitiesCameraResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string object_id */ 1:
                    message.objectId = reader.string();
                    break;
                case /* fixed32 key */ 2:
                    message.key = reader.fixed32();
                    break;
                case /* string name */ 3:
                    message.name = reader.string();
                    break;
                case /* string unique_id */ 4:
                    message.uniqueId = reader.string();
                    break;
                case /* bool disabled_by_default */ 5:
                    message.disabledByDefault = reader.bool();
                    break;
                case /* string icon */ 6:
                    message.icon = reader.string();
                    break;
                case /* EntityCategory entity_category */ 7:
                    message.entityCategory = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListEntitiesCameraResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string object_id = 1; */
        if (message.objectId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.objectId);
        /* fixed32 key = 2; */
        if (message.key !== 0)
            writer.tag(2, WireType.Bit32).fixed32(message.key);
        /* string name = 3; */
        if (message.name !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.name);
        /* string unique_id = 4; */
        if (message.uniqueId !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.uniqueId);
        /* bool disabled_by_default = 5; */
        if (message.disabledByDefault !== false)
            writer.tag(5, WireType.Varint).bool(message.disabledByDefault);
        /* string icon = 6; */
        if (message.icon !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.icon);
        /* EntityCategory entity_category = 7; */
        if (message.entityCategory !== 0)
            writer.tag(7, WireType.Varint).int32(message.entityCategory);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ListEntitiesCameraResponse
 */
export const ListEntitiesCameraResponse = new ListEntitiesCameraResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CameraImageResponse$Type extends MessageType<CameraImageResponse> {
    constructor() {
        super("CameraImageResponse", [
            { no: 1, name: "key", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ },
            { no: 2, name: "data", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "done", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ], { id: 44, source: "SOURCE_SERVER", ifdef: "USE_ESP32_CAMERA" });
    }
    create(value?: PartialMessage<CameraImageResponse>): CameraImageResponse {
        const message = { key: 0, data: new Uint8Array(0), done: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CameraImageResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CameraImageResponse): CameraImageResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* fixed32 key */ 1:
                    message.key = reader.fixed32();
                    break;
                case /* bytes data */ 2:
                    message.data = reader.bytes();
                    break;
                case /* bool done */ 3:
                    message.done = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CameraImageResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* fixed32 key = 1; */
        if (message.key !== 0)
            writer.tag(1, WireType.Bit32).fixed32(message.key);
        /* bytes data = 2; */
        if (message.data.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.data);
        /* bool done = 3; */
        if (message.done !== false)
            writer.tag(3, WireType.Varint).bool(message.done);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CameraImageResponse
 */
export const CameraImageResponse = new CameraImageResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CameraImageRequest$Type extends MessageType<CameraImageRequest> {
    constructor() {
        super("CameraImageRequest", [
            { no: 1, name: "single", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "stream", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ], { id: 45, source: "SOURCE_CLIENT", ifdef: "USE_ESP32_CAMERA", no_delay: true });
    }
    create(value?: PartialMessage<CameraImageRequest>): CameraImageRequest {
        const message = { single: false, stream: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CameraImageRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CameraImageRequest): CameraImageRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool single */ 1:
                    message.single = reader.bool();
                    break;
                case /* bool stream */ 2:
                    message.stream = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CameraImageRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool single = 1; */
        if (message.single !== false)
            writer.tag(1, WireType.Varint).bool(message.single);
        /* bool stream = 2; */
        if (message.stream !== false)
            writer.tag(2, WireType.Varint).bool(message.stream);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CameraImageRequest
 */
export const CameraImageRequest = new CameraImageRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListEntitiesClimateResponse$Type extends MessageType<ListEntitiesClimateResponse> {
    constructor() {
        super("ListEntitiesClimateResponse", [
            { no: 1, name: "object_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "key", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ },
            { no: 3, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "unique_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "supports_current_temperature", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "supports_two_point_target_temperature", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "supported_modes", kind: "enum", repeat: 1 /*RepeatType.PACKED*/, T: () => ["ClimateMode", ClimateMode, "CLIMATE_MODE_"] },
            { no: 8, name: "visual_min_temperature", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 9, name: "visual_max_temperature", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 10, name: "visual_target_temperature_step", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 11, name: "legacy_supports_away", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 12, name: "supports_action", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 13, name: "supported_fan_modes", kind: "enum", repeat: 1 /*RepeatType.PACKED*/, T: () => ["ClimateFanMode", ClimateFanMode] },
            { no: 14, name: "supported_swing_modes", kind: "enum", repeat: 1 /*RepeatType.PACKED*/, T: () => ["ClimateSwingMode", ClimateSwingMode] },
            { no: 15, name: "supported_custom_fan_modes", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 16, name: "supported_presets", kind: "enum", repeat: 1 /*RepeatType.PACKED*/, T: () => ["ClimatePreset", ClimatePreset, "CLIMATE_PRESET_"] },
            { no: 17, name: "supported_custom_presets", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 18, name: "disabled_by_default", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 19, name: "icon", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 20, name: "entity_category", kind: "enum", T: () => ["EntityCategory", EntityCategory, "ENTITY_CATEGORY_"] },
            { no: 21, name: "visual_current_temperature_step", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ], { id: 46, source: "SOURCE_SERVER", ifdef: "USE_CLIMATE" });
    }
    create(value?: PartialMessage<ListEntitiesClimateResponse>): ListEntitiesClimateResponse {
        const message = { objectId: "", key: 0, name: "", uniqueId: "", supportsCurrentTemperature: false, supportsTwoPointTargetTemperature: false, supportedModes: [], visualMinTemperature: 0, visualMaxTemperature: 0, visualTargetTemperatureStep: 0, legacySupportsAway: false, supportsAction: false, supportedFanModes: [], supportedSwingModes: [], supportedCustomFanModes: [], supportedPresets: [], supportedCustomPresets: [], disabledByDefault: false, icon: "", entityCategory: 0, visualCurrentTemperatureStep: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListEntitiesClimateResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListEntitiesClimateResponse): ListEntitiesClimateResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string object_id */ 1:
                    message.objectId = reader.string();
                    break;
                case /* fixed32 key */ 2:
                    message.key = reader.fixed32();
                    break;
                case /* string name */ 3:
                    message.name = reader.string();
                    break;
                case /* string unique_id */ 4:
                    message.uniqueId = reader.string();
                    break;
                case /* bool supports_current_temperature */ 5:
                    message.supportsCurrentTemperature = reader.bool();
                    break;
                case /* bool supports_two_point_target_temperature */ 6:
                    message.supportsTwoPointTargetTemperature = reader.bool();
                    break;
                case /* repeated ClimateMode supported_modes */ 7:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.supportedModes.push(reader.int32());
                    else
                        message.supportedModes.push(reader.int32());
                    break;
                case /* float visual_min_temperature */ 8:
                    message.visualMinTemperature = reader.float();
                    break;
                case /* float visual_max_temperature */ 9:
                    message.visualMaxTemperature = reader.float();
                    break;
                case /* float visual_target_temperature_step */ 10:
                    message.visualTargetTemperatureStep = reader.float();
                    break;
                case /* bool legacy_supports_away */ 11:
                    message.legacySupportsAway = reader.bool();
                    break;
                case /* bool supports_action */ 12:
                    message.supportsAction = reader.bool();
                    break;
                case /* repeated ClimateFanMode supported_fan_modes */ 13:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.supportedFanModes.push(reader.int32());
                    else
                        message.supportedFanModes.push(reader.int32());
                    break;
                case /* repeated ClimateSwingMode supported_swing_modes */ 14:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.supportedSwingModes.push(reader.int32());
                    else
                        message.supportedSwingModes.push(reader.int32());
                    break;
                case /* repeated string supported_custom_fan_modes */ 15:
                    message.supportedCustomFanModes.push(reader.string());
                    break;
                case /* repeated ClimatePreset supported_presets */ 16:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.supportedPresets.push(reader.int32());
                    else
                        message.supportedPresets.push(reader.int32());
                    break;
                case /* repeated string supported_custom_presets */ 17:
                    message.supportedCustomPresets.push(reader.string());
                    break;
                case /* bool disabled_by_default */ 18:
                    message.disabledByDefault = reader.bool();
                    break;
                case /* string icon */ 19:
                    message.icon = reader.string();
                    break;
                case /* EntityCategory entity_category */ 20:
                    message.entityCategory = reader.int32();
                    break;
                case /* float visual_current_temperature_step */ 21:
                    message.visualCurrentTemperatureStep = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListEntitiesClimateResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string object_id = 1; */
        if (message.objectId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.objectId);
        /* fixed32 key = 2; */
        if (message.key !== 0)
            writer.tag(2, WireType.Bit32).fixed32(message.key);
        /* string name = 3; */
        if (message.name !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.name);
        /* string unique_id = 4; */
        if (message.uniqueId !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.uniqueId);
        /* bool supports_current_temperature = 5; */
        if (message.supportsCurrentTemperature !== false)
            writer.tag(5, WireType.Varint).bool(message.supportsCurrentTemperature);
        /* bool supports_two_point_target_temperature = 6; */
        if (message.supportsTwoPointTargetTemperature !== false)
            writer.tag(6, WireType.Varint).bool(message.supportsTwoPointTargetTemperature);
        /* repeated ClimateMode supported_modes = 7; */
        if (message.supportedModes.length) {
            writer.tag(7, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.supportedModes.length; i++)
                writer.int32(message.supportedModes[i]);
            writer.join();
        }
        /* float visual_min_temperature = 8; */
        if (message.visualMinTemperature !== 0)
            writer.tag(8, WireType.Bit32).float(message.visualMinTemperature);
        /* float visual_max_temperature = 9; */
        if (message.visualMaxTemperature !== 0)
            writer.tag(9, WireType.Bit32).float(message.visualMaxTemperature);
        /* float visual_target_temperature_step = 10; */
        if (message.visualTargetTemperatureStep !== 0)
            writer.tag(10, WireType.Bit32).float(message.visualTargetTemperatureStep);
        /* bool legacy_supports_away = 11; */
        if (message.legacySupportsAway !== false)
            writer.tag(11, WireType.Varint).bool(message.legacySupportsAway);
        /* bool supports_action = 12; */
        if (message.supportsAction !== false)
            writer.tag(12, WireType.Varint).bool(message.supportsAction);
        /* repeated ClimateFanMode supported_fan_modes = 13; */
        if (message.supportedFanModes.length) {
            writer.tag(13, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.supportedFanModes.length; i++)
                writer.int32(message.supportedFanModes[i]);
            writer.join();
        }
        /* repeated ClimateSwingMode supported_swing_modes = 14; */
        if (message.supportedSwingModes.length) {
            writer.tag(14, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.supportedSwingModes.length; i++)
                writer.int32(message.supportedSwingModes[i]);
            writer.join();
        }
        /* repeated string supported_custom_fan_modes = 15; */
        for (let i = 0; i < message.supportedCustomFanModes.length; i++)
            writer.tag(15, WireType.LengthDelimited).string(message.supportedCustomFanModes[i]);
        /* repeated ClimatePreset supported_presets = 16; */
        if (message.supportedPresets.length) {
            writer.tag(16, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.supportedPresets.length; i++)
                writer.int32(message.supportedPresets[i]);
            writer.join();
        }
        /* repeated string supported_custom_presets = 17; */
        for (let i = 0; i < message.supportedCustomPresets.length; i++)
            writer.tag(17, WireType.LengthDelimited).string(message.supportedCustomPresets[i]);
        /* bool disabled_by_default = 18; */
        if (message.disabledByDefault !== false)
            writer.tag(18, WireType.Varint).bool(message.disabledByDefault);
        /* string icon = 19; */
        if (message.icon !== "")
            writer.tag(19, WireType.LengthDelimited).string(message.icon);
        /* EntityCategory entity_category = 20; */
        if (message.entityCategory !== 0)
            writer.tag(20, WireType.Varint).int32(message.entityCategory);
        /* float visual_current_temperature_step = 21; */
        if (message.visualCurrentTemperatureStep !== 0)
            writer.tag(21, WireType.Bit32).float(message.visualCurrentTemperatureStep);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ListEntitiesClimateResponse
 */
export const ListEntitiesClimateResponse = new ListEntitiesClimateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ClimateStateResponse$Type extends MessageType<ClimateStateResponse> {
    constructor() {
        super("ClimateStateResponse", [
            { no: 1, name: "key", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ },
            { no: 2, name: "mode", kind: "enum", T: () => ["ClimateMode", ClimateMode, "CLIMATE_MODE_"] },
            { no: 3, name: "current_temperature", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "target_temperature", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 5, name: "target_temperature_low", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 6, name: "target_temperature_high", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 7, name: "legacy_away", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "action", kind: "enum", T: () => ["ClimateAction", ClimateAction, "CLIMATE_ACTION_"] },
            { no: 9, name: "fan_mode", kind: "enum", T: () => ["ClimateFanMode", ClimateFanMode] },
            { no: 10, name: "swing_mode", kind: "enum", T: () => ["ClimateSwingMode", ClimateSwingMode] },
            { no: 11, name: "custom_fan_mode", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "preset", kind: "enum", T: () => ["ClimatePreset", ClimatePreset, "CLIMATE_PRESET_"] },
            { no: 13, name: "custom_preset", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { id: 47, source: "SOURCE_SERVER", ifdef: "USE_CLIMATE", no_delay: true });
    }
    create(value?: PartialMessage<ClimateStateResponse>): ClimateStateResponse {
        const message = { key: 0, mode: 0, currentTemperature: 0, targetTemperature: 0, targetTemperatureLow: 0, targetTemperatureHigh: 0, legacyAway: false, action: 0, fanMode: 0, swingMode: 0, customFanMode: "", preset: 0, customPreset: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ClimateStateResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ClimateStateResponse): ClimateStateResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* fixed32 key */ 1:
                    message.key = reader.fixed32();
                    break;
                case /* ClimateMode mode */ 2:
                    message.mode = reader.int32();
                    break;
                case /* float current_temperature */ 3:
                    message.currentTemperature = reader.float();
                    break;
                case /* float target_temperature */ 4:
                    message.targetTemperature = reader.float();
                    break;
                case /* float target_temperature_low */ 5:
                    message.targetTemperatureLow = reader.float();
                    break;
                case /* float target_temperature_high */ 6:
                    message.targetTemperatureHigh = reader.float();
                    break;
                case /* bool legacy_away */ 7:
                    message.legacyAway = reader.bool();
                    break;
                case /* ClimateAction action */ 8:
                    message.action = reader.int32();
                    break;
                case /* ClimateFanMode fan_mode */ 9:
                    message.fanMode = reader.int32();
                    break;
                case /* ClimateSwingMode swing_mode */ 10:
                    message.swingMode = reader.int32();
                    break;
                case /* string custom_fan_mode */ 11:
                    message.customFanMode = reader.string();
                    break;
                case /* ClimatePreset preset */ 12:
                    message.preset = reader.int32();
                    break;
                case /* string custom_preset */ 13:
                    message.customPreset = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ClimateStateResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* fixed32 key = 1; */
        if (message.key !== 0)
            writer.tag(1, WireType.Bit32).fixed32(message.key);
        /* ClimateMode mode = 2; */
        if (message.mode !== 0)
            writer.tag(2, WireType.Varint).int32(message.mode);
        /* float current_temperature = 3; */
        if (message.currentTemperature !== 0)
            writer.tag(3, WireType.Bit32).float(message.currentTemperature);
        /* float target_temperature = 4; */
        if (message.targetTemperature !== 0)
            writer.tag(4, WireType.Bit32).float(message.targetTemperature);
        /* float target_temperature_low = 5; */
        if (message.targetTemperatureLow !== 0)
            writer.tag(5, WireType.Bit32).float(message.targetTemperatureLow);
        /* float target_temperature_high = 6; */
        if (message.targetTemperatureHigh !== 0)
            writer.tag(6, WireType.Bit32).float(message.targetTemperatureHigh);
        /* bool legacy_away = 7; */
        if (message.legacyAway !== false)
            writer.tag(7, WireType.Varint).bool(message.legacyAway);
        /* ClimateAction action = 8; */
        if (message.action !== 0)
            writer.tag(8, WireType.Varint).int32(message.action);
        /* ClimateFanMode fan_mode = 9; */
        if (message.fanMode !== 0)
            writer.tag(9, WireType.Varint).int32(message.fanMode);
        /* ClimateSwingMode swing_mode = 10; */
        if (message.swingMode !== 0)
            writer.tag(10, WireType.Varint).int32(message.swingMode);
        /* string custom_fan_mode = 11; */
        if (message.customFanMode !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.customFanMode);
        /* ClimatePreset preset = 12; */
        if (message.preset !== 0)
            writer.tag(12, WireType.Varint).int32(message.preset);
        /* string custom_preset = 13; */
        if (message.customPreset !== "")
            writer.tag(13, WireType.LengthDelimited).string(message.customPreset);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ClimateStateResponse
 */
export const ClimateStateResponse = new ClimateStateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ClimateCommandRequest$Type extends MessageType<ClimateCommandRequest> {
    constructor() {
        super("ClimateCommandRequest", [
            { no: 1, name: "key", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ },
            { no: 2, name: "has_mode", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "mode", kind: "enum", T: () => ["ClimateMode", ClimateMode, "CLIMATE_MODE_"] },
            { no: 4, name: "has_target_temperature", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "target_temperature", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 6, name: "has_target_temperature_low", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "target_temperature_low", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 8, name: "has_target_temperature_high", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "target_temperature_high", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 10, name: "has_legacy_away", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 11, name: "legacy_away", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 12, name: "has_fan_mode", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 13, name: "fan_mode", kind: "enum", T: () => ["ClimateFanMode", ClimateFanMode] },
            { no: 14, name: "has_swing_mode", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 15, name: "swing_mode", kind: "enum", T: () => ["ClimateSwingMode", ClimateSwingMode] },
            { no: 16, name: "has_custom_fan_mode", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 17, name: "custom_fan_mode", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 18, name: "has_preset", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 19, name: "preset", kind: "enum", T: () => ["ClimatePreset", ClimatePreset, "CLIMATE_PRESET_"] },
            { no: 20, name: "has_custom_preset", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 21, name: "custom_preset", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { id: 48, source: "SOURCE_CLIENT", ifdef: "USE_CLIMATE", no_delay: true });
    }
    create(value?: PartialMessage<ClimateCommandRequest>): ClimateCommandRequest {
        const message = { key: 0, hasMode: false, mode: 0, hasTargetTemperature: false, targetTemperature: 0, hasTargetTemperatureLow: false, targetTemperatureLow: 0, hasTargetTemperatureHigh: false, targetTemperatureHigh: 0, hasLegacyAway: false, legacyAway: false, hasFanMode: false, fanMode: 0, hasSwingMode: false, swingMode: 0, hasCustomFanMode: false, customFanMode: "", hasPreset: false, preset: 0, hasCustomPreset: false, customPreset: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ClimateCommandRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ClimateCommandRequest): ClimateCommandRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* fixed32 key */ 1:
                    message.key = reader.fixed32();
                    break;
                case /* bool has_mode */ 2:
                    message.hasMode = reader.bool();
                    break;
                case /* ClimateMode mode */ 3:
                    message.mode = reader.int32();
                    break;
                case /* bool has_target_temperature */ 4:
                    message.hasTargetTemperature = reader.bool();
                    break;
                case /* float target_temperature */ 5:
                    message.targetTemperature = reader.float();
                    break;
                case /* bool has_target_temperature_low */ 6:
                    message.hasTargetTemperatureLow = reader.bool();
                    break;
                case /* float target_temperature_low */ 7:
                    message.targetTemperatureLow = reader.float();
                    break;
                case /* bool has_target_temperature_high */ 8:
                    message.hasTargetTemperatureHigh = reader.bool();
                    break;
                case /* float target_temperature_high */ 9:
                    message.targetTemperatureHigh = reader.float();
                    break;
                case /* bool has_legacy_away */ 10:
                    message.hasLegacyAway = reader.bool();
                    break;
                case /* bool legacy_away */ 11:
                    message.legacyAway = reader.bool();
                    break;
                case /* bool has_fan_mode */ 12:
                    message.hasFanMode = reader.bool();
                    break;
                case /* ClimateFanMode fan_mode */ 13:
                    message.fanMode = reader.int32();
                    break;
                case /* bool has_swing_mode */ 14:
                    message.hasSwingMode = reader.bool();
                    break;
                case /* ClimateSwingMode swing_mode */ 15:
                    message.swingMode = reader.int32();
                    break;
                case /* bool has_custom_fan_mode */ 16:
                    message.hasCustomFanMode = reader.bool();
                    break;
                case /* string custom_fan_mode */ 17:
                    message.customFanMode = reader.string();
                    break;
                case /* bool has_preset */ 18:
                    message.hasPreset = reader.bool();
                    break;
                case /* ClimatePreset preset */ 19:
                    message.preset = reader.int32();
                    break;
                case /* bool has_custom_preset */ 20:
                    message.hasCustomPreset = reader.bool();
                    break;
                case /* string custom_preset */ 21:
                    message.customPreset = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ClimateCommandRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* fixed32 key = 1; */
        if (message.key !== 0)
            writer.tag(1, WireType.Bit32).fixed32(message.key);
        /* bool has_mode = 2; */
        if (message.hasMode !== false)
            writer.tag(2, WireType.Varint).bool(message.hasMode);
        /* ClimateMode mode = 3; */
        if (message.mode !== 0)
            writer.tag(3, WireType.Varint).int32(message.mode);
        /* bool has_target_temperature = 4; */
        if (message.hasTargetTemperature !== false)
            writer.tag(4, WireType.Varint).bool(message.hasTargetTemperature);
        /* float target_temperature = 5; */
        if (message.targetTemperature !== 0)
            writer.tag(5, WireType.Bit32).float(message.targetTemperature);
        /* bool has_target_temperature_low = 6; */
        if (message.hasTargetTemperatureLow !== false)
            writer.tag(6, WireType.Varint).bool(message.hasTargetTemperatureLow);
        /* float target_temperature_low = 7; */
        if (message.targetTemperatureLow !== 0)
            writer.tag(7, WireType.Bit32).float(message.targetTemperatureLow);
        /* bool has_target_temperature_high = 8; */
        if (message.hasTargetTemperatureHigh !== false)
            writer.tag(8, WireType.Varint).bool(message.hasTargetTemperatureHigh);
        /* float target_temperature_high = 9; */
        if (message.targetTemperatureHigh !== 0)
            writer.tag(9, WireType.Bit32).float(message.targetTemperatureHigh);
        /* bool has_legacy_away = 10; */
        if (message.hasLegacyAway !== false)
            writer.tag(10, WireType.Varint).bool(message.hasLegacyAway);
        /* bool legacy_away = 11; */
        if (message.legacyAway !== false)
            writer.tag(11, WireType.Varint).bool(message.legacyAway);
        /* bool has_fan_mode = 12; */
        if (message.hasFanMode !== false)
            writer.tag(12, WireType.Varint).bool(message.hasFanMode);
        /* ClimateFanMode fan_mode = 13; */
        if (message.fanMode !== 0)
            writer.tag(13, WireType.Varint).int32(message.fanMode);
        /* bool has_swing_mode = 14; */
        if (message.hasSwingMode !== false)
            writer.tag(14, WireType.Varint).bool(message.hasSwingMode);
        /* ClimateSwingMode swing_mode = 15; */
        if (message.swingMode !== 0)
            writer.tag(15, WireType.Varint).int32(message.swingMode);
        /* bool has_custom_fan_mode = 16; */
        if (message.hasCustomFanMode !== false)
            writer.tag(16, WireType.Varint).bool(message.hasCustomFanMode);
        /* string custom_fan_mode = 17; */
        if (message.customFanMode !== "")
            writer.tag(17, WireType.LengthDelimited).string(message.customFanMode);
        /* bool has_preset = 18; */
        if (message.hasPreset !== false)
            writer.tag(18, WireType.Varint).bool(message.hasPreset);
        /* ClimatePreset preset = 19; */
        if (message.preset !== 0)
            writer.tag(19, WireType.Varint).int32(message.preset);
        /* bool has_custom_preset = 20; */
        if (message.hasCustomPreset !== false)
            writer.tag(20, WireType.Varint).bool(message.hasCustomPreset);
        /* string custom_preset = 21; */
        if (message.customPreset !== "")
            writer.tag(21, WireType.LengthDelimited).string(message.customPreset);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ClimateCommandRequest
 */
export const ClimateCommandRequest = new ClimateCommandRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListEntitiesNumberResponse$Type extends MessageType<ListEntitiesNumberResponse> {
    constructor() {
        super("ListEntitiesNumberResponse", [
            { no: 1, name: "object_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "key", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ },
            { no: 3, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "unique_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "icon", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "min_value", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 7, name: "max_value", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 8, name: "step", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 9, name: "disabled_by_default", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 10, name: "entity_category", kind: "enum", T: () => ["EntityCategory", EntityCategory, "ENTITY_CATEGORY_"] },
            { no: 11, name: "unit_of_measurement", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "mode", kind: "enum", T: () => ["NumberMode", NumberMode, "NUMBER_MODE_"] },
            { no: 13, name: "device_class", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { id: 49, source: "SOURCE_SERVER", ifdef: "USE_NUMBER" });
    }
    create(value?: PartialMessage<ListEntitiesNumberResponse>): ListEntitiesNumberResponse {
        const message = { objectId: "", key: 0, name: "", uniqueId: "", icon: "", minValue: 0, maxValue: 0, step: 0, disabledByDefault: false, entityCategory: 0, unitOfMeasurement: "", mode: 0, deviceClass: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListEntitiesNumberResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListEntitiesNumberResponse): ListEntitiesNumberResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string object_id */ 1:
                    message.objectId = reader.string();
                    break;
                case /* fixed32 key */ 2:
                    message.key = reader.fixed32();
                    break;
                case /* string name */ 3:
                    message.name = reader.string();
                    break;
                case /* string unique_id */ 4:
                    message.uniqueId = reader.string();
                    break;
                case /* string icon */ 5:
                    message.icon = reader.string();
                    break;
                case /* float min_value */ 6:
                    message.minValue = reader.float();
                    break;
                case /* float max_value */ 7:
                    message.maxValue = reader.float();
                    break;
                case /* float step */ 8:
                    message.step = reader.float();
                    break;
                case /* bool disabled_by_default */ 9:
                    message.disabledByDefault = reader.bool();
                    break;
                case /* EntityCategory entity_category */ 10:
                    message.entityCategory = reader.int32();
                    break;
                case /* string unit_of_measurement */ 11:
                    message.unitOfMeasurement = reader.string();
                    break;
                case /* NumberMode mode */ 12:
                    message.mode = reader.int32();
                    break;
                case /* string device_class */ 13:
                    message.deviceClass = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListEntitiesNumberResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string object_id = 1; */
        if (message.objectId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.objectId);
        /* fixed32 key = 2; */
        if (message.key !== 0)
            writer.tag(2, WireType.Bit32).fixed32(message.key);
        /* string name = 3; */
        if (message.name !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.name);
        /* string unique_id = 4; */
        if (message.uniqueId !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.uniqueId);
        /* string icon = 5; */
        if (message.icon !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.icon);
        /* float min_value = 6; */
        if (message.minValue !== 0)
            writer.tag(6, WireType.Bit32).float(message.minValue);
        /* float max_value = 7; */
        if (message.maxValue !== 0)
            writer.tag(7, WireType.Bit32).float(message.maxValue);
        /* float step = 8; */
        if (message.step !== 0)
            writer.tag(8, WireType.Bit32).float(message.step);
        /* bool disabled_by_default = 9; */
        if (message.disabledByDefault !== false)
            writer.tag(9, WireType.Varint).bool(message.disabledByDefault);
        /* EntityCategory entity_category = 10; */
        if (message.entityCategory !== 0)
            writer.tag(10, WireType.Varint).int32(message.entityCategory);
        /* string unit_of_measurement = 11; */
        if (message.unitOfMeasurement !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.unitOfMeasurement);
        /* NumberMode mode = 12; */
        if (message.mode !== 0)
            writer.tag(12, WireType.Varint).int32(message.mode);
        /* string device_class = 13; */
        if (message.deviceClass !== "")
            writer.tag(13, WireType.LengthDelimited).string(message.deviceClass);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ListEntitiesNumberResponse
 */
export const ListEntitiesNumberResponse = new ListEntitiesNumberResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class NumberStateResponse$Type extends MessageType<NumberStateResponse> {
    constructor() {
        super("NumberStateResponse", [
            { no: 1, name: "key", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ },
            { no: 2, name: "state", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "missing_state", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ], { id: 50, source: "SOURCE_SERVER", ifdef: "USE_NUMBER", no_delay: true });
    }
    create(value?: PartialMessage<NumberStateResponse>): NumberStateResponse {
        const message = { key: 0, state: 0, missingState: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<NumberStateResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: NumberStateResponse): NumberStateResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* fixed32 key */ 1:
                    message.key = reader.fixed32();
                    break;
                case /* float state */ 2:
                    message.state = reader.float();
                    break;
                case /* bool missing_state */ 3:
                    message.missingState = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: NumberStateResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* fixed32 key = 1; */
        if (message.key !== 0)
            writer.tag(1, WireType.Bit32).fixed32(message.key);
        /* float state = 2; */
        if (message.state !== 0)
            writer.tag(2, WireType.Bit32).float(message.state);
        /* bool missing_state = 3; */
        if (message.missingState !== false)
            writer.tag(3, WireType.Varint).bool(message.missingState);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message NumberStateResponse
 */
export const NumberStateResponse = new NumberStateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class NumberCommandRequest$Type extends MessageType<NumberCommandRequest> {
    constructor() {
        super("NumberCommandRequest", [
            { no: 1, name: "key", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ },
            { no: 2, name: "state", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ], { id: 51, source: "SOURCE_CLIENT", ifdef: "USE_NUMBER", no_delay: true });
    }
    create(value?: PartialMessage<NumberCommandRequest>): NumberCommandRequest {
        const message = { key: 0, state: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<NumberCommandRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: NumberCommandRequest): NumberCommandRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* fixed32 key */ 1:
                    message.key = reader.fixed32();
                    break;
                case /* float state */ 2:
                    message.state = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: NumberCommandRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* fixed32 key = 1; */
        if (message.key !== 0)
            writer.tag(1, WireType.Bit32).fixed32(message.key);
        /* float state = 2; */
        if (message.state !== 0)
            writer.tag(2, WireType.Bit32).float(message.state);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message NumberCommandRequest
 */
export const NumberCommandRequest = new NumberCommandRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListEntitiesSelectResponse$Type extends MessageType<ListEntitiesSelectResponse> {
    constructor() {
        super("ListEntitiesSelectResponse", [
            { no: 1, name: "object_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "key", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ },
            { no: 3, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "unique_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "icon", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "options", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "disabled_by_default", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "entity_category", kind: "enum", T: () => ["EntityCategory", EntityCategory, "ENTITY_CATEGORY_"] }
        ], { id: 52, source: "SOURCE_SERVER", ifdef: "USE_SELECT" });
    }
    create(value?: PartialMessage<ListEntitiesSelectResponse>): ListEntitiesSelectResponse {
        const message = { objectId: "", key: 0, name: "", uniqueId: "", icon: "", options: [], disabledByDefault: false, entityCategory: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListEntitiesSelectResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListEntitiesSelectResponse): ListEntitiesSelectResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string object_id */ 1:
                    message.objectId = reader.string();
                    break;
                case /* fixed32 key */ 2:
                    message.key = reader.fixed32();
                    break;
                case /* string name */ 3:
                    message.name = reader.string();
                    break;
                case /* string unique_id */ 4:
                    message.uniqueId = reader.string();
                    break;
                case /* string icon */ 5:
                    message.icon = reader.string();
                    break;
                case /* repeated string options */ 6:
                    message.options.push(reader.string());
                    break;
                case /* bool disabled_by_default */ 7:
                    message.disabledByDefault = reader.bool();
                    break;
                case /* EntityCategory entity_category */ 8:
                    message.entityCategory = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListEntitiesSelectResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string object_id = 1; */
        if (message.objectId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.objectId);
        /* fixed32 key = 2; */
        if (message.key !== 0)
            writer.tag(2, WireType.Bit32).fixed32(message.key);
        /* string name = 3; */
        if (message.name !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.name);
        /* string unique_id = 4; */
        if (message.uniqueId !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.uniqueId);
        /* string icon = 5; */
        if (message.icon !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.icon);
        /* repeated string options = 6; */
        for (let i = 0; i < message.options.length; i++)
            writer.tag(6, WireType.LengthDelimited).string(message.options[i]);
        /* bool disabled_by_default = 7; */
        if (message.disabledByDefault !== false)
            writer.tag(7, WireType.Varint).bool(message.disabledByDefault);
        /* EntityCategory entity_category = 8; */
        if (message.entityCategory !== 0)
            writer.tag(8, WireType.Varint).int32(message.entityCategory);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ListEntitiesSelectResponse
 */
export const ListEntitiesSelectResponse = new ListEntitiesSelectResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SelectStateResponse$Type extends MessageType<SelectStateResponse> {
    constructor() {
        super("SelectStateResponse", [
            { no: 1, name: "key", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ },
            { no: 2, name: "state", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "missing_state", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ], { id: 53, source: "SOURCE_SERVER", ifdef: "USE_SELECT", no_delay: true });
    }
    create(value?: PartialMessage<SelectStateResponse>): SelectStateResponse {
        const message = { key: 0, state: "", missingState: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SelectStateResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SelectStateResponse): SelectStateResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* fixed32 key */ 1:
                    message.key = reader.fixed32();
                    break;
                case /* string state */ 2:
                    message.state = reader.string();
                    break;
                case /* bool missing_state */ 3:
                    message.missingState = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SelectStateResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* fixed32 key = 1; */
        if (message.key !== 0)
            writer.tag(1, WireType.Bit32).fixed32(message.key);
        /* string state = 2; */
        if (message.state !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.state);
        /* bool missing_state = 3; */
        if (message.missingState !== false)
            writer.tag(3, WireType.Varint).bool(message.missingState);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SelectStateResponse
 */
export const SelectStateResponse = new SelectStateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SelectCommandRequest$Type extends MessageType<SelectCommandRequest> {
    constructor() {
        super("SelectCommandRequest", [
            { no: 1, name: "key", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ },
            { no: 2, name: "state", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { id: 54, source: "SOURCE_CLIENT", ifdef: "USE_SELECT", no_delay: true });
    }
    create(value?: PartialMessage<SelectCommandRequest>): SelectCommandRequest {
        const message = { key: 0, state: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SelectCommandRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SelectCommandRequest): SelectCommandRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* fixed32 key */ 1:
                    message.key = reader.fixed32();
                    break;
                case /* string state */ 2:
                    message.state = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SelectCommandRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* fixed32 key = 1; */
        if (message.key !== 0)
            writer.tag(1, WireType.Bit32).fixed32(message.key);
        /* string state = 2; */
        if (message.state !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.state);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SelectCommandRequest
 */
export const SelectCommandRequest = new SelectCommandRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListEntitiesSirenResponse$Type extends MessageType<ListEntitiesSirenResponse> {
    constructor() {
        super("ListEntitiesSirenResponse", [
            { no: 1, name: "object_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "key", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ },
            { no: 3, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "unique_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "icon", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "disabled_by_default", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "tones", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "supports_duration", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "supports_volume", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 10, name: "entity_category", kind: "enum", T: () => ["EntityCategory", EntityCategory, "ENTITY_CATEGORY_"] }
        ], { id: 55, source: "SOURCE_SERVER", ifdef: "USE_SIREN" });
    }
    create(value?: PartialMessage<ListEntitiesSirenResponse>): ListEntitiesSirenResponse {
        const message = { objectId: "", key: 0, name: "", uniqueId: "", icon: "", disabledByDefault: false, tones: [], supportsDuration: false, supportsVolume: false, entityCategory: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListEntitiesSirenResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListEntitiesSirenResponse): ListEntitiesSirenResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string object_id */ 1:
                    message.objectId = reader.string();
                    break;
                case /* fixed32 key */ 2:
                    message.key = reader.fixed32();
                    break;
                case /* string name */ 3:
                    message.name = reader.string();
                    break;
                case /* string unique_id */ 4:
                    message.uniqueId = reader.string();
                    break;
                case /* string icon */ 5:
                    message.icon = reader.string();
                    break;
                case /* bool disabled_by_default */ 6:
                    message.disabledByDefault = reader.bool();
                    break;
                case /* repeated string tones */ 7:
                    message.tones.push(reader.string());
                    break;
                case /* bool supports_duration */ 8:
                    message.supportsDuration = reader.bool();
                    break;
                case /* bool supports_volume */ 9:
                    message.supportsVolume = reader.bool();
                    break;
                case /* EntityCategory entity_category */ 10:
                    message.entityCategory = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListEntitiesSirenResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string object_id = 1; */
        if (message.objectId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.objectId);
        /* fixed32 key = 2; */
        if (message.key !== 0)
            writer.tag(2, WireType.Bit32).fixed32(message.key);
        /* string name = 3; */
        if (message.name !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.name);
        /* string unique_id = 4; */
        if (message.uniqueId !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.uniqueId);
        /* string icon = 5; */
        if (message.icon !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.icon);
        /* bool disabled_by_default = 6; */
        if (message.disabledByDefault !== false)
            writer.tag(6, WireType.Varint).bool(message.disabledByDefault);
        /* repeated string tones = 7; */
        for (let i = 0; i < message.tones.length; i++)
            writer.tag(7, WireType.LengthDelimited).string(message.tones[i]);
        /* bool supports_duration = 8; */
        if (message.supportsDuration !== false)
            writer.tag(8, WireType.Varint).bool(message.supportsDuration);
        /* bool supports_volume = 9; */
        if (message.supportsVolume !== false)
            writer.tag(9, WireType.Varint).bool(message.supportsVolume);
        /* EntityCategory entity_category = 10; */
        if (message.entityCategory !== 0)
            writer.tag(10, WireType.Varint).int32(message.entityCategory);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ListEntitiesSirenResponse
 */
export const ListEntitiesSirenResponse = new ListEntitiesSirenResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SirenStateResponse$Type extends MessageType<SirenStateResponse> {
    constructor() {
        super("SirenStateResponse", [
            { no: 1, name: "key", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ },
            { no: 2, name: "state", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ], { id: 56, source: "SOURCE_SERVER", ifdef: "USE_SIREN", no_delay: true });
    }
    create(value?: PartialMessage<SirenStateResponse>): SirenStateResponse {
        const message = { key: 0, state: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SirenStateResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SirenStateResponse): SirenStateResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* fixed32 key */ 1:
                    message.key = reader.fixed32();
                    break;
                case /* bool state */ 2:
                    message.state = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SirenStateResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* fixed32 key = 1; */
        if (message.key !== 0)
            writer.tag(1, WireType.Bit32).fixed32(message.key);
        /* bool state = 2; */
        if (message.state !== false)
            writer.tag(2, WireType.Varint).bool(message.state);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SirenStateResponse
 */
export const SirenStateResponse = new SirenStateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SirenCommandRequest$Type extends MessageType<SirenCommandRequest> {
    constructor() {
        super("SirenCommandRequest", [
            { no: 1, name: "key", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ },
            { no: 2, name: "has_state", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "state", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "has_tone", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "tone", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "has_duration", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "duration", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "has_volume", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "volume", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ], { id: 57, source: "SOURCE_CLIENT", ifdef: "USE_SIREN", no_delay: true });
    }
    create(value?: PartialMessage<SirenCommandRequest>): SirenCommandRequest {
        const message = { key: 0, hasState: false, state: false, hasTone: false, tone: "", hasDuration: false, duration: 0, hasVolume: false, volume: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SirenCommandRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SirenCommandRequest): SirenCommandRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* fixed32 key */ 1:
                    message.key = reader.fixed32();
                    break;
                case /* bool has_state */ 2:
                    message.hasState = reader.bool();
                    break;
                case /* bool state */ 3:
                    message.state = reader.bool();
                    break;
                case /* bool has_tone */ 4:
                    message.hasTone = reader.bool();
                    break;
                case /* string tone */ 5:
                    message.tone = reader.string();
                    break;
                case /* bool has_duration */ 6:
                    message.hasDuration = reader.bool();
                    break;
                case /* uint32 duration */ 7:
                    message.duration = reader.uint32();
                    break;
                case /* bool has_volume */ 8:
                    message.hasVolume = reader.bool();
                    break;
                case /* float volume */ 9:
                    message.volume = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SirenCommandRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* fixed32 key = 1; */
        if (message.key !== 0)
            writer.tag(1, WireType.Bit32).fixed32(message.key);
        /* bool has_state = 2; */
        if (message.hasState !== false)
            writer.tag(2, WireType.Varint).bool(message.hasState);
        /* bool state = 3; */
        if (message.state !== false)
            writer.tag(3, WireType.Varint).bool(message.state);
        /* bool has_tone = 4; */
        if (message.hasTone !== false)
            writer.tag(4, WireType.Varint).bool(message.hasTone);
        /* string tone = 5; */
        if (message.tone !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.tone);
        /* bool has_duration = 6; */
        if (message.hasDuration !== false)
            writer.tag(6, WireType.Varint).bool(message.hasDuration);
        /* uint32 duration = 7; */
        if (message.duration !== 0)
            writer.tag(7, WireType.Varint).uint32(message.duration);
        /* bool has_volume = 8; */
        if (message.hasVolume !== false)
            writer.tag(8, WireType.Varint).bool(message.hasVolume);
        /* float volume = 9; */
        if (message.volume !== 0)
            writer.tag(9, WireType.Bit32).float(message.volume);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SirenCommandRequest
 */
export const SirenCommandRequest = new SirenCommandRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListEntitiesLockResponse$Type extends MessageType<ListEntitiesLockResponse> {
    constructor() {
        super("ListEntitiesLockResponse", [
            { no: 1, name: "object_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "key", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ },
            { no: 3, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "unique_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "icon", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "disabled_by_default", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "entity_category", kind: "enum", T: () => ["EntityCategory", EntityCategory, "ENTITY_CATEGORY_"] },
            { no: 8, name: "assumed_state", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "supports_open", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 10, name: "requires_code", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 11, name: "code_format", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { id: 58, source: "SOURCE_SERVER", ifdef: "USE_LOCK" });
    }
    create(value?: PartialMessage<ListEntitiesLockResponse>): ListEntitiesLockResponse {
        const message = { objectId: "", key: 0, name: "", uniqueId: "", icon: "", disabledByDefault: false, entityCategory: 0, assumedState: false, supportsOpen: false, requiresCode: false, codeFormat: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListEntitiesLockResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListEntitiesLockResponse): ListEntitiesLockResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string object_id */ 1:
                    message.objectId = reader.string();
                    break;
                case /* fixed32 key */ 2:
                    message.key = reader.fixed32();
                    break;
                case /* string name */ 3:
                    message.name = reader.string();
                    break;
                case /* string unique_id */ 4:
                    message.uniqueId = reader.string();
                    break;
                case /* string icon */ 5:
                    message.icon = reader.string();
                    break;
                case /* bool disabled_by_default */ 6:
                    message.disabledByDefault = reader.bool();
                    break;
                case /* EntityCategory entity_category */ 7:
                    message.entityCategory = reader.int32();
                    break;
                case /* bool assumed_state */ 8:
                    message.assumedState = reader.bool();
                    break;
                case /* bool supports_open */ 9:
                    message.supportsOpen = reader.bool();
                    break;
                case /* bool requires_code */ 10:
                    message.requiresCode = reader.bool();
                    break;
                case /* string code_format */ 11:
                    message.codeFormat = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListEntitiesLockResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string object_id = 1; */
        if (message.objectId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.objectId);
        /* fixed32 key = 2; */
        if (message.key !== 0)
            writer.tag(2, WireType.Bit32).fixed32(message.key);
        /* string name = 3; */
        if (message.name !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.name);
        /* string unique_id = 4; */
        if (message.uniqueId !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.uniqueId);
        /* string icon = 5; */
        if (message.icon !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.icon);
        /* bool disabled_by_default = 6; */
        if (message.disabledByDefault !== false)
            writer.tag(6, WireType.Varint).bool(message.disabledByDefault);
        /* EntityCategory entity_category = 7; */
        if (message.entityCategory !== 0)
            writer.tag(7, WireType.Varint).int32(message.entityCategory);
        /* bool assumed_state = 8; */
        if (message.assumedState !== false)
            writer.tag(8, WireType.Varint).bool(message.assumedState);
        /* bool supports_open = 9; */
        if (message.supportsOpen !== false)
            writer.tag(9, WireType.Varint).bool(message.supportsOpen);
        /* bool requires_code = 10; */
        if (message.requiresCode !== false)
            writer.tag(10, WireType.Varint).bool(message.requiresCode);
        /* string code_format = 11; */
        if (message.codeFormat !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.codeFormat);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ListEntitiesLockResponse
 */
export const ListEntitiesLockResponse = new ListEntitiesLockResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LockStateResponse$Type extends MessageType<LockStateResponse> {
    constructor() {
        super("LockStateResponse", [
            { no: 1, name: "key", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ },
            { no: 2, name: "state", kind: "enum", T: () => ["LockState", LockState, "LOCK_STATE_"] }
        ], { id: 59, source: "SOURCE_SERVER", ifdef: "USE_LOCK", no_delay: true });
    }
    create(value?: PartialMessage<LockStateResponse>): LockStateResponse {
        const message = { key: 0, state: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<LockStateResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LockStateResponse): LockStateResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* fixed32 key */ 1:
                    message.key = reader.fixed32();
                    break;
                case /* LockState state */ 2:
                    message.state = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LockStateResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* fixed32 key = 1; */
        if (message.key !== 0)
            writer.tag(1, WireType.Bit32).fixed32(message.key);
        /* LockState state = 2; */
        if (message.state !== 0)
            writer.tag(2, WireType.Varint).int32(message.state);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message LockStateResponse
 */
export const LockStateResponse = new LockStateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LockCommandRequest$Type extends MessageType<LockCommandRequest> {
    constructor() {
        super("LockCommandRequest", [
            { no: 1, name: "key", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ },
            { no: 2, name: "command", kind: "enum", T: () => ["LockCommand", LockCommand] },
            { no: 3, name: "has_code", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "code", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { id: 60, source: "SOURCE_CLIENT", ifdef: "USE_LOCK", no_delay: true });
    }
    create(value?: PartialMessage<LockCommandRequest>): LockCommandRequest {
        const message = { key: 0, command: 0, hasCode: false, code: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<LockCommandRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LockCommandRequest): LockCommandRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* fixed32 key */ 1:
                    message.key = reader.fixed32();
                    break;
                case /* LockCommand command */ 2:
                    message.command = reader.int32();
                    break;
                case /* bool has_code */ 3:
                    message.hasCode = reader.bool();
                    break;
                case /* string code */ 4:
                    message.code = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LockCommandRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* fixed32 key = 1; */
        if (message.key !== 0)
            writer.tag(1, WireType.Bit32).fixed32(message.key);
        /* LockCommand command = 2; */
        if (message.command !== 0)
            writer.tag(2, WireType.Varint).int32(message.command);
        /* bool has_code = 3; */
        if (message.hasCode !== false)
            writer.tag(3, WireType.Varint).bool(message.hasCode);
        /* string code = 4; */
        if (message.code !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.code);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message LockCommandRequest
 */
export const LockCommandRequest = new LockCommandRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListEntitiesButtonResponse$Type extends MessageType<ListEntitiesButtonResponse> {
    constructor() {
        super("ListEntitiesButtonResponse", [
            { no: 1, name: "object_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "key", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ },
            { no: 3, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "unique_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "icon", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "disabled_by_default", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "entity_category", kind: "enum", T: () => ["EntityCategory", EntityCategory, "ENTITY_CATEGORY_"] },
            { no: 8, name: "device_class", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { id: 61, source: "SOURCE_SERVER", ifdef: "USE_BUTTON" });
    }
    create(value?: PartialMessage<ListEntitiesButtonResponse>): ListEntitiesButtonResponse {
        const message = { objectId: "", key: 0, name: "", uniqueId: "", icon: "", disabledByDefault: false, entityCategory: 0, deviceClass: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListEntitiesButtonResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListEntitiesButtonResponse): ListEntitiesButtonResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string object_id */ 1:
                    message.objectId = reader.string();
                    break;
                case /* fixed32 key */ 2:
                    message.key = reader.fixed32();
                    break;
                case /* string name */ 3:
                    message.name = reader.string();
                    break;
                case /* string unique_id */ 4:
                    message.uniqueId = reader.string();
                    break;
                case /* string icon */ 5:
                    message.icon = reader.string();
                    break;
                case /* bool disabled_by_default */ 6:
                    message.disabledByDefault = reader.bool();
                    break;
                case /* EntityCategory entity_category */ 7:
                    message.entityCategory = reader.int32();
                    break;
                case /* string device_class */ 8:
                    message.deviceClass = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListEntitiesButtonResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string object_id = 1; */
        if (message.objectId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.objectId);
        /* fixed32 key = 2; */
        if (message.key !== 0)
            writer.tag(2, WireType.Bit32).fixed32(message.key);
        /* string name = 3; */
        if (message.name !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.name);
        /* string unique_id = 4; */
        if (message.uniqueId !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.uniqueId);
        /* string icon = 5; */
        if (message.icon !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.icon);
        /* bool disabled_by_default = 6; */
        if (message.disabledByDefault !== false)
            writer.tag(6, WireType.Varint).bool(message.disabledByDefault);
        /* EntityCategory entity_category = 7; */
        if (message.entityCategory !== 0)
            writer.tag(7, WireType.Varint).int32(message.entityCategory);
        /* string device_class = 8; */
        if (message.deviceClass !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.deviceClass);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ListEntitiesButtonResponse
 */
export const ListEntitiesButtonResponse = new ListEntitiesButtonResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ButtonCommandRequest$Type extends MessageType<ButtonCommandRequest> {
    constructor() {
        super("ButtonCommandRequest", [
            { no: 1, name: "key", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ }
        ], { id: 62, source: "SOURCE_CLIENT", ifdef: "USE_BUTTON", no_delay: true });
    }
    create(value?: PartialMessage<ButtonCommandRequest>): ButtonCommandRequest {
        const message = { key: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ButtonCommandRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ButtonCommandRequest): ButtonCommandRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* fixed32 key */ 1:
                    message.key = reader.fixed32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ButtonCommandRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* fixed32 key = 1; */
        if (message.key !== 0)
            writer.tag(1, WireType.Bit32).fixed32(message.key);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ButtonCommandRequest
 */
export const ButtonCommandRequest = new ButtonCommandRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListEntitiesMediaPlayerResponse$Type extends MessageType<ListEntitiesMediaPlayerResponse> {
    constructor() {
        super("ListEntitiesMediaPlayerResponse", [
            { no: 1, name: "object_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "key", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ },
            { no: 3, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "unique_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "icon", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "disabled_by_default", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "entity_category", kind: "enum", T: () => ["EntityCategory", EntityCategory, "ENTITY_CATEGORY_"] },
            { no: 8, name: "supports_pause", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ], { id: 63, source: "SOURCE_SERVER", ifdef: "USE_MEDIA_PLAYER" });
    }
    create(value?: PartialMessage<ListEntitiesMediaPlayerResponse>): ListEntitiesMediaPlayerResponse {
        const message = { objectId: "", key: 0, name: "", uniqueId: "", icon: "", disabledByDefault: false, entityCategory: 0, supportsPause: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListEntitiesMediaPlayerResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListEntitiesMediaPlayerResponse): ListEntitiesMediaPlayerResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string object_id */ 1:
                    message.objectId = reader.string();
                    break;
                case /* fixed32 key */ 2:
                    message.key = reader.fixed32();
                    break;
                case /* string name */ 3:
                    message.name = reader.string();
                    break;
                case /* string unique_id */ 4:
                    message.uniqueId = reader.string();
                    break;
                case /* string icon */ 5:
                    message.icon = reader.string();
                    break;
                case /* bool disabled_by_default */ 6:
                    message.disabledByDefault = reader.bool();
                    break;
                case /* EntityCategory entity_category */ 7:
                    message.entityCategory = reader.int32();
                    break;
                case /* bool supports_pause */ 8:
                    message.supportsPause = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListEntitiesMediaPlayerResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string object_id = 1; */
        if (message.objectId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.objectId);
        /* fixed32 key = 2; */
        if (message.key !== 0)
            writer.tag(2, WireType.Bit32).fixed32(message.key);
        /* string name = 3; */
        if (message.name !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.name);
        /* string unique_id = 4; */
        if (message.uniqueId !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.uniqueId);
        /* string icon = 5; */
        if (message.icon !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.icon);
        /* bool disabled_by_default = 6; */
        if (message.disabledByDefault !== false)
            writer.tag(6, WireType.Varint).bool(message.disabledByDefault);
        /* EntityCategory entity_category = 7; */
        if (message.entityCategory !== 0)
            writer.tag(7, WireType.Varint).int32(message.entityCategory);
        /* bool supports_pause = 8; */
        if (message.supportsPause !== false)
            writer.tag(8, WireType.Varint).bool(message.supportsPause);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ListEntitiesMediaPlayerResponse
 */
export const ListEntitiesMediaPlayerResponse = new ListEntitiesMediaPlayerResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MediaPlayerStateResponse$Type extends MessageType<MediaPlayerStateResponse> {
    constructor() {
        super("MediaPlayerStateResponse", [
            { no: 1, name: "key", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ },
            { no: 2, name: "state", kind: "enum", T: () => ["MediaPlayerState", MediaPlayerState, "MEDIA_PLAYER_STATE_"] },
            { no: 3, name: "volume", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "muted", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ], { id: 64, source: "SOURCE_SERVER", ifdef: "USE_MEDIA_PLAYER", no_delay: true });
    }
    create(value?: PartialMessage<MediaPlayerStateResponse>): MediaPlayerStateResponse {
        const message = { key: 0, state: 0, volume: 0, muted: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MediaPlayerStateResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MediaPlayerStateResponse): MediaPlayerStateResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* fixed32 key */ 1:
                    message.key = reader.fixed32();
                    break;
                case /* MediaPlayerState state */ 2:
                    message.state = reader.int32();
                    break;
                case /* float volume */ 3:
                    message.volume = reader.float();
                    break;
                case /* bool muted */ 4:
                    message.muted = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MediaPlayerStateResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* fixed32 key = 1; */
        if (message.key !== 0)
            writer.tag(1, WireType.Bit32).fixed32(message.key);
        /* MediaPlayerState state = 2; */
        if (message.state !== 0)
            writer.tag(2, WireType.Varint).int32(message.state);
        /* float volume = 3; */
        if (message.volume !== 0)
            writer.tag(3, WireType.Bit32).float(message.volume);
        /* bool muted = 4; */
        if (message.muted !== false)
            writer.tag(4, WireType.Varint).bool(message.muted);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message MediaPlayerStateResponse
 */
export const MediaPlayerStateResponse = new MediaPlayerStateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MediaPlayerCommandRequest$Type extends MessageType<MediaPlayerCommandRequest> {
    constructor() {
        super("MediaPlayerCommandRequest", [
            { no: 1, name: "key", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ },
            { no: 2, name: "has_command", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "command", kind: "enum", T: () => ["MediaPlayerCommand", MediaPlayerCommand, "MEDIA_PLAYER_COMMAND_"] },
            { no: 4, name: "has_volume", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "volume", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 6, name: "has_media_url", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "media_url", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { id: 65, source: "SOURCE_CLIENT", ifdef: "USE_MEDIA_PLAYER", no_delay: true });
    }
    create(value?: PartialMessage<MediaPlayerCommandRequest>): MediaPlayerCommandRequest {
        const message = { key: 0, hasCommand: false, command: 0, hasVolume: false, volume: 0, hasMediaUrl: false, mediaUrl: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MediaPlayerCommandRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MediaPlayerCommandRequest): MediaPlayerCommandRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* fixed32 key */ 1:
                    message.key = reader.fixed32();
                    break;
                case /* bool has_command */ 2:
                    message.hasCommand = reader.bool();
                    break;
                case /* MediaPlayerCommand command */ 3:
                    message.command = reader.int32();
                    break;
                case /* bool has_volume */ 4:
                    message.hasVolume = reader.bool();
                    break;
                case /* float volume */ 5:
                    message.volume = reader.float();
                    break;
                case /* bool has_media_url */ 6:
                    message.hasMediaUrl = reader.bool();
                    break;
                case /* string media_url */ 7:
                    message.mediaUrl = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MediaPlayerCommandRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* fixed32 key = 1; */
        if (message.key !== 0)
            writer.tag(1, WireType.Bit32).fixed32(message.key);
        /* bool has_command = 2; */
        if (message.hasCommand !== false)
            writer.tag(2, WireType.Varint).bool(message.hasCommand);
        /* MediaPlayerCommand command = 3; */
        if (message.command !== 0)
            writer.tag(3, WireType.Varint).int32(message.command);
        /* bool has_volume = 4; */
        if (message.hasVolume !== false)
            writer.tag(4, WireType.Varint).bool(message.hasVolume);
        /* float volume = 5; */
        if (message.volume !== 0)
            writer.tag(5, WireType.Bit32).float(message.volume);
        /* bool has_media_url = 6; */
        if (message.hasMediaUrl !== false)
            writer.tag(6, WireType.Varint).bool(message.hasMediaUrl);
        /* string media_url = 7; */
        if (message.mediaUrl !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.mediaUrl);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message MediaPlayerCommandRequest
 */
export const MediaPlayerCommandRequest = new MediaPlayerCommandRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeBluetoothLEAdvertisementsRequest$Type extends MessageType<SubscribeBluetoothLEAdvertisementsRequest> {
    constructor() {
        super("SubscribeBluetoothLEAdvertisementsRequest", [
            { no: 1, name: "flags", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ], { id: 66, source: "SOURCE_CLIENT" });
    }
    create(value?: PartialMessage<SubscribeBluetoothLEAdvertisementsRequest>): SubscribeBluetoothLEAdvertisementsRequest {
        const message = { flags: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SubscribeBluetoothLEAdvertisementsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeBluetoothLEAdvertisementsRequest): SubscribeBluetoothLEAdvertisementsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 flags */ 1:
                    message.flags = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubscribeBluetoothLEAdvertisementsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 flags = 1; */
        if (message.flags !== 0)
            writer.tag(1, WireType.Varint).int32(message.flags);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SubscribeBluetoothLEAdvertisementsRequest
 */
export const SubscribeBluetoothLEAdvertisementsRequest = new SubscribeBluetoothLEAdvertisementsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BluetoothServiceData$Type extends MessageType<BluetoothServiceData> {
    constructor() {
        super("BluetoothServiceData", [
            { no: 1, name: "uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "legacy_data", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "data", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<BluetoothServiceData>): BluetoothServiceData {
        const message = { uuid: "", legacyData: [], data: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BluetoothServiceData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BluetoothServiceData): BluetoothServiceData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string uuid */ 1:
                    message.uuid = reader.string();
                    break;
                case /* repeated uint32 legacy_data = 2 [packed = true];*/ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.legacyData.push(reader.uint32());
                    else
                        message.legacyData.push(reader.uint32());
                    break;
                case /* bytes data */ 3:
                    message.data = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BluetoothServiceData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string uuid = 1; */
        if (message.uuid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.uuid);
        /* repeated uint32 legacy_data = 2 [packed = true]; */
        if (message.legacyData.length) {
            writer.tag(2, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.legacyData.length; i++)
                writer.uint32(message.legacyData[i]);
            writer.join();
        }
        /* bytes data = 3; */
        if (message.data.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.data);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message BluetoothServiceData
 */
export const BluetoothServiceData = new BluetoothServiceData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BluetoothLEAdvertisementResponse$Type extends MessageType<BluetoothLEAdvertisementResponse> {
    constructor() {
        super("BluetoothLEAdvertisementResponse", [
            { no: 1, name: "address", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "name", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "rssi", kind: "scalar", T: 17 /*ScalarType.SINT32*/ },
            { no: 4, name: "service_uuids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "service_data", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => BluetoothServiceData },
            { no: 6, name: "manufacturer_data", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => BluetoothServiceData },
            { no: 7, name: "address_type", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ], { id: 67, source: "SOURCE_SERVER", ifdef: "USE_BLUETOOTH_PROXY", no_delay: true });
    }
    create(value?: PartialMessage<BluetoothLEAdvertisementResponse>): BluetoothLEAdvertisementResponse {
        const message = { address: 0n, name: new Uint8Array(0), rssi: 0, serviceUuids: [], serviceData: [], manufacturerData: [], addressType: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BluetoothLEAdvertisementResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BluetoothLEAdvertisementResponse): BluetoothLEAdvertisementResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 address */ 1:
                    message.address = reader.uint64().toBigInt();
                    break;
                case /* bytes name */ 2:
                    message.name = reader.bytes();
                    break;
                case /* sint32 rssi */ 3:
                    message.rssi = reader.sint32();
                    break;
                case /* repeated string service_uuids */ 4:
                    message.serviceUuids.push(reader.string());
                    break;
                case /* repeated BluetoothServiceData service_data */ 5:
                    message.serviceData.push(BluetoothServiceData.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated BluetoothServiceData manufacturer_data */ 6:
                    message.manufacturerData.push(BluetoothServiceData.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* uint32 address_type */ 7:
                    message.addressType = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BluetoothLEAdvertisementResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 address = 1; */
        if (message.address !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.address);
        /* bytes name = 2; */
        if (message.name.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.name);
        /* sint32 rssi = 3; */
        if (message.rssi !== 0)
            writer.tag(3, WireType.Varint).sint32(message.rssi);
        /* repeated string service_uuids = 4; */
        for (let i = 0; i < message.serviceUuids.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.serviceUuids[i]);
        /* repeated BluetoothServiceData service_data = 5; */
        for (let i = 0; i < message.serviceData.length; i++)
            BluetoothServiceData.internalBinaryWrite(message.serviceData[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* repeated BluetoothServiceData manufacturer_data = 6; */
        for (let i = 0; i < message.manufacturerData.length; i++)
            BluetoothServiceData.internalBinaryWrite(message.manufacturerData[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* uint32 address_type = 7; */
        if (message.addressType !== 0)
            writer.tag(7, WireType.Varint).uint32(message.addressType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message BluetoothLEAdvertisementResponse
 */
export const BluetoothLEAdvertisementResponse = new BluetoothLEAdvertisementResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BluetoothLERawAdvertisement$Type extends MessageType<BluetoothLERawAdvertisement> {
    constructor() {
        super("BluetoothLERawAdvertisement", [
            { no: 1, name: "address", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "rssi", kind: "scalar", T: 17 /*ScalarType.SINT32*/ },
            { no: 3, name: "address_type", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "data", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<BluetoothLERawAdvertisement>): BluetoothLERawAdvertisement {
        const message = { address: 0n, rssi: 0, addressType: 0, data: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BluetoothLERawAdvertisement>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BluetoothLERawAdvertisement): BluetoothLERawAdvertisement {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 address */ 1:
                    message.address = reader.uint64().toBigInt();
                    break;
                case /* sint32 rssi */ 2:
                    message.rssi = reader.sint32();
                    break;
                case /* uint32 address_type */ 3:
                    message.addressType = reader.uint32();
                    break;
                case /* bytes data */ 4:
                    message.data = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BluetoothLERawAdvertisement, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 address = 1; */
        if (message.address !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.address);
        /* sint32 rssi = 2; */
        if (message.rssi !== 0)
            writer.tag(2, WireType.Varint).sint32(message.rssi);
        /* uint32 address_type = 3; */
        if (message.addressType !== 0)
            writer.tag(3, WireType.Varint).uint32(message.addressType);
        /* bytes data = 4; */
        if (message.data.length)
            writer.tag(4, WireType.LengthDelimited).bytes(message.data);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message BluetoothLERawAdvertisement
 */
export const BluetoothLERawAdvertisement = new BluetoothLERawAdvertisement$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BluetoothLERawAdvertisementsResponse$Type extends MessageType<BluetoothLERawAdvertisementsResponse> {
    constructor() {
        super("BluetoothLERawAdvertisementsResponse", [
            { no: 1, name: "advertisements", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => BluetoothLERawAdvertisement }
        ], { id: 93, source: "SOURCE_SERVER", ifdef: "USE_BLUETOOTH_PROXY", no_delay: true });
    }
    create(value?: PartialMessage<BluetoothLERawAdvertisementsResponse>): BluetoothLERawAdvertisementsResponse {
        const message = { advertisements: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BluetoothLERawAdvertisementsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BluetoothLERawAdvertisementsResponse): BluetoothLERawAdvertisementsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated BluetoothLERawAdvertisement advertisements */ 1:
                    message.advertisements.push(BluetoothLERawAdvertisement.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BluetoothLERawAdvertisementsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated BluetoothLERawAdvertisement advertisements = 1; */
        for (let i = 0; i < message.advertisements.length; i++)
            BluetoothLERawAdvertisement.internalBinaryWrite(message.advertisements[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message BluetoothLERawAdvertisementsResponse
 */
export const BluetoothLERawAdvertisementsResponse = new BluetoothLERawAdvertisementsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BluetoothDeviceRequest$Type extends MessageType<BluetoothDeviceRequest> {
    constructor() {
        super("BluetoothDeviceRequest", [
            { no: 1, name: "address", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "request_type", kind: "enum", T: () => ["BluetoothDeviceRequestType", BluetoothDeviceRequestType, "BLUETOOTH_DEVICE_REQUEST_TYPE_"] },
            { no: 3, name: "has_address_type", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "address_type", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ], { id: 68, source: "SOURCE_CLIENT", ifdef: "USE_BLUETOOTH_PROXY" });
    }
    create(value?: PartialMessage<BluetoothDeviceRequest>): BluetoothDeviceRequest {
        const message = { address: 0n, requestType: 0, hasAddressType: false, addressType: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BluetoothDeviceRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BluetoothDeviceRequest): BluetoothDeviceRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 address */ 1:
                    message.address = reader.uint64().toBigInt();
                    break;
                case /* BluetoothDeviceRequestType request_type */ 2:
                    message.requestType = reader.int32();
                    break;
                case /* bool has_address_type */ 3:
                    message.hasAddressType = reader.bool();
                    break;
                case /* uint32 address_type */ 4:
                    message.addressType = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BluetoothDeviceRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 address = 1; */
        if (message.address !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.address);
        /* BluetoothDeviceRequestType request_type = 2; */
        if (message.requestType !== 0)
            writer.tag(2, WireType.Varint).int32(message.requestType);
        /* bool has_address_type = 3; */
        if (message.hasAddressType !== false)
            writer.tag(3, WireType.Varint).bool(message.hasAddressType);
        /* uint32 address_type = 4; */
        if (message.addressType !== 0)
            writer.tag(4, WireType.Varint).uint32(message.addressType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message BluetoothDeviceRequest
 */
export const BluetoothDeviceRequest = new BluetoothDeviceRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BluetoothDeviceConnectionResponse$Type extends MessageType<BluetoothDeviceConnectionResponse> {
    constructor() {
        super("BluetoothDeviceConnectionResponse", [
            { no: 1, name: "address", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "connected", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "mtu", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "error", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ], { id: 69, source: "SOURCE_SERVER", ifdef: "USE_BLUETOOTH_PROXY" });
    }
    create(value?: PartialMessage<BluetoothDeviceConnectionResponse>): BluetoothDeviceConnectionResponse {
        const message = { address: 0n, connected: false, mtu: 0, error: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BluetoothDeviceConnectionResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BluetoothDeviceConnectionResponse): BluetoothDeviceConnectionResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 address */ 1:
                    message.address = reader.uint64().toBigInt();
                    break;
                case /* bool connected */ 2:
                    message.connected = reader.bool();
                    break;
                case /* uint32 mtu */ 3:
                    message.mtu = reader.uint32();
                    break;
                case /* int32 error */ 4:
                    message.error = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BluetoothDeviceConnectionResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 address = 1; */
        if (message.address !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.address);
        /* bool connected = 2; */
        if (message.connected !== false)
            writer.tag(2, WireType.Varint).bool(message.connected);
        /* uint32 mtu = 3; */
        if (message.mtu !== 0)
            writer.tag(3, WireType.Varint).uint32(message.mtu);
        /* int32 error = 4; */
        if (message.error !== 0)
            writer.tag(4, WireType.Varint).int32(message.error);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message BluetoothDeviceConnectionResponse
 */
export const BluetoothDeviceConnectionResponse = new BluetoothDeviceConnectionResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BluetoothGATTGetServicesRequest$Type extends MessageType<BluetoothGATTGetServicesRequest> {
    constructor() {
        super("BluetoothGATTGetServicesRequest", [
            { no: 1, name: "address", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ], { id: 70, source: "SOURCE_CLIENT", ifdef: "USE_BLUETOOTH_PROXY" });
    }
    create(value?: PartialMessage<BluetoothGATTGetServicesRequest>): BluetoothGATTGetServicesRequest {
        const message = { address: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BluetoothGATTGetServicesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BluetoothGATTGetServicesRequest): BluetoothGATTGetServicesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 address */ 1:
                    message.address = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BluetoothGATTGetServicesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 address = 1; */
        if (message.address !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.address);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message BluetoothGATTGetServicesRequest
 */
export const BluetoothGATTGetServicesRequest = new BluetoothGATTGetServicesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BluetoothGATTDescriptor$Type extends MessageType<BluetoothGATTDescriptor> {
    constructor() {
        super("BluetoothGATTDescriptor", [
            { no: 1, name: "uuid", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "handle", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<BluetoothGATTDescriptor>): BluetoothGATTDescriptor {
        const message = { uuid: [], handle: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BluetoothGATTDescriptor>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BluetoothGATTDescriptor): BluetoothGATTDescriptor {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated uint64 uuid */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.uuid.push(reader.uint64().toBigInt());
                    else
                        message.uuid.push(reader.uint64().toBigInt());
                    break;
                case /* uint32 handle */ 2:
                    message.handle = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BluetoothGATTDescriptor, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated uint64 uuid = 1; */
        if (message.uuid.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.uuid.length; i++)
                writer.uint64(message.uuid[i]);
            writer.join();
        }
        /* uint32 handle = 2; */
        if (message.handle !== 0)
            writer.tag(2, WireType.Varint).uint32(message.handle);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message BluetoothGATTDescriptor
 */
export const BluetoothGATTDescriptor = new BluetoothGATTDescriptor$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BluetoothGATTCharacteristic$Type extends MessageType<BluetoothGATTCharacteristic> {
    constructor() {
        super("BluetoothGATTCharacteristic", [
            { no: 1, name: "uuid", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "handle", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "properties", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "descriptors", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => BluetoothGATTDescriptor }
        ]);
    }
    create(value?: PartialMessage<BluetoothGATTCharacteristic>): BluetoothGATTCharacteristic {
        const message = { uuid: [], handle: 0, properties: 0, descriptors: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BluetoothGATTCharacteristic>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BluetoothGATTCharacteristic): BluetoothGATTCharacteristic {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated uint64 uuid */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.uuid.push(reader.uint64().toBigInt());
                    else
                        message.uuid.push(reader.uint64().toBigInt());
                    break;
                case /* uint32 handle */ 2:
                    message.handle = reader.uint32();
                    break;
                case /* uint32 properties */ 3:
                    message.properties = reader.uint32();
                    break;
                case /* repeated BluetoothGATTDescriptor descriptors */ 4:
                    message.descriptors.push(BluetoothGATTDescriptor.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BluetoothGATTCharacteristic, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated uint64 uuid = 1; */
        if (message.uuid.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.uuid.length; i++)
                writer.uint64(message.uuid[i]);
            writer.join();
        }
        /* uint32 handle = 2; */
        if (message.handle !== 0)
            writer.tag(2, WireType.Varint).uint32(message.handle);
        /* uint32 properties = 3; */
        if (message.properties !== 0)
            writer.tag(3, WireType.Varint).uint32(message.properties);
        /* repeated BluetoothGATTDescriptor descriptors = 4; */
        for (let i = 0; i < message.descriptors.length; i++)
            BluetoothGATTDescriptor.internalBinaryWrite(message.descriptors[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message BluetoothGATTCharacteristic
 */
export const BluetoothGATTCharacteristic = new BluetoothGATTCharacteristic$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BluetoothGATTService$Type extends MessageType<BluetoothGATTService> {
    constructor() {
        super("BluetoothGATTService", [
            { no: 1, name: "uuid", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "handle", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "characteristics", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => BluetoothGATTCharacteristic }
        ]);
    }
    create(value?: PartialMessage<BluetoothGATTService>): BluetoothGATTService {
        const message = { uuid: [], handle: 0, characteristics: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BluetoothGATTService>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BluetoothGATTService): BluetoothGATTService {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated uint64 uuid */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.uuid.push(reader.uint64().toBigInt());
                    else
                        message.uuid.push(reader.uint64().toBigInt());
                    break;
                case /* uint32 handle */ 2:
                    message.handle = reader.uint32();
                    break;
                case /* repeated BluetoothGATTCharacteristic characteristics */ 3:
                    message.characteristics.push(BluetoothGATTCharacteristic.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BluetoothGATTService, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated uint64 uuid = 1; */
        if (message.uuid.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.uuid.length; i++)
                writer.uint64(message.uuid[i]);
            writer.join();
        }
        /* uint32 handle = 2; */
        if (message.handle !== 0)
            writer.tag(2, WireType.Varint).uint32(message.handle);
        /* repeated BluetoothGATTCharacteristic characteristics = 3; */
        for (let i = 0; i < message.characteristics.length; i++)
            BluetoothGATTCharacteristic.internalBinaryWrite(message.characteristics[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message BluetoothGATTService
 */
export const BluetoothGATTService = new BluetoothGATTService$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BluetoothGATTGetServicesResponse$Type extends MessageType<BluetoothGATTGetServicesResponse> {
    constructor() {
        super("BluetoothGATTGetServicesResponse", [
            { no: 1, name: "address", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "services", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => BluetoothGATTService }
        ], { id: 71, source: "SOURCE_SERVER", ifdef: "USE_BLUETOOTH_PROXY" });
    }
    create(value?: PartialMessage<BluetoothGATTGetServicesResponse>): BluetoothGATTGetServicesResponse {
        const message = { address: 0n, services: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BluetoothGATTGetServicesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BluetoothGATTGetServicesResponse): BluetoothGATTGetServicesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 address */ 1:
                    message.address = reader.uint64().toBigInt();
                    break;
                case /* repeated BluetoothGATTService services */ 2:
                    message.services.push(BluetoothGATTService.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BluetoothGATTGetServicesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 address = 1; */
        if (message.address !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.address);
        /* repeated BluetoothGATTService services = 2; */
        for (let i = 0; i < message.services.length; i++)
            BluetoothGATTService.internalBinaryWrite(message.services[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message BluetoothGATTGetServicesResponse
 */
export const BluetoothGATTGetServicesResponse = new BluetoothGATTGetServicesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BluetoothGATTGetServicesDoneResponse$Type extends MessageType<BluetoothGATTGetServicesDoneResponse> {
    constructor() {
        super("BluetoothGATTGetServicesDoneResponse", [
            { no: 1, name: "address", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ], { id: 72, source: "SOURCE_SERVER", ifdef: "USE_BLUETOOTH_PROXY" });
    }
    create(value?: PartialMessage<BluetoothGATTGetServicesDoneResponse>): BluetoothGATTGetServicesDoneResponse {
        const message = { address: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BluetoothGATTGetServicesDoneResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BluetoothGATTGetServicesDoneResponse): BluetoothGATTGetServicesDoneResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 address */ 1:
                    message.address = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BluetoothGATTGetServicesDoneResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 address = 1; */
        if (message.address !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.address);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message BluetoothGATTGetServicesDoneResponse
 */
export const BluetoothGATTGetServicesDoneResponse = new BluetoothGATTGetServicesDoneResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BluetoothGATTReadRequest$Type extends MessageType<BluetoothGATTReadRequest> {
    constructor() {
        super("BluetoothGATTReadRequest", [
            { no: 1, name: "address", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "handle", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ], { id: 73, source: "SOURCE_CLIENT", ifdef: "USE_BLUETOOTH_PROXY" });
    }
    create(value?: PartialMessage<BluetoothGATTReadRequest>): BluetoothGATTReadRequest {
        const message = { address: 0n, handle: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BluetoothGATTReadRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BluetoothGATTReadRequest): BluetoothGATTReadRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 address */ 1:
                    message.address = reader.uint64().toBigInt();
                    break;
                case /* uint32 handle */ 2:
                    message.handle = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BluetoothGATTReadRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 address = 1; */
        if (message.address !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.address);
        /* uint32 handle = 2; */
        if (message.handle !== 0)
            writer.tag(2, WireType.Varint).uint32(message.handle);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message BluetoothGATTReadRequest
 */
export const BluetoothGATTReadRequest = new BluetoothGATTReadRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BluetoothGATTReadResponse$Type extends MessageType<BluetoothGATTReadResponse> {
    constructor() {
        super("BluetoothGATTReadResponse", [
            { no: 1, name: "address", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "handle", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "data", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ], { id: 74, source: "SOURCE_SERVER", ifdef: "USE_BLUETOOTH_PROXY" });
    }
    create(value?: PartialMessage<BluetoothGATTReadResponse>): BluetoothGATTReadResponse {
        const message = { address: 0n, handle: 0, data: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BluetoothGATTReadResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BluetoothGATTReadResponse): BluetoothGATTReadResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 address */ 1:
                    message.address = reader.uint64().toBigInt();
                    break;
                case /* uint32 handle */ 2:
                    message.handle = reader.uint32();
                    break;
                case /* bytes data */ 3:
                    message.data = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BluetoothGATTReadResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 address = 1; */
        if (message.address !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.address);
        /* uint32 handle = 2; */
        if (message.handle !== 0)
            writer.tag(2, WireType.Varint).uint32(message.handle);
        /* bytes data = 3; */
        if (message.data.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.data);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message BluetoothGATTReadResponse
 */
export const BluetoothGATTReadResponse = new BluetoothGATTReadResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BluetoothGATTWriteRequest$Type extends MessageType<BluetoothGATTWriteRequest> {
    constructor() {
        super("BluetoothGATTWriteRequest", [
            { no: 1, name: "address", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "handle", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "response", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "data", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ], { id: 75, source: "SOURCE_CLIENT", ifdef: "USE_BLUETOOTH_PROXY" });
    }
    create(value?: PartialMessage<BluetoothGATTWriteRequest>): BluetoothGATTWriteRequest {
        const message = { address: 0n, handle: 0, response: false, data: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BluetoothGATTWriteRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BluetoothGATTWriteRequest): BluetoothGATTWriteRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 address */ 1:
                    message.address = reader.uint64().toBigInt();
                    break;
                case /* uint32 handle */ 2:
                    message.handle = reader.uint32();
                    break;
                case /* bool response */ 3:
                    message.response = reader.bool();
                    break;
                case /* bytes data */ 4:
                    message.data = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BluetoothGATTWriteRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 address = 1; */
        if (message.address !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.address);
        /* uint32 handle = 2; */
        if (message.handle !== 0)
            writer.tag(2, WireType.Varint).uint32(message.handle);
        /* bool response = 3; */
        if (message.response !== false)
            writer.tag(3, WireType.Varint).bool(message.response);
        /* bytes data = 4; */
        if (message.data.length)
            writer.tag(4, WireType.LengthDelimited).bytes(message.data);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message BluetoothGATTWriteRequest
 */
export const BluetoothGATTWriteRequest = new BluetoothGATTWriteRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BluetoothGATTReadDescriptorRequest$Type extends MessageType<BluetoothGATTReadDescriptorRequest> {
    constructor() {
        super("BluetoothGATTReadDescriptorRequest", [
            { no: 1, name: "address", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "handle", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ], { id: 76, source: "SOURCE_CLIENT", ifdef: "USE_BLUETOOTH_PROXY" });
    }
    create(value?: PartialMessage<BluetoothGATTReadDescriptorRequest>): BluetoothGATTReadDescriptorRequest {
        const message = { address: 0n, handle: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BluetoothGATTReadDescriptorRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BluetoothGATTReadDescriptorRequest): BluetoothGATTReadDescriptorRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 address */ 1:
                    message.address = reader.uint64().toBigInt();
                    break;
                case /* uint32 handle */ 2:
                    message.handle = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BluetoothGATTReadDescriptorRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 address = 1; */
        if (message.address !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.address);
        /* uint32 handle = 2; */
        if (message.handle !== 0)
            writer.tag(2, WireType.Varint).uint32(message.handle);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message BluetoothGATTReadDescriptorRequest
 */
export const BluetoothGATTReadDescriptorRequest = new BluetoothGATTReadDescriptorRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BluetoothGATTWriteDescriptorRequest$Type extends MessageType<BluetoothGATTWriteDescriptorRequest> {
    constructor() {
        super("BluetoothGATTWriteDescriptorRequest", [
            { no: 1, name: "address", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "handle", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "data", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ], { id: 77, source: "SOURCE_CLIENT", ifdef: "USE_BLUETOOTH_PROXY" });
    }
    create(value?: PartialMessage<BluetoothGATTWriteDescriptorRequest>): BluetoothGATTWriteDescriptorRequest {
        const message = { address: 0n, handle: 0, data: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BluetoothGATTWriteDescriptorRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BluetoothGATTWriteDescriptorRequest): BluetoothGATTWriteDescriptorRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 address */ 1:
                    message.address = reader.uint64().toBigInt();
                    break;
                case /* uint32 handle */ 2:
                    message.handle = reader.uint32();
                    break;
                case /* bytes data */ 3:
                    message.data = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BluetoothGATTWriteDescriptorRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 address = 1; */
        if (message.address !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.address);
        /* uint32 handle = 2; */
        if (message.handle !== 0)
            writer.tag(2, WireType.Varint).uint32(message.handle);
        /* bytes data = 3; */
        if (message.data.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.data);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message BluetoothGATTWriteDescriptorRequest
 */
export const BluetoothGATTWriteDescriptorRequest = new BluetoothGATTWriteDescriptorRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BluetoothGATTNotifyRequest$Type extends MessageType<BluetoothGATTNotifyRequest> {
    constructor() {
        super("BluetoothGATTNotifyRequest", [
            { no: 1, name: "address", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "handle", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "enable", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ], { id: 78, source: "SOURCE_CLIENT", ifdef: "USE_BLUETOOTH_PROXY" });
    }
    create(value?: PartialMessage<BluetoothGATTNotifyRequest>): BluetoothGATTNotifyRequest {
        const message = { address: 0n, handle: 0, enable: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BluetoothGATTNotifyRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BluetoothGATTNotifyRequest): BluetoothGATTNotifyRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 address */ 1:
                    message.address = reader.uint64().toBigInt();
                    break;
                case /* uint32 handle */ 2:
                    message.handle = reader.uint32();
                    break;
                case /* bool enable */ 3:
                    message.enable = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BluetoothGATTNotifyRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 address = 1; */
        if (message.address !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.address);
        /* uint32 handle = 2; */
        if (message.handle !== 0)
            writer.tag(2, WireType.Varint).uint32(message.handle);
        /* bool enable = 3; */
        if (message.enable !== false)
            writer.tag(3, WireType.Varint).bool(message.enable);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message BluetoothGATTNotifyRequest
 */
export const BluetoothGATTNotifyRequest = new BluetoothGATTNotifyRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BluetoothGATTNotifyDataResponse$Type extends MessageType<BluetoothGATTNotifyDataResponse> {
    constructor() {
        super("BluetoothGATTNotifyDataResponse", [
            { no: 1, name: "address", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "handle", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "data", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ], { id: 79, source: "SOURCE_SERVER", ifdef: "USE_BLUETOOTH_PROXY" });
    }
    create(value?: PartialMessage<BluetoothGATTNotifyDataResponse>): BluetoothGATTNotifyDataResponse {
        const message = { address: 0n, handle: 0, data: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BluetoothGATTNotifyDataResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BluetoothGATTNotifyDataResponse): BluetoothGATTNotifyDataResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 address */ 1:
                    message.address = reader.uint64().toBigInt();
                    break;
                case /* uint32 handle */ 2:
                    message.handle = reader.uint32();
                    break;
                case /* bytes data */ 3:
                    message.data = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BluetoothGATTNotifyDataResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 address = 1; */
        if (message.address !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.address);
        /* uint32 handle = 2; */
        if (message.handle !== 0)
            writer.tag(2, WireType.Varint).uint32(message.handle);
        /* bytes data = 3; */
        if (message.data.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.data);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message BluetoothGATTNotifyDataResponse
 */
export const BluetoothGATTNotifyDataResponse = new BluetoothGATTNotifyDataResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeBluetoothConnectionsFreeRequest$Type extends MessageType<SubscribeBluetoothConnectionsFreeRequest> {
    constructor() {
        super("SubscribeBluetoothConnectionsFreeRequest", [], { id: 80, source: "SOURCE_CLIENT", ifdef: "USE_BLUETOOTH_PROXY" });
    }
    create(value?: PartialMessage<SubscribeBluetoothConnectionsFreeRequest>): SubscribeBluetoothConnectionsFreeRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SubscribeBluetoothConnectionsFreeRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeBluetoothConnectionsFreeRequest): SubscribeBluetoothConnectionsFreeRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: SubscribeBluetoothConnectionsFreeRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SubscribeBluetoothConnectionsFreeRequest
 */
export const SubscribeBluetoothConnectionsFreeRequest = new SubscribeBluetoothConnectionsFreeRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BluetoothConnectionsFreeResponse$Type extends MessageType<BluetoothConnectionsFreeResponse> {
    constructor() {
        super("BluetoothConnectionsFreeResponse", [
            { no: 1, name: "free", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "limit", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ], { id: 81, source: "SOURCE_SERVER", ifdef: "USE_BLUETOOTH_PROXY" });
    }
    create(value?: PartialMessage<BluetoothConnectionsFreeResponse>): BluetoothConnectionsFreeResponse {
        const message = { free: 0, limit: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BluetoothConnectionsFreeResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BluetoothConnectionsFreeResponse): BluetoothConnectionsFreeResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 free */ 1:
                    message.free = reader.uint32();
                    break;
                case /* uint32 limit */ 2:
                    message.limit = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BluetoothConnectionsFreeResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 free = 1; */
        if (message.free !== 0)
            writer.tag(1, WireType.Varint).uint32(message.free);
        /* uint32 limit = 2; */
        if (message.limit !== 0)
            writer.tag(2, WireType.Varint).uint32(message.limit);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message BluetoothConnectionsFreeResponse
 */
export const BluetoothConnectionsFreeResponse = new BluetoothConnectionsFreeResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BluetoothGATTErrorResponse$Type extends MessageType<BluetoothGATTErrorResponse> {
    constructor() {
        super("BluetoothGATTErrorResponse", [
            { no: 1, name: "address", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "handle", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "error", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ], { id: 82, source: "SOURCE_SERVER", ifdef: "USE_BLUETOOTH_PROXY" });
    }
    create(value?: PartialMessage<BluetoothGATTErrorResponse>): BluetoothGATTErrorResponse {
        const message = { address: 0n, handle: 0, error: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BluetoothGATTErrorResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BluetoothGATTErrorResponse): BluetoothGATTErrorResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 address */ 1:
                    message.address = reader.uint64().toBigInt();
                    break;
                case /* uint32 handle */ 2:
                    message.handle = reader.uint32();
                    break;
                case /* int32 error */ 3:
                    message.error = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BluetoothGATTErrorResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 address = 1; */
        if (message.address !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.address);
        /* uint32 handle = 2; */
        if (message.handle !== 0)
            writer.tag(2, WireType.Varint).uint32(message.handle);
        /* int32 error = 3; */
        if (message.error !== 0)
            writer.tag(3, WireType.Varint).int32(message.error);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message BluetoothGATTErrorResponse
 */
export const BluetoothGATTErrorResponse = new BluetoothGATTErrorResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BluetoothGATTWriteResponse$Type extends MessageType<BluetoothGATTWriteResponse> {
    constructor() {
        super("BluetoothGATTWriteResponse", [
            { no: 1, name: "address", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "handle", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ], { id: 83, source: "SOURCE_SERVER", ifdef: "USE_BLUETOOTH_PROXY" });
    }
    create(value?: PartialMessage<BluetoothGATTWriteResponse>): BluetoothGATTWriteResponse {
        const message = { address: 0n, handle: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BluetoothGATTWriteResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BluetoothGATTWriteResponse): BluetoothGATTWriteResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 address */ 1:
                    message.address = reader.uint64().toBigInt();
                    break;
                case /* uint32 handle */ 2:
                    message.handle = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BluetoothGATTWriteResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 address = 1; */
        if (message.address !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.address);
        /* uint32 handle = 2; */
        if (message.handle !== 0)
            writer.tag(2, WireType.Varint).uint32(message.handle);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message BluetoothGATTWriteResponse
 */
export const BluetoothGATTWriteResponse = new BluetoothGATTWriteResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BluetoothGATTNotifyResponse$Type extends MessageType<BluetoothGATTNotifyResponse> {
    constructor() {
        super("BluetoothGATTNotifyResponse", [
            { no: 1, name: "address", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "handle", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ], { id: 84, source: "SOURCE_SERVER", ifdef: "USE_BLUETOOTH_PROXY" });
    }
    create(value?: PartialMessage<BluetoothGATTNotifyResponse>): BluetoothGATTNotifyResponse {
        const message = { address: 0n, handle: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BluetoothGATTNotifyResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BluetoothGATTNotifyResponse): BluetoothGATTNotifyResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 address */ 1:
                    message.address = reader.uint64().toBigInt();
                    break;
                case /* uint32 handle */ 2:
                    message.handle = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BluetoothGATTNotifyResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 address = 1; */
        if (message.address !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.address);
        /* uint32 handle = 2; */
        if (message.handle !== 0)
            writer.tag(2, WireType.Varint).uint32(message.handle);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message BluetoothGATTNotifyResponse
 */
export const BluetoothGATTNotifyResponse = new BluetoothGATTNotifyResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BluetoothDevicePairingResponse$Type extends MessageType<BluetoothDevicePairingResponse> {
    constructor() {
        super("BluetoothDevicePairingResponse", [
            { no: 1, name: "address", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "paired", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "error", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ], { id: 85, source: "SOURCE_SERVER", ifdef: "USE_BLUETOOTH_PROXY" });
    }
    create(value?: PartialMessage<BluetoothDevicePairingResponse>): BluetoothDevicePairingResponse {
        const message = { address: 0n, paired: false, error: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BluetoothDevicePairingResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BluetoothDevicePairingResponse): BluetoothDevicePairingResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 address */ 1:
                    message.address = reader.uint64().toBigInt();
                    break;
                case /* bool paired */ 2:
                    message.paired = reader.bool();
                    break;
                case /* int32 error */ 3:
                    message.error = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BluetoothDevicePairingResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 address = 1; */
        if (message.address !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.address);
        /* bool paired = 2; */
        if (message.paired !== false)
            writer.tag(2, WireType.Varint).bool(message.paired);
        /* int32 error = 3; */
        if (message.error !== 0)
            writer.tag(3, WireType.Varint).int32(message.error);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message BluetoothDevicePairingResponse
 */
export const BluetoothDevicePairingResponse = new BluetoothDevicePairingResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BluetoothDeviceUnpairingResponse$Type extends MessageType<BluetoothDeviceUnpairingResponse> {
    constructor() {
        super("BluetoothDeviceUnpairingResponse", [
            { no: 1, name: "address", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "success", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "error", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ], { id: 86, source: "SOURCE_SERVER", ifdef: "USE_BLUETOOTH_PROXY" });
    }
    create(value?: PartialMessage<BluetoothDeviceUnpairingResponse>): BluetoothDeviceUnpairingResponse {
        const message = { address: 0n, success: false, error: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BluetoothDeviceUnpairingResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BluetoothDeviceUnpairingResponse): BluetoothDeviceUnpairingResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 address */ 1:
                    message.address = reader.uint64().toBigInt();
                    break;
                case /* bool success */ 2:
                    message.success = reader.bool();
                    break;
                case /* int32 error */ 3:
                    message.error = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BluetoothDeviceUnpairingResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 address = 1; */
        if (message.address !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.address);
        /* bool success = 2; */
        if (message.success !== false)
            writer.tag(2, WireType.Varint).bool(message.success);
        /* int32 error = 3; */
        if (message.error !== 0)
            writer.tag(3, WireType.Varint).int32(message.error);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message BluetoothDeviceUnpairingResponse
 */
export const BluetoothDeviceUnpairingResponse = new BluetoothDeviceUnpairingResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UnsubscribeBluetoothLEAdvertisementsRequest$Type extends MessageType<UnsubscribeBluetoothLEAdvertisementsRequest> {
    constructor() {
        super("UnsubscribeBluetoothLEAdvertisementsRequest", [], { id: 87, source: "SOURCE_CLIENT" });
    }
    create(value?: PartialMessage<UnsubscribeBluetoothLEAdvertisementsRequest>): UnsubscribeBluetoothLEAdvertisementsRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UnsubscribeBluetoothLEAdvertisementsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UnsubscribeBluetoothLEAdvertisementsRequest): UnsubscribeBluetoothLEAdvertisementsRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: UnsubscribeBluetoothLEAdvertisementsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message UnsubscribeBluetoothLEAdvertisementsRequest
 */
export const UnsubscribeBluetoothLEAdvertisementsRequest = new UnsubscribeBluetoothLEAdvertisementsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BluetoothDeviceClearCacheResponse$Type extends MessageType<BluetoothDeviceClearCacheResponse> {
    constructor() {
        super("BluetoothDeviceClearCacheResponse", [
            { no: 1, name: "address", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "success", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "error", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ], { id: 88, source: "SOURCE_SERVER", ifdef: "USE_BLUETOOTH_PROXY" });
    }
    create(value?: PartialMessage<BluetoothDeviceClearCacheResponse>): BluetoothDeviceClearCacheResponse {
        const message = { address: 0n, success: false, error: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BluetoothDeviceClearCacheResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BluetoothDeviceClearCacheResponse): BluetoothDeviceClearCacheResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 address */ 1:
                    message.address = reader.uint64().toBigInt();
                    break;
                case /* bool success */ 2:
                    message.success = reader.bool();
                    break;
                case /* int32 error */ 3:
                    message.error = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BluetoothDeviceClearCacheResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 address = 1; */
        if (message.address !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.address);
        /* bool success = 2; */
        if (message.success !== false)
            writer.tag(2, WireType.Varint).bool(message.success);
        /* int32 error = 3; */
        if (message.error !== 0)
            writer.tag(3, WireType.Varint).int32(message.error);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message BluetoothDeviceClearCacheResponse
 */
export const BluetoothDeviceClearCacheResponse = new BluetoothDeviceClearCacheResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeVoiceAssistantRequest$Type extends MessageType<SubscribeVoiceAssistantRequest> {
    constructor() {
        super("SubscribeVoiceAssistantRequest", [
            { no: 1, name: "subscribe", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ], { id: 89, source: "SOURCE_CLIENT", ifdef: "USE_VOICE_ASSISTANT" });
    }
    create(value?: PartialMessage<SubscribeVoiceAssistantRequest>): SubscribeVoiceAssistantRequest {
        const message = { subscribe: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SubscribeVoiceAssistantRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeVoiceAssistantRequest): SubscribeVoiceAssistantRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool subscribe */ 1:
                    message.subscribe = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubscribeVoiceAssistantRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool subscribe = 1; */
        if (message.subscribe !== false)
            writer.tag(1, WireType.Varint).bool(message.subscribe);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SubscribeVoiceAssistantRequest
 */
export const SubscribeVoiceAssistantRequest = new SubscribeVoiceAssistantRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VoiceAssistantRequest$Type extends MessageType<VoiceAssistantRequest> {
    constructor() {
        super("VoiceAssistantRequest", [
            { no: 1, name: "start", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "conversation_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "use_vad", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ], { id: 90, source: "SOURCE_SERVER", ifdef: "USE_VOICE_ASSISTANT" });
    }
    create(value?: PartialMessage<VoiceAssistantRequest>): VoiceAssistantRequest {
        const message = { start: false, conversationId: "", useVad: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<VoiceAssistantRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: VoiceAssistantRequest): VoiceAssistantRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool start */ 1:
                    message.start = reader.bool();
                    break;
                case /* string conversation_id */ 2:
                    message.conversationId = reader.string();
                    break;
                case /* bool use_vad */ 3:
                    message.useVad = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: VoiceAssistantRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool start = 1; */
        if (message.start !== false)
            writer.tag(1, WireType.Varint).bool(message.start);
        /* string conversation_id = 2; */
        if (message.conversationId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.conversationId);
        /* bool use_vad = 3; */
        if (message.useVad !== false)
            writer.tag(3, WireType.Varint).bool(message.useVad);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message VoiceAssistantRequest
 */
export const VoiceAssistantRequest = new VoiceAssistantRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VoiceAssistantResponse$Type extends MessageType<VoiceAssistantResponse> {
    constructor() {
        super("VoiceAssistantResponse", [
            { no: 1, name: "port", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "error", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ], { id: 91, source: "SOURCE_CLIENT", ifdef: "USE_VOICE_ASSISTANT" });
    }
    create(value?: PartialMessage<VoiceAssistantResponse>): VoiceAssistantResponse {
        const message = { port: 0, error: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<VoiceAssistantResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: VoiceAssistantResponse): VoiceAssistantResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 port */ 1:
                    message.port = reader.uint32();
                    break;
                case /* bool error */ 2:
                    message.error = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: VoiceAssistantResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 port = 1; */
        if (message.port !== 0)
            writer.tag(1, WireType.Varint).uint32(message.port);
        /* bool error = 2; */
        if (message.error !== false)
            writer.tag(2, WireType.Varint).bool(message.error);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message VoiceAssistantResponse
 */
export const VoiceAssistantResponse = new VoiceAssistantResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VoiceAssistantEventData$Type extends MessageType<VoiceAssistantEventData> {
    constructor() {
        super("VoiceAssistantEventData", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "value", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<VoiceAssistantEventData>): VoiceAssistantEventData {
        const message = { name: "", value: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<VoiceAssistantEventData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: VoiceAssistantEventData): VoiceAssistantEventData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string value */ 2:
                    message.value = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: VoiceAssistantEventData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string value = 2; */
        if (message.value !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message VoiceAssistantEventData
 */
export const VoiceAssistantEventData = new VoiceAssistantEventData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VoiceAssistantEventResponse$Type extends MessageType<VoiceAssistantEventResponse> {
    constructor() {
        super("VoiceAssistantEventResponse", [
            { no: 1, name: "event_type", kind: "enum", T: () => ["VoiceAssistantEvent", VoiceAssistantEvent] },
            { no: 2, name: "data", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => VoiceAssistantEventData }
        ], { id: 92, source: "SOURCE_CLIENT", ifdef: "USE_VOICE_ASSISTANT" });
    }
    create(value?: PartialMessage<VoiceAssistantEventResponse>): VoiceAssistantEventResponse {
        const message = { eventType: 0, data: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<VoiceAssistantEventResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: VoiceAssistantEventResponse): VoiceAssistantEventResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* VoiceAssistantEvent event_type */ 1:
                    message.eventType = reader.int32();
                    break;
                case /* repeated VoiceAssistantEventData data */ 2:
                    message.data.push(VoiceAssistantEventData.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: VoiceAssistantEventResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* VoiceAssistantEvent event_type = 1; */
        if (message.eventType !== 0)
            writer.tag(1, WireType.Varint).int32(message.eventType);
        /* repeated VoiceAssistantEventData data = 2; */
        for (let i = 0; i < message.data.length; i++)
            VoiceAssistantEventData.internalBinaryWrite(message.data[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message VoiceAssistantEventResponse
 */
export const VoiceAssistantEventResponse = new VoiceAssistantEventResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListEntitiesAlarmControlPanelResponse$Type extends MessageType<ListEntitiesAlarmControlPanelResponse> {
    constructor() {
        super("ListEntitiesAlarmControlPanelResponse", [
            { no: 1, name: "object_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "key", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ },
            { no: 3, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "unique_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "icon", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "disabled_by_default", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "entity_category", kind: "enum", T: () => ["EntityCategory", EntityCategory, "ENTITY_CATEGORY_"] },
            { no: 8, name: "supported_features", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "requires_code", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 10, name: "requires_code_to_arm", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ], { id: 94, source: "SOURCE_SERVER", ifdef: "USE_ALARM_CONTROL_PANEL" });
    }
    create(value?: PartialMessage<ListEntitiesAlarmControlPanelResponse>): ListEntitiesAlarmControlPanelResponse {
        const message = { objectId: "", key: 0, name: "", uniqueId: "", icon: "", disabledByDefault: false, entityCategory: 0, supportedFeatures: 0, requiresCode: false, requiresCodeToArm: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListEntitiesAlarmControlPanelResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListEntitiesAlarmControlPanelResponse): ListEntitiesAlarmControlPanelResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string object_id */ 1:
                    message.objectId = reader.string();
                    break;
                case /* fixed32 key */ 2:
                    message.key = reader.fixed32();
                    break;
                case /* string name */ 3:
                    message.name = reader.string();
                    break;
                case /* string unique_id */ 4:
                    message.uniqueId = reader.string();
                    break;
                case /* string icon */ 5:
                    message.icon = reader.string();
                    break;
                case /* bool disabled_by_default */ 6:
                    message.disabledByDefault = reader.bool();
                    break;
                case /* EntityCategory entity_category */ 7:
                    message.entityCategory = reader.int32();
                    break;
                case /* uint32 supported_features */ 8:
                    message.supportedFeatures = reader.uint32();
                    break;
                case /* bool requires_code */ 9:
                    message.requiresCode = reader.bool();
                    break;
                case /* bool requires_code_to_arm */ 10:
                    message.requiresCodeToArm = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListEntitiesAlarmControlPanelResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string object_id = 1; */
        if (message.objectId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.objectId);
        /* fixed32 key = 2; */
        if (message.key !== 0)
            writer.tag(2, WireType.Bit32).fixed32(message.key);
        /* string name = 3; */
        if (message.name !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.name);
        /* string unique_id = 4; */
        if (message.uniqueId !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.uniqueId);
        /* string icon = 5; */
        if (message.icon !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.icon);
        /* bool disabled_by_default = 6; */
        if (message.disabledByDefault !== false)
            writer.tag(6, WireType.Varint).bool(message.disabledByDefault);
        /* EntityCategory entity_category = 7; */
        if (message.entityCategory !== 0)
            writer.tag(7, WireType.Varint).int32(message.entityCategory);
        /* uint32 supported_features = 8; */
        if (message.supportedFeatures !== 0)
            writer.tag(8, WireType.Varint).uint32(message.supportedFeatures);
        /* bool requires_code = 9; */
        if (message.requiresCode !== false)
            writer.tag(9, WireType.Varint).bool(message.requiresCode);
        /* bool requires_code_to_arm = 10; */
        if (message.requiresCodeToArm !== false)
            writer.tag(10, WireType.Varint).bool(message.requiresCodeToArm);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ListEntitiesAlarmControlPanelResponse
 */
export const ListEntitiesAlarmControlPanelResponse = new ListEntitiesAlarmControlPanelResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AlarmControlPanelStateResponse$Type extends MessageType<AlarmControlPanelStateResponse> {
    constructor() {
        super("AlarmControlPanelStateResponse", [
            { no: 1, name: "key", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ },
            { no: 2, name: "state", kind: "enum", T: () => ["AlarmControlPanelState", AlarmControlPanelState] }
        ], { id: 95, source: "SOURCE_SERVER", ifdef: "USE_ALARM_CONTROL_PANEL", no_delay: true });
    }
    create(value?: PartialMessage<AlarmControlPanelStateResponse>): AlarmControlPanelStateResponse {
        const message = { key: 0, state: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AlarmControlPanelStateResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AlarmControlPanelStateResponse): AlarmControlPanelStateResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* fixed32 key */ 1:
                    message.key = reader.fixed32();
                    break;
                case /* AlarmControlPanelState state */ 2:
                    message.state = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AlarmControlPanelStateResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* fixed32 key = 1; */
        if (message.key !== 0)
            writer.tag(1, WireType.Bit32).fixed32(message.key);
        /* AlarmControlPanelState state = 2; */
        if (message.state !== 0)
            writer.tag(2, WireType.Varint).int32(message.state);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AlarmControlPanelStateResponse
 */
export const AlarmControlPanelStateResponse = new AlarmControlPanelStateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AlarmControlPanelCommandRequest$Type extends MessageType<AlarmControlPanelCommandRequest> {
    constructor() {
        super("AlarmControlPanelCommandRequest", [
            { no: 1, name: "key", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ },
            { no: 2, name: "command", kind: "enum", T: () => ["AlarmControlPanelStateCommand", AlarmControlPanelStateCommand] },
            { no: 3, name: "code", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { id: 96, source: "SOURCE_CLIENT", ifdef: "USE_ALARM_CONTROL_PANEL", no_delay: true });
    }
    create(value?: PartialMessage<AlarmControlPanelCommandRequest>): AlarmControlPanelCommandRequest {
        const message = { key: 0, command: 0, code: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AlarmControlPanelCommandRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AlarmControlPanelCommandRequest): AlarmControlPanelCommandRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* fixed32 key */ 1:
                    message.key = reader.fixed32();
                    break;
                case /* AlarmControlPanelStateCommand command */ 2:
                    message.command = reader.int32();
                    break;
                case /* string code */ 3:
                    message.code = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AlarmControlPanelCommandRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* fixed32 key = 1; */
        if (message.key !== 0)
            writer.tag(1, WireType.Bit32).fixed32(message.key);
        /* AlarmControlPanelStateCommand command = 2; */
        if (message.command !== 0)
            writer.tag(2, WireType.Varint).int32(message.command);
        /* string code = 3; */
        if (message.code !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.code);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AlarmControlPanelCommandRequest
 */
export const AlarmControlPanelCommandRequest = new AlarmControlPanelCommandRequest$Type();
/**
 * @generated ServiceType for protobuf service APIConnection
 */
export const APIConnection = new ServiceType("APIConnection", [
    { name: "hello", options: { needs_setup_connection: false, needs_authentication: false }, I: HelloRequest, O: HelloResponse },
    { name: "connect", options: { needs_setup_connection: false, needs_authentication: false }, I: ConnectRequest, O: ConnectResponse },
    { name: "disconnect", options: { needs_setup_connection: false, needs_authentication: false }, I: DisconnectRequest, O: DisconnectResponse },
    { name: "ping", options: { needs_setup_connection: false, needs_authentication: false }, I: PingRequest, O: PingResponse },
    { name: "device_info", options: { needs_authentication: false }, I: DeviceInfoRequest, O: DeviceInfoResponse },
    { name: "list_entities", options: {}, I: ListEntitiesRequest, O: void$ },
    { name: "subscribe_states", options: {}, I: SubscribeStatesRequest, O: void$ },
    { name: "subscribe_logs", options: {}, I: SubscribeLogsRequest, O: void$ },
    { name: "subscribe_homeassistant_services", options: {}, I: SubscribeHomeassistantServicesRequest, O: void$ },
    { name: "subscribe_home_assistant_states", options: {}, I: SubscribeHomeAssistantStatesRequest, O: void$ },
    { name: "get_time", options: { needs_authentication: false }, I: GetTimeRequest, O: GetTimeResponse },
    { name: "execute_service", options: {}, I: ExecuteServiceRequest, O: void$ },
    { name: "cover_command", options: {}, I: CoverCommandRequest, O: void$ },
    { name: "fan_command", options: {}, I: FanCommandRequest, O: void$ },
    { name: "light_command", options: {}, I: LightCommandRequest, O: void$ },
    { name: "switch_command", options: {}, I: SwitchCommandRequest, O: void$ },
    { name: "camera_image", options: {}, I: CameraImageRequest, O: void$ },
    { name: "climate_command", options: {}, I: ClimateCommandRequest, O: void$ },
    { name: "number_command", options: {}, I: NumberCommandRequest, O: void$ },
    { name: "select_command", options: {}, I: SelectCommandRequest, O: void$ },
    { name: "siren_command", options: {}, I: SirenCommandRequest, O: void$ },
    { name: "button_command", options: {}, I: ButtonCommandRequest, O: void$ },
    { name: "lock_command", options: {}, I: LockCommandRequest, O: void$ },
    { name: "media_player_command", options: {}, I: MediaPlayerCommandRequest, O: void$ },
    { name: "subscribe_bluetooth_le_advertisements", options: {}, I: SubscribeBluetoothLEAdvertisementsRequest, O: void$ },
    { name: "bluetooth_device_request", options: {}, I: BluetoothDeviceRequest, O: void$ },
    { name: "bluetooth_gatt_get_services", options: {}, I: BluetoothGATTGetServicesRequest, O: void$ },
    { name: "bluetooth_gatt_read", options: {}, I: BluetoothGATTReadRequest, O: void$ },
    { name: "bluetooth_gatt_write", options: {}, I: BluetoothGATTWriteRequest, O: void$ },
    { name: "bluetooth_gatt_read_descriptor", options: {}, I: BluetoothGATTReadDescriptorRequest, O: void$ },
    { name: "bluetooth_gatt_write_descriptor", options: {}, I: BluetoothGATTWriteDescriptorRequest, O: void$ },
    { name: "bluetooth_gatt_notify", options: {}, I: BluetoothGATTNotifyRequest, O: void$ },
    { name: "unsubscribe_bluetooth_le_advertisements", options: {}, I: UnsubscribeBluetoothLEAdvertisementsRequest, O: void$ },
    { name: "subscribe_voice_assistant", options: {}, I: SubscribeVoiceAssistantRequest, O: void$ },
    { name: "alarm_control_panel_command", options: {}, I: AlarmControlPanelCommandRequest, O: void$ }
]);
